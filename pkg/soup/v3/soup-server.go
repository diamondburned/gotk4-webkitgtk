// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_soup3_Server_ConnectRequestStarted(gpointer, SoupServerMessage*, guintptr);
// extern void _gotk4_soup3_Server_ConnectRequestRead(gpointer, SoupServerMessage*, guintptr);
// extern void _gotk4_soup3_Server_ConnectRequestFinished(gpointer, SoupServerMessage*, guintptr);
// extern void _gotk4_soup3_Server_ConnectRequestAborted(gpointer, SoupServerMessage*, guintptr);
// extern void _gotk4_soup3_ServerWebsocketCallback(SoupServer*, SoupServerMessage*, char*, SoupWebsocketConnection*, gpointer);
// extern void _gotk4_soup3_ServerClass_request_started(SoupServer*, SoupServerMessage*);
// extern void _gotk4_soup3_ServerClass_request_read(SoupServer*, SoupServerMessage*);
// extern void _gotk4_soup3_ServerClass_request_finished(SoupServer*, SoupServerMessage*);
// extern void _gotk4_soup3_ServerClass_request_aborted(SoupServer*, SoupServerMessage*);
// extern void _gotk4_soup3_ServerCallback(SoupServer*, SoupServerMessage*, char*, GHashTable*, gpointer);
// void _gotk4_soup3_Server_virtual_request_aborted(void* fnptr, SoupServer* arg0, SoupServerMessage* arg1) {
//   ((void (*)(SoupServer*, SoupServerMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_soup3_Server_virtual_request_finished(void* fnptr, SoupServer* arg0, SoupServerMessage* arg1) {
//   ((void (*)(SoupServer*, SoupServerMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_soup3_Server_virtual_request_read(void* fnptr, SoupServer* arg0, SoupServerMessage* arg1) {
//   ((void (*)(SoupServer*, SoupServerMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_soup3_Server_virtual_request_started(void* fnptr, SoupServer* arg0, SoupServerMessage* arg1) {
//   ((void (*)(SoupServer*, SoupServerMessage*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeServerListenOptions = coreglib.Type(C.soup_server_listen_options_get_type())
	GTypeServer              = coreglib.Type(C.soup_server_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeServerListenOptions, F: marshalServerListenOptions},
		coreglib.TypeMarshaler{T: GTypeServer, F: marshalServer},
	})
}

// ServerListenOptions options to pass to server.Listen, etc.
//
// SOUP_SERVER_LISTEN_IPV4_ONLY and SOUP_SERVER_LISTEN_IPV6_ONLY only make
// sense with server.ListenAll and server.ListenLocal, not plain server.Listen
// (which simply listens on whatever kind of socket you give it). And you cannot
// specify both of them in a single call.
type ServerListenOptions C.guint

const (
	// ServerListenHTTPS: listen for https connections rather than plain http.
	ServerListenHTTPS ServerListenOptions = 0b1
	// ServerListenIPv4Only: only listen on IPv4 interfaces.
	ServerListenIPv4Only ServerListenOptions = 0b10
	// ServerListenIPv6Only: only listen on IPv6 interfaces.
	ServerListenIPv6Only ServerListenOptions = 0b100
)

func marshalServerListenOptions(p uintptr) (interface{}, error) {
	return ServerListenOptions(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ServerListenOptions.
func (s ServerListenOptions) String() string {
	if s == 0 {
		return "ServerListenOptions(0)"
	}

	var builder strings.Builder
	builder.Grow(59)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case ServerListenHTTPS:
			builder.WriteString("HTTPS|")
		case ServerListenIPv4Only:
			builder.WriteString("IPv4Only|")
		case ServerListenIPv6Only:
			builder.WriteString("IPv6Only|")
		default:
			builder.WriteString(fmt.Sprintf("ServerListenOptions(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s ServerListenOptions) Has(other ServerListenOptions) bool {
	return (s & other) == other
}

// ServerCallback: callback used to handle requests to a server.
//
// path and query contain the likewise-named components of the Request-URI,
// subject to certain assumptions. By default, server decodes all
// percent-encoding in the URI path, such that "/foo2Fbar" is treated
// the same as "/foo/bar". If your server is serving resources in some
// non-POSIX-filesystem namespace, you may want to distinguish those as two
// distinct paths. In that case, you can set the server:raw-paths property when
// creating the server, and it will leave those characters undecoded.
//
// query contains the query component of the Request-URI parsed according to
// the rules for HTML form handling. Although this is the only commonly-used
// query string format in HTTP, there is nothing that actually requires that
// HTTP URIs use that format; if your server needs to use some other format,
// you can just ignore query, and call message.GetURI and parse the URI's query
// field yourself.
//
// See server.AddHandler and server.AddEarlyHandler for details of what handlers
// can/should do.
type ServerCallback func(server *Server, msg *ServerMessage, path string, query map[string]string)

// ServerWebsocketCallback: callback used to handle WebSocket requests to a
// Server.
//
// The callback will be invoked after sending the handshake response back to the
// client (and is only invoked if the handshake was successful).
//
// path contains the path of the Request-URI, subject to the same rules as
// servercallback (qv).
type ServerWebsocketCallback func(server *Server, msg *ServerMessage, path string, connection *WebsocketConnection)

// ServerOverrides contains methods that are overridable.
type ServerOverrides struct {
	// The function takes the following parameters:
	//
	RequestAborted func(msg *ServerMessage)
	// The function takes the following parameters:
	//
	RequestFinished func(msg *ServerMessage)
	// The function takes the following parameters:
	//
	RequestRead func(msg *ServerMessage)
	// The function takes the following parameters:
	//
	RequestStarted func(msg *ServerMessage)
}

func defaultServerOverrides(v *Server) ServerOverrides {
	return ServerOverrides{
		RequestAborted:  v.requestAborted,
		RequestFinished: v.requestFinished,
		RequestRead:     v.requestRead,
		RequestStarted:  v.requestStarted,
	}
}

// Server: HTTP server.
//
// Server implements a simple HTTP server.
//
// To begin, create a server using server.New. Add at least one handler by
// calling server.AddHandler or server.AddEarlyHandler; the handler will be
// called to process any requests underneath the path you pass. (If you want all
// requests to go to the same handler, just pass "/" (or NULL) for the path.)
//
// When a new connection is accepted (or a new request is started on an existing
// persistent connection), the Server will emit server::request-started and
// then begin processing the request as described below, but note that once the
// message is assigned a status-code, then callbacks after that point will be
// skipped. Note also that it is not defined when the callbacks happen relative
// to various servermessage signals.
//
// Once the headers have been read, Server will check if there is a authdomain
// (qv) covering the Request-URI; if so, and if the message does not
// contain suitable authorization, then the authdomain will set a status of
// SOUP_STATUS_UNAUTHORIZED on the message.
//
// After checking for authorization, Server will look for "early" handlers
// (added with server.AddEarlyHandler) matching the Request-URI. If one is
// found, it will be run; in particular, this can be used to connect to signals
// to do a streaming read of the request body.
//
// (At this point, if the request headers contain Expect: 100-continue,
// and a status code has been set, then Server will skip the remaining steps and
// return the response. If the request headers contain Expect: 100-continue and
// no status code has been set, Server will return a SOUP_STATUS_CONTINUE status
// before continuing.)
//
// The server will then read in the response body (if present). At this point,
// if there are no handlers at all defined for the Request-URI, then the server
// will return SOUP_STATUS_NOT_FOUND to the client.
//
// Otherwise (assuming no previous step assigned a status to the message)
// any "normal" handlers (added with server.AddHandler) for the message's
// Request-URI will be run.
//
// Then, if the path has a WebSocket handler registered (and has not
// yet been assigned a status), Server will attempt to validate the
// WebSocket handshake, filling in the response and setting a status of
// SOUP_STATUS_SWITCHING_PROTOCOLS or SOUP_STATUS_BAD_REQUEST accordingly.
//
// If the message still has no status code at this point (and has not been
// paused with servermessage.Pause), then it will be given a status of
// SOUP_STATUS_INTERNAL_SERVER_ERROR (because at least one handler ran,
// but returned without assigning a status).
//
// Finally, the server will emit server::request-finished (or
// server::request-aborted if an I/O error occurred before handling was
// completed).
//
// If you want to handle the special "*" URI (eg, "OPTIONS *"), you must
// explicitly register a handler for "*"; the default handler will not be used
// for that case.
//
// If you want to process https connections in addition to (or instead of) http
// connections, you can set the server:tls-certificate property.
//
// Once the server is set up, make one or more calls to server.Listen,
// server.ListenLocal, or server.ListenAll to tell it where to listen for
// connections. (All ports on a Server use the same handlers; if you need to
// handle some ports differently, such as returning different data for http
// and https, you'll need to create multiple SoupServers, or else check the
// passed-in URI in the handler function.).
//
// Server will begin processing connections as soon as you return to (or start)
// the main loop for the current thread-default glib.MainContext.
type Server struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Server)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Server, *ServerClass, ServerOverrides](
		GTypeServer,
		initServerClass,
		wrapServer,
		defaultServerOverrides,
	)
}

func initServerClass(gclass unsafe.Pointer, overrides ServerOverrides, classInitFunc func(*ServerClass)) {
	pclass := (*C.SoupServerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeServer))))

	if overrides.RequestAborted != nil {
		pclass.request_aborted = (*[0]byte)(C._gotk4_soup3_ServerClass_request_aborted)
	}

	if overrides.RequestFinished != nil {
		pclass.request_finished = (*[0]byte)(C._gotk4_soup3_ServerClass_request_finished)
	}

	if overrides.RequestRead != nil {
		pclass.request_read = (*[0]byte)(C._gotk4_soup3_ServerClass_request_read)
	}

	if overrides.RequestStarted != nil {
		pclass.request_started = (*[0]byte)(C._gotk4_soup3_ServerClass_request_started)
	}

	if classInitFunc != nil {
		class := (*ServerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapServer(obj *coreglib.Object) *Server {
	return &Server{
		Object: obj,
	}
}

func marshalServer(p uintptr) (interface{}, error) {
	return wrapServer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectRequestAborted is emitted when processing has failed for a message.
//
// This could mean either that it could not be read (if server::request-read has
// not been emitted for it yet), or that the response could not be written back
// (if server::request-read has been emitted but server::request-finished has
// not been).
//
// message is in an undefined state when this signal is emitted; the signal
// exists primarily to allow the server to free any state that it may have
// allocated in server::request-started.
func (server *Server) ConnectRequestAborted(f func(message *ServerMessage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-aborted", false, unsafe.Pointer(C._gotk4_soup3_Server_ConnectRequestAborted), f)
}

// ConnectRequestFinished is emitted when the server has finished writing a
// response to a request.
func (server *Server) ConnectRequestFinished(f func(message *ServerMessage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-finished", false, unsafe.Pointer(C._gotk4_soup3_Server_ConnectRequestFinished), f)
}

// ConnectRequestRead is emitted when the server has successfully read a
// request.
//
// message will have all of its request-side information filled in, and if the
// message was authenticated, client will have information about that. This
// signal is emitted before any (non-early) handlers are called for the message,
// and if it sets the message's #status_code, then normal handler processing
// will be skipped.
func (server *Server) ConnectRequestRead(f func(message *ServerMessage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-read", false, unsafe.Pointer(C._gotk4_soup3_Server_ConnectRequestRead), f)
}

// ConnectRequestStarted is emitted when the server has started reading a new
// request.
//
// message will be completely blank; not even the Request-Line will have been
// read yet. About the only thing you can usefully do with it is connect to its
// signals.
//
// If the request is read successfully, this will eventually be followed by
// a server::request_read signal. If a response is then sent, the request
// processing will end with a server::request-finished signal. If a network
// error occurs, the processing will instead end with server::request-aborted.
func (server *Server) ConnectRequestStarted(f func(message *ServerMessage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-started", false, unsafe.Pointer(C._gotk4_soup3_Server_ConnectRequestStarted), f)
}

// AcceptIostream adds a new client stream to the server.
//
// The function takes the following parameters:
//
//   - stream: OStream.
//   - localAddr (optional): local Address associated with the stream.
//   - remoteAddr (optional): remote Address associated with the stream.
//
func (server *Server) AcceptIostream(stream gio.IOStreamer, localAddr, remoteAddr gio.SocketAddresser) error {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.GIOStream      // out
	var _arg2 *C.GSocketAddress // out
	var _arg3 *C.GSocketAddress // out
	var _cerr *C.GError         // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if localAddr != nil {
		_arg2 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(localAddr).Native()))
	}
	if remoteAddr != nil {
		_arg3 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(remoteAddr).Native()))
	}

	C.soup_server_accept_iostream(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(localAddr)
	runtime.KeepAlive(remoteAddr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddAuthDomain adds an authentication domain to server.
//
// Each auth domain will have the chance to require authentication for each
// request that comes in; normally auth domains will require authentication for
// requests on certain paths that they have been set up to watch, or that meet
// other criteria set by the caller. If an auth domain determines that a request
// requires authentication (and the request doesn't contain authentication),
// server will automatically reject the request with an appropriate status (401
// Unauthorized or 407 Proxy Authentication Required). If the request used the
// SoupServer:100-continue Expectation, server will reject it before the request
// body is sent.
//
// The function takes the following parameters:
//
//   - authDomain: AuthDomain.
//
func (server *Server) AddAuthDomain(authDomain AuthDomainer) {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.SoupAuthDomain // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(authDomain).Native()))

	C.soup_server_add_auth_domain(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(authDomain)
}

// AddEarlyHandler adds an "early" handler to server for requests prefixed by
// path.
//
// Note that "normal" and "early" handlers are matched up together, so if you
// add a normal handler for "/foo" and an early handler for "/foo/bar", then a
// request to "/foo/bar" (or any path below it) will run only the early handler.
// (But if you add both handlers at the same path, then both will get run.)
//
// For requests under path (that have not already been assigned a status code by
// a authdomain or a signal handler), callback will be invoked after receiving
// the request headers, but before receiving the request body; the message's
// method and request-headers properties will be set.
//
// Early handlers are generally used for processing requests with request bodies
// in a streaming fashion. If you determine that the request will contain a
// message body, normally you would call messagebody.SetAccumulate on the
// message's request-body to turn off request-body accumulation, and connect
// to the message's servermessage::got-chunk signal to process each chunk as it
// comes in.
//
// To complete the message processing after the full message body has been read,
// you can either also connect to servermessage::got-body, or else you can
// register a non-early handler for path as well. As long as you have not set
// the status-code by the time servermessage::got-body is emitted, the non-early
// handler will be run as well.
//
// The function takes the following parameters:
//
//   - path (optional): toplevel path for the handler.
//   - callback to invoke for requests under path.
//
func (server *Server) AddEarlyHandler(path string, callback ServerCallback) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.char              // out
	var _arg2 C.SoupServerCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*[0]byte)(C._gotk4_soup3_ServerCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_early_handler(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(callback)
}

// AddHandler adds a handler to server for requests prefixed by path.
//
// If path is NULL or "/", then this will be the default handler for all
// requests that don't have a more specific handler. (Note though that if you
// want to handle requests to the special "*" URI, you must explicitly register
// a handler for "*"; the default handler will not be used for that case.)
//
// For requests under path (that have not already been assigned a status code
// by a authdomain, an early server handler, or a signal handler), callback
// will be invoked after receiving the request body; the servermessage's method,
// request-headers, and request-body properties will be set.
//
// After determining what to do with the request, the callback must at a minimum
// call servermessage.SetStatus on the message to set the response status code.
// Additionally, it may set response headers and/or fill in the response body.
//
// If the callback cannot fully fill in the response before returning (eg, if it
// needs to wait for information from a database, or another network server),
// it should call servermessage.Pause to tell server to not send the response
// right away. When the response is ready, call servermessage.Unpause to cause
// it to be sent.
//
// To send the response body a bit at a time using "chunked" encoding,
// first call messageheaders.SetEncoding to set SOUP_ENCODING_CHUNKED on the
// response-headers. Then call messagebody.Append (or messagebody.AppendBytes))
// to append each chunk as it becomes ready, and servermessage.Unpause to make
// sure it's running. (The server will automatically pause the message if it is
// using chunked encoding but no more chunks are available.) When you are done,
// call messagebody.Complete to indicate that no more chunks are coming.
//
// The function takes the following parameters:
//
//   - path (optional): toplevel path for the handler.
//   - callback to invoke for requests under path.
//
func (server *Server) AddHandler(path string, callback ServerCallback) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.char              // out
	var _arg2 C.SoupServerCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*[0]byte)(C._gotk4_soup3_ServerCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_handler(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(callback)
}

// AddWebsocketExtension: add support for a WebSocket extension of the given
// extension_type.
//
// When a WebSocket client requests an extension of extension_type, a new
// websocketextension of type extension_type will be created to handle the
// request.
//
// Note that websocketextensiondeflate is supported by default, use
// server.RemoveWebsocketExtension if you want to disable it.
//
// The function takes the following parameters:
//
//   - extensionType: #GType.
//
func (server *Server) AddWebsocketExtension(extensionType coreglib.Type) {
	var _arg0 *C.SoupServer // out
	var _arg1 C.GType       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.GType(extensionType)

	C.soup_server_add_websocket_extension(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(extensionType)
}

// AddWebsocketHandler adds a WebSocket handler to server for requests prefixed
// by path.
//
// If path is NULL or "/", then this will be the default handler for all
// requests that don't have a more specific handler.
//
// When a path has a WebSocket handler registered, server will check incoming
// requests for WebSocket handshakes after all other handlers have run (unless
// some earlier handler has already set a status code on the message), and
// update the request's status, response headers, and response body accordingly.
//
// If origin is non-NULL, then only requests containing a matching "Origin"
// header will be accepted. If protocols is non-NULL, then only requests
// containing a compatible "Sec-WebSocket-Protocols" header will be accepted.
// More complicated requirements can be handled by adding a normal handler to
// path, and having it perform whatever checks are needed and setting a failure
// status code if the handshake should be rejected.
//
// The function takes the following parameters:
//
//   - path (optional): toplevel path for the handler.
//   - origin (optional) of the connection.
//   - protocols (optional): protocols supported by this handler.
//   - callback to invoke for successful WebSocket requests under path.
//
func (server *Server) AddWebsocketHandler(path, origin string, protocols []string, callback ServerWebsocketCallback) {
	var _arg0 *C.SoupServer                 // out
	var _arg1 *C.char                       // out
	var _arg2 *C.char                       // out
	var _arg3 **C.char                      // out
	var _arg4 C.SoupServerWebsocketCallback // out
	var _arg5 C.gpointer
	var _arg6 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if origin != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(origin)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	{
		_arg3 = (**C.char)(C.calloc(C.size_t((len(protocols) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(protocols)+1)
			var zero *C.char
			out[len(protocols)] = zero
			for i := range protocols {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(protocols[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg4 = (*[0]byte)(C._gotk4_soup3_ServerWebsocketCallback)
	_arg5 = C.gpointer(gbox.Assign(callback))
	_arg6 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_websocket_handler(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(origin)
	runtime.KeepAlive(protocols)
	runtime.KeepAlive(callback)
}

// Disconnect closes and frees server's listening sockets.
//
// Note that if there are currently requests in progress on server, that they
// will continue to be processed if server's glib.MainContext is still running.
//
// You can call server.Listen, etc, after calling this function if you want to
// start listening again.
func (server *Server) Disconnect() {
	var _arg0 *C.SoupServer // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	C.soup_server_disconnect(_arg0)
	runtime.KeepAlive(server)
}

// Listeners gets server's list of listening sockets.
//
// You should treat these sockets as read-only; writing to or modifiying any of
// these sockets may cause server to malfunction.
//
// The function returns the following values:
//
//   - sList: a list of listening sockets.
//
func (server *Server) Listeners() []*gio.Socket {
	var _arg0 *C.SoupServer // out
	var _cret *C.GSList     // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_listeners(_arg0)
	runtime.KeepAlive(server)

	var _sList []*gio.Socket // out

	_sList = make([]*gio.Socket, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSocket)(v)
		var dst *gio.Socket // out
		{
			obj := coreglib.Take(unsafe.Pointer(src))
			dst = &gio.Socket{
				Object: obj,
				DatagramBased: gio.DatagramBased{
					Object: obj,
				},
				Initable: gio.Initable{
					Object: obj,
				},
			}
		}
		_sList = append(_sList, dst)
	})

	return _sList
}

// TLSAuthMode gets the server SSL/TLS client authentication mode.
//
// The function returns the following values:
//
//   - tlsAuthenticationMode: AuthenticationMode.
//
func (server *Server) TLSAuthMode() gio.TLSAuthenticationMode {
	var _arg0 *C.SoupServer            // out
	var _cret C.GTlsAuthenticationMode // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_tls_auth_mode(_arg0)
	runtime.KeepAlive(server)

	var _tlsAuthenticationMode gio.TLSAuthenticationMode // out

	_tlsAuthenticationMode = gio.TLSAuthenticationMode(_cret)

	return _tlsAuthenticationMode
}

// TLSCertificate gets the server SSL/TLS certificate.
//
// The function returns the following values:
//
//   - tlsCertificate (optional) or NULL.
//
func (server *Server) TLSCertificate() gio.TLSCertificater {
	var _arg0 *C.SoupServer      // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_tls_certificate(_arg0)
	runtime.KeepAlive(server)

	var _tlsCertificate gio.TLSCertificater // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.TLSCertificater)
				return ok
			})
			rv, ok := casted.(gio.TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			_tlsCertificate = rv
		}
	}

	return _tlsCertificate
}

// TLSDatabase gets the server SSL/TLS database.
//
// The function returns the following values:
//
//   - tlsDatabase (optional): Database.
//
func (server *Server) TLSDatabase() gio.TLSDatabaser {
	var _arg0 *C.SoupServer   // out
	var _cret *C.GTlsDatabase // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_tls_database(_arg0)
	runtime.KeepAlive(server)

	var _tlsDatabase gio.TLSDatabaser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.TLSDatabaser)
				return ok
			})
			rv, ok := casted.(gio.TLSDatabaser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSDatabaser")
			}
			_tlsDatabase = rv
		}
	}

	return _tlsDatabase
}

// URIs gets a list of URIs corresponding to the interfaces server is listening
// on.
//
// These will contain IP addresses, not hostnames, and will also indicate
// whether the given listener is http or https.
//
// Note that if you used server.ListenAll the returned URIs will use the
// addresses 0.0.0.0 and ::, rather than actually returning separate URIs for
// each interface on the system.
//
// The function returns the following values:
//
//   - sList: list of #GUris, which you must free when you are done with it.
//
func (server *Server) URIs() []*glib.URI {
	var _arg0 *C.SoupServer // out
	var _cret *C.GSList     // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_uris(_arg0)
	runtime.KeepAlive(server)

	var _sList []*glib.URI // out

	_sList = make([]*glib.URI, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GUri)(v)
		var dst *glib.URI // out
		dst = (*glib.URI)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// IsHTTPS checks whether server is capable of https.
//
// In order for a server to run https, you must call server.SetTLSCertificate,
// or set the server:tls-certificate property, to provide it with a certificate
// to use.
//
// If you are using the deprecated single-listener APIs, then a return value
// of TRUE indicates that the Server serves https exclusively. If you are using
// server.Listen, etc, then a TRUE return value merely indicates that the server
// is *able* to do https, regardless of whether it actually currently is or not.
// Use server.GetURIs to see if it currently has any https listeners.
//
// The function returns the following values:
//
//   - ok: TRUE if server is configured to serve https.
//
func (server *Server) IsHTTPS() bool {
	var _arg0 *C.SoupServer // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_is_https(_arg0)
	runtime.KeepAlive(server)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Listen attempts to set up server to listen for connections on address.
//
// If options includes SOUP_SERVER_LISTEN_HTTPS, and server has been configured
// for TLS, then server will listen for https connections on this port.
// Otherwise it will listen for plain http.
//
// You may call this method (along with the other "listen" methods) any number
// of times on a server, if you want to listen on multiple ports, or set up both
// http and https service.
//
// After calling this method, server will begin accepting and processing
// connections as soon as the appropriate glib.MainContext is run.
//
// Note that this API does not make use of dual IPv4/IPv6 sockets; if address
// is an IPv6 address, it will only accept IPv6 connections. You must configure
// IPv4 listening separately.
//
// The function takes the following parameters:
//
//   - address of the interface to listen on.
//   - options: listening options for this server.
//
func (server *Server) Listen(address gio.SocketAddresser, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 *C.GSocketAddress         // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(address)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenAll attempts to set up server to listen for connections on all
// interfaces on the system.
//
// That is, it listens on the addresses 0.0.0.0 and/or ::, depending on whether
// options includes SOUP_SERVER_LISTEN_IPV4_ONLY, SOUP_SERVER_LISTEN_IPV6_ONLY,
// or neither.) If port is specified, server will listen on that port.
// If it is 0, server will find an unused port to listen on. (In that case,
// you can use server.GetURIs to find out what port it ended up choosing.
//
// See server.Listen for more details.
//
// The function takes the following parameters:
//
//   - port to listen on, or 0.
//   - options: listening options for this server.
//
func (server *Server) ListenAll(port uint, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 C.guint                   // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.guint(port)
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_all(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(port)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenLocal attempts to set up server to listen for connections on
// "localhost".
//
// That is, 127.0.0.1 and/or ::1, depending on whether options includes
// SOUP_SERVER_LISTEN_IPV4_ONLY, SOUP_SERVER_LISTEN_IPV6_ONLY, or neither). If
// port is specified, server will listen on that port. If it is 0, server will
// find an unused port to listen on. (In that case, you can use server.GetURIs
// to find out what port it ended up choosing.
//
// See server.Listen for more details.
//
// The function takes the following parameters:
//
//   - port to listen on, or 0.
//   - options: listening options for this server.
//
func (server *Server) ListenLocal(port uint, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 C.guint                   // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.guint(port)
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_local(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(port)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenSocket attempts to set up server to listen for connections on socket.
//
// See server.Listen for more details.
//
// The function takes the following parameters:
//
//   - socket: listening #GSocket.
//   - options: listening options for this server.
//
func (server *Server) ListenSocket(socket *gio.Socket, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 *C.GSocket                // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_socket(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PauseMessage pauses I/O on msg.
//
// This can be used when you need to return from the server handler without
// having the full response ready yet. Use server.UnpauseMessage to resume I/O.
//
// This must only be called on a servermessage which was created by the Server
// and are currently doing I/O, such as those passed into a servercallback or
// emitted in a server::request-read signal.
//
// Deprecated: Use soup_server_message_pause() instead.
//
// The function takes the following parameters:
//
//   - msg associated with server.
//
func (server *Server) PauseMessage(msg *ServerMessage) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_server_pause_message(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// RemoveAuthDomain removes auth_domain from server.
//
// The function takes the following parameters:
//
//   - authDomain: AuthDomain.
//
func (server *Server) RemoveAuthDomain(authDomain AuthDomainer) {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.SoupAuthDomain // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(authDomain).Native()))

	C.soup_server_remove_auth_domain(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(authDomain)
}

// RemoveHandler removes all handlers (early and normal) registered at path.
//
// The function takes the following parameters:
//
//   - path: toplevel path for the handler.
//
func (server *Server) RemoveHandler(path string) {
	var _arg0 *C.SoupServer // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_server_remove_handler(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
}

// RemoveWebsocketExtension removes support for WebSocket extension of type
// extension_type (or any subclass of extension_type) from server.
//
// The function takes the following parameters:
//
//   - extensionType: #GType.
//
func (server *Server) RemoveWebsocketExtension(extensionType coreglib.Type) {
	var _arg0 *C.SoupServer // out
	var _arg1 C.GType       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.GType(extensionType)

	C.soup_server_remove_websocket_extension(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(extensionType)
}

// SetTLSAuthMode sets server's AuthenticationMode to use for SSL/TLS client
// authentication.
//
// The function takes the following parameters:
//
//   - mode: AuthenticationMode.
//
func (server *Server) SetTLSAuthMode(mode gio.TLSAuthenticationMode) {
	var _arg0 *C.SoupServer            // out
	var _arg1 C.GTlsAuthenticationMode // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.GTlsAuthenticationMode(mode)

	C.soup_server_set_tls_auth_mode(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(mode)
}

// SetTLSCertificate sets server up to do https, using the given SSL/TLS
// certificate.
//
// The function takes the following parameters:
//
//   - certificate: Certificate.
//
func (server *Server) SetTLSCertificate(certificate gio.TLSCertificater) {
	var _arg0 *C.SoupServer      // out
	var _arg1 *C.GTlsCertificate // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))

	C.soup_server_set_tls_certificate(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(certificate)
}

// SetTLSDatabase sets server's Database to use for validating SSL/TLS client
// certificates.
//
// The function takes the following parameters:
//
//   - tlsDatabase: Database.
//
func (server *Server) SetTLSDatabase(tlsDatabase gio.TLSDatabaser) {
	var _arg0 *C.SoupServer   // out
	var _arg1 *C.GTlsDatabase // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(tlsDatabase).Native()))

	C.soup_server_set_tls_database(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(tlsDatabase)
}

// UnpauseMessage resumes I/O on msg.
//
// Use this to resume after calling server.PauseMessage, or after adding a new
// chunk to a chunked response.
//
// I/O won't actually resume until you return to the main loop.
//
// This must only be called on a servermessage which was created by the Server
// and are currently doing I/O, such as those passed into a servercallback or
// emitted in a server::request-read signal.
//
// Deprecated: Use soup_server_message_unpause() instead.
//
// The function takes the following parameters:
//
//   - msg associated with server.
//
func (server *Server) UnpauseMessage(msg *ServerMessage) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_server_unpause_message(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (server *Server) requestAborted(msg *ServerMessage) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_aborted

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Server_virtual_request_aborted(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (server *Server) requestFinished(msg *ServerMessage) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_finished

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Server_virtual_request_finished(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (server *Server) requestRead(msg *ServerMessage) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_read

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Server_virtual_request_read(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (server *Server) requestStarted(msg *ServerMessage) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_started

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Server_virtual_request_started(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// ServerClass: instance of this type is always passed by reference.
type ServerClass struct {
	*serverClass
}

// serverClass is the struct that's finalized.
type serverClass struct {
	native *C.SoupServerClass
}

func (s *ServerClass) Padding() [6]unsafe.Pointer {
	valptr := &s.native.padding
	var _v [6]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 6; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}
