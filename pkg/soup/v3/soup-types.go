// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
import "C"

// GType values.
var (
	GTypeCookie         = coreglib.Type(C.soup_cookie_get_type())
	GTypeHSTSPolicy     = coreglib.Type(C.soup_hsts_policy_get_type())
	GTypeMessageMetrics = coreglib.Type(C.soup_message_metrics_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCookie, F: marshalCookie},
		coreglib.TypeMarshaler{T: GTypeHSTSPolicy, F: marshalHSTSPolicy},
		coreglib.TypeMarshaler{T: GTypeMessageMetrics, F: marshalMessageMetrics},
	})
}

// Cookie implements HTTP cookies, as described by RFC 6265
// (http://tools.ietf.org/html/rfc6265.txt).
//
// To have a session handle cookies for your appliction automatically, use a
// cookiejar.
//
// name and value will be set for all cookies. If the cookie is generated from a
// string that appears to have no name, then name will be the empty string.
//
// domain and path give the host or domain, and path within that host/domain, to
// restrict this cookie to. If domain starts with ".", that indicates a domain
// (which matches the string after the ".", or any hostname that has domain as a
// suffix). Otherwise, it is a hostname and must match exactly.
//
// expires will be non-NULL if the cookie uses either the original "expires"
// attribute, or the newer "max-age" attribute. If expires is NULL, it indicates
// that neither "expires" nor "max-age" was specified, and the cookie expires at
// the end of the session.
//
// If http_only is set, the cookie should not be exposed to untrusted code (eg,
// javascript), so as to minimize the danger posed by cross-site scripting
// attacks.
//
// An instance of this type is always passed by reference.
type Cookie struct {
	*cookie
}

// cookie is the struct that's finalized.
type cookie struct {
	native *C.SoupCookie
}

func marshalCookie(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Cookie{&cookie{(*C.SoupCookie)(b)}}, nil
}

// NewCookie constructs a struct Cookie.
func NewCookie(name string, value string, domain string, path string, maxAge int) *Cookie {
	var _arg1 *C.char       // out
	var _arg2 *C.char       // out
	var _arg3 *C.char       // out
	var _arg4 *C.char       // out
	var _arg5 C.int         // out
	var _cret *C.SoupCookie // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = C.int(maxAge)

	_cret = C.soup_cookie_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(path)
	runtime.KeepAlive(maxAge)

	var _cookie *Cookie // out

	_cookie = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_cookie)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_cookie_free((*C.SoupCookie)(intern.C))
		},
	)

	return _cookie
}

// AppliesToURI tests if cookie should be sent to uri.
//
// (At the moment, this does not check that cookie's domain matches uri, because
// it assumes that the caller has already done that. But don't rely on that;
// it may change in the future.).
//
// The function takes the following parameters:
//
//   - uri: #GUri.
//
// The function returns the following values:
//
//   - ok: TRUE if cookie should be sent to uri, FALSE if not.
//
func (cookie *Cookie) AppliesToURI(uri *glib.URI) bool {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.GUri       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.soup_cookie_applies_to_uri(_arg0, _arg1)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy copies cookie.
//
// The function returns the following values:
//
//   - ret: copy of cookie.
//
func (cookie *Cookie) Copy() *Cookie {
	var _arg0 *C.SoupCookie // out
	var _cret *C.SoupCookie // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_copy(_arg0)
	runtime.KeepAlive(cookie)

	var _ret *Cookie // out

	_ret = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_cookie_free((*C.SoupCookie)(intern.C))
		},
	)

	return _ret
}

// DomainMatches checks if the cookie's domain and host match.
//
// The domains match if cookie should be sent when making a request to host,
// or that cookie should be accepted when receiving a response from host.
//
// The function takes the following parameters:
//
//   - host: URI.
//
// The function returns the following values:
//
//   - ok: TRUE if the domains match, FALSE otherwise.
//
func (cookie *Cookie) DomainMatches(host string) bool {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.char       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(host)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.soup_cookie_domain_matches(_arg0, _arg1)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(host)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal tests if cookie1 and cookie2 are equal.
//
// Note that currently, this does not check that the cookie domains match.
// This may change in the future.
//
// The function takes the following parameters:
//
//   - cookie2: Cookie.
//
// The function returns the following values:
//
//   - ok: whether the cookies are equal.
//
func (cookie1 *Cookie) Equal(cookie2 *Cookie) bool {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.SoupCookie // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie1)))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie2)))

	_cret = C.soup_cookie_equal(_arg0, _arg1)
	runtime.KeepAlive(cookie1)
	runtime.KeepAlive(cookie2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Domain gets cookie's domain.
//
// The function returns the following values:
//
//   - utf8 cookie's domain.
//
func (cookie *Cookie) Domain() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_domain(_arg0)
	runtime.KeepAlive(cookie)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Expires gets cookie's expiration time.
//
// The function returns the following values:
//
//   - dateTime (optional) cookie's expiration time, which is owned by cookie
//     and should not be modified or freed.
//
func (cookie *Cookie) Expires() *glib.DateTime {
	var _arg0 *C.SoupCookie // out
	var _cret *C.GDateTime  // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_expires(_arg0)
	runtime.KeepAlive(cookie)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_date_time_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// HTTPOnly gets cookie's HttpOnly attribute.
//
// The function returns the following values:
//
//   - ok cookie's HttpOnly attribute.
//
func (cookie *Cookie) HTTPOnly() bool {
	var _arg0 *C.SoupCookie // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_http_only(_arg0)
	runtime.KeepAlive(cookie)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name gets cookie's name.
//
// The function returns the following values:
//
//   - utf8 cookie's name.
//
func (cookie *Cookie) Name() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_name(_arg0)
	runtime.KeepAlive(cookie)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Path gets cookie's path.
//
// The function returns the following values:
//
//   - utf8 cookie's path.
//
func (cookie *Cookie) Path() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_path(_arg0)
	runtime.KeepAlive(cookie)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SameSitePolicy returns the same-site policy for this cookie.
//
// The function returns the following values:
//
//   - sameSitePolicy: SameSitePolicy.
//
func (cookie *Cookie) SameSitePolicy() SameSitePolicy {
	var _arg0 *C.SoupCookie        // out
	var _cret C.SoupSameSitePolicy // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_same_site_policy(_arg0)
	runtime.KeepAlive(cookie)

	var _sameSitePolicy SameSitePolicy // out

	_sameSitePolicy = SameSitePolicy(_cret)

	return _sameSitePolicy
}

// Secure gets cookie's secure attribute.
//
// The function returns the following values:
//
//   - ok cookie's secure attribute.
//
func (cookie *Cookie) Secure() bool {
	var _arg0 *C.SoupCookie // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_secure(_arg0)
	runtime.KeepAlive(cookie)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Value gets cookie's value.
//
// The function returns the following values:
//
//   - utf8 cookie's value.
//
func (cookie *Cookie) Value() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_value(_arg0)
	runtime.KeepAlive(cookie)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SetDomain sets cookie's domain to domain.
//
// The function takes the following parameters:
//
//   - domain: new domain.
//
func (cookie *Cookie) SetDomain(domain string) {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_cookie_set_domain(_arg0, _arg1)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(domain)
}

// SetExpires sets cookie's expiration time to expires.
//
// If expires is NULL, cookie will be a session cookie and will expire at the
// end of the client's session.
//
// (This sets the same property as cookie.SetMaxAge.).
//
// The function takes the following parameters:
//
//   - expires: new expiration time, or NULL.
//
func (cookie *Cookie) SetExpires(expires *glib.DateTime) {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.GDateTime  // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(expires)))

	C.soup_cookie_set_expires(_arg0, _arg1)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(expires)
}

// SetHTTPOnly sets cookie's HttpOnly attribute to http_only.
//
// If TRUE, cookie will be marked as "http only", meaning it should not be
// exposed to web page scripts or other untrusted code.
//
// The function takes the following parameters:
//
//   - httpOnly: new value for the HttpOnly attribute.
//
func (cookie *Cookie) SetHTTPOnly(httpOnly bool) {
	var _arg0 *C.SoupCookie // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	if httpOnly {
		_arg1 = C.TRUE
	}

	C.soup_cookie_set_http_only(_arg0, _arg1)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(httpOnly)
}

// SetMaxAge sets cookie's max age to max_age.
//
// If max_age is -1, the cookie is a session cookie, and will expire at the
// end of the client's session. Otherwise, it is the number of seconds until
// the cookie expires. You can use the constants SOUP_COOKIE_MAX_AGE_ONE_HOUR,
// SOUP_COOKIE_MAX_AGE_ONE_DAY, SOUP_COOKIE_MAX_AGE_ONE_WEEK and
// SOUP_COOKIE_MAX_AGE_ONE_YEAR (or multiples thereof) to calculate this
// value. (A value of 0 indicates that the cookie should be considered
// already-expired.)
//
// This sets the same property as cookie.SetExpires.
//
// The function takes the following parameters:
//
//   - maxAge: new max age.
//
func (cookie *Cookie) SetMaxAge(maxAge int) {
	var _arg0 *C.SoupCookie // out
	var _arg1 C.int         // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = C.int(maxAge)

	C.soup_cookie_set_max_age(_arg0, _arg1)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(maxAge)
}

// SetName sets cookie's name to name.
//
// The function takes the following parameters:
//
//   - name: new name.
//
func (cookie *Cookie) SetName(name string) {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_cookie_set_name(_arg0, _arg1)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(name)
}

// SetPath sets cookie's path to path.
//
// The function takes the following parameters:
//
//   - path: new path.
//
func (cookie *Cookie) SetPath(path string) {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_cookie_set_path(_arg0, _arg1)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(path)
}

// SetSameSitePolicy: when used in conjunction with
// cookiejar.GetCookieListWithSameSiteInfo this sets the policy of when this
// cookie should be exposed.
//
// The function takes the following parameters:
//
//   - policy: SameSitePolicy.
//
func (cookie *Cookie) SetSameSitePolicy(policy SameSitePolicy) {
	var _arg0 *C.SoupCookie        // out
	var _arg1 C.SoupSameSitePolicy // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = C.SoupSameSitePolicy(policy)

	C.soup_cookie_set_same_site_policy(_arg0, _arg1)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(policy)
}

// SetSecure sets cookie's secure attribute to secure.
//
// If TRUE, cookie will only be transmitted from the client to the server over
// secure (https) connections.
//
// The function takes the following parameters:
//
//   - secure: new value for the secure attribute.
//
func (cookie *Cookie) SetSecure(secure bool) {
	var _arg0 *C.SoupCookie // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	if secure {
		_arg1 = C.TRUE
	}

	C.soup_cookie_set_secure(_arg0, _arg1)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(secure)
}

// SetValue sets cookie's value to value.
//
// The function takes the following parameters:
//
//   - value: new value.
//
func (cookie *Cookie) SetValue(value string) {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_cookie_set_value(_arg0, _arg1)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(value)
}

// ToCookieHeader serializes cookie in the format used by the Cookie header (ie,
// for returning a cookie from a session to a server).
//
// The function returns the following values:
//
//   - utf8: header.
//
func (cookie *Cookie) ToCookieHeader() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_to_cookie_header(_arg0)
	runtime.KeepAlive(cookie)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToSetCookieHeader serializes cookie in the format used by the Set-Cookie
// header.
//
// i.e. for sending a cookie from a server to a client.
//
// The function returns the following values:
//
//   - utf8: header.
//
func (cookie *Cookie) ToSetCookieHeader() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_to_set_cookie_header(_arg0)
	runtime.KeepAlive(cookie)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HSTSPolicy implements HTTP policies, as described by RFC 6797
// (http://tools.ietf.org/html/rfc6797).
//
// domain represents the host that this policy applies to. The domain must be
// IDNA-canonicalized. hstspolicy.New and related methods will do this for you.
//
// max_age contains the 'max-age' value from the Strict Transport Security
// header and indicates the time to live of this policy, in seconds.
//
// expires will be non-NULL if the policy has been set by the host and hence
// has an expiry time. If expires is NULL, it indicates that the policy is a
// permanent session policy set by the user agent.
//
// If include_subdomains is TRUE, the Strict Transport Security policy must also
// be enforced on subdomains of domain.
//
// An instance of this type is always passed by reference.
type HSTSPolicy struct {
	*hstsPolicy
}

// hstsPolicy is the struct that's finalized.
type hstsPolicy struct {
	native *C.SoupHSTSPolicy
}

func marshalHSTSPolicy(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &HSTSPolicy{&hstsPolicy{(*C.SoupHSTSPolicy)(b)}}, nil
}

// NewHSTSPolicy constructs a struct HSTSPolicy.
func NewHSTSPolicy(domain string, maxAge uint32, includeSubdomains bool) *HSTSPolicy {
	var _arg1 *C.char           // out
	var _arg2 C.ulong           // out
	var _arg3 C.gboolean        // out
	var _cret *C.SoupHSTSPolicy // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.ulong(maxAge)
	if includeSubdomains {
		_arg3 = C.TRUE
	}

	_cret = C.soup_hsts_policy_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(maxAge)
	runtime.KeepAlive(includeSubdomains)

	var _hstsPolicy *HSTSPolicy // out

	_hstsPolicy = (*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_hstsPolicy)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_hsts_policy_free((*C.SoupHSTSPolicy)(intern.C))
		},
	)

	return _hstsPolicy
}

// NewHSTSPolicyFromResponse constructs a struct HSTSPolicy.
func NewHSTSPolicyFromResponse(msg *Message) *HSTSPolicy {
	var _arg1 *C.SoupMessage    // out
	var _cret *C.SoupHSTSPolicy // in

	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_hsts_policy_new_from_response(_arg1)
	runtime.KeepAlive(msg)

	var _hstsPolicy *HSTSPolicy // out

	if _cret != nil {
		_hstsPolicy = (*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_hstsPolicy)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_hsts_policy_free((*C.SoupHSTSPolicy)(intern.C))
			},
		)
	}

	return _hstsPolicy
}

// NewHSTSPolicyFull constructs a struct HSTSPolicy.
func NewHSTSPolicyFull(domain string, maxAge uint32, expires *glib.DateTime, includeSubdomains bool) *HSTSPolicy {
	var _arg1 *C.char           // out
	var _arg2 C.ulong           // out
	var _arg3 *C.GDateTime      // out
	var _arg4 C.gboolean        // out
	var _cret *C.SoupHSTSPolicy // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.ulong(maxAge)
	_arg3 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(expires)))
	if includeSubdomains {
		_arg4 = C.TRUE
	}

	_cret = C.soup_hsts_policy_new_full(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(maxAge)
	runtime.KeepAlive(expires)
	runtime.KeepAlive(includeSubdomains)

	var _hstsPolicy *HSTSPolicy // out

	_hstsPolicy = (*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_hstsPolicy)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_hsts_policy_free((*C.SoupHSTSPolicy)(intern.C))
		},
	)

	return _hstsPolicy
}

// NewHSTSPolicySessionPolicy constructs a struct HSTSPolicy.
func NewHSTSPolicySessionPolicy(domain string, includeSubdomains bool) *HSTSPolicy {
	var _arg1 *C.char           // out
	var _arg2 C.gboolean        // out
	var _cret *C.SoupHSTSPolicy // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))
	if includeSubdomains {
		_arg2 = C.TRUE
	}

	_cret = C.soup_hsts_policy_new_session_policy(_arg1, _arg2)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(includeSubdomains)

	var _hstsPolicy *HSTSPolicy // out

	_hstsPolicy = (*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_hstsPolicy)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_hsts_policy_free((*C.SoupHSTSPolicy)(intern.C))
		},
	)

	return _hstsPolicy
}

// Copy copies policy.
//
// The function returns the following values:
//
//   - hstsPolicy: copy of policy.
//
func (policy *HSTSPolicy) Copy() *HSTSPolicy {
	var _arg0 *C.SoupHSTSPolicy // out
	var _cret *C.SoupHSTSPolicy // in

	_arg0 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy)))

	_cret = C.soup_hsts_policy_copy(_arg0)
	runtime.KeepAlive(policy)

	var _hstsPolicy *HSTSPolicy // out

	_hstsPolicy = (*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_hstsPolicy)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_hsts_policy_free((*C.SoupHSTSPolicy)(intern.C))
		},
	)

	return _hstsPolicy
}

// Equal tests if policy1 and policy2 are equal.
//
// The function takes the following parameters:
//
//   - policy2: HSTSPolicy.
//
// The function returns the following values:
//
//   - ok: whether the policies are equal.
//
func (policy1 *HSTSPolicy) Equal(policy2 *HSTSPolicy) bool {
	var _arg0 *C.SoupHSTSPolicy // out
	var _arg1 *C.SoupHSTSPolicy // out
	var _cret C.gboolean        // in

	_arg0 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy1)))
	_arg1 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy2)))

	_cret = C.soup_hsts_policy_equal(_arg0, _arg1)
	runtime.KeepAlive(policy1)
	runtime.KeepAlive(policy2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Domain gets policy's domain.
//
// The function returns the following values:
//
//   - utf8 policy's domain.
//
func (policy *HSTSPolicy) Domain() string {
	var _arg0 *C.SoupHSTSPolicy // out
	var _cret *C.char           // in

	_arg0 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy)))

	_cret = C.soup_hsts_policy_get_domain(_arg0)
	runtime.KeepAlive(policy)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Expires returns the expiration date for policy.
//
// The function returns the following values:
//
//   - dateTime or NULL if unset.
//
func (policy *HSTSPolicy) Expires() *glib.DateTime {
	var _arg0 *C.SoupHSTSPolicy // out
	var _cret *C.GDateTime      // in

	_arg0 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy)))

	_cret = C.soup_hsts_policy_get_expires(_arg0)
	runtime.KeepAlive(policy)

	var _dateTime *glib.DateTime // out

	_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dateTime)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_date_time_unref((*C.GDateTime)(intern.C))
		},
	)

	return _dateTime
}

// MaxAge returns the max age for policy.
//
// The function returns the following values:
//
//   - gulong: max age in seconds.
//
func (policy *HSTSPolicy) MaxAge() uint32 {
	var _arg0 *C.SoupHSTSPolicy // out
	var _cret C.gulong          // in

	_arg0 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy)))

	_cret = C.soup_hsts_policy_get_max_age(_arg0)
	runtime.KeepAlive(policy)

	var _gulong uint32 // out

	_gulong = uint32(_cret)

	return _gulong
}

// IncludesSubdomains gets whether policy include its subdomains.
//
// The function returns the following values:
//
//   - ok: TRUE if policy includes subdomains, FALSE otherwise.
//
func (policy *HSTSPolicy) IncludesSubdomains() bool {
	var _arg0 *C.SoupHSTSPolicy // out
	var _cret C.gboolean        // in

	_arg0 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy)))

	_cret = C.soup_hsts_policy_includes_subdomains(_arg0)
	runtime.KeepAlive(policy)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsExpired gets whether policy is expired.
//
// Permanent policies never expire.
//
// The function returns the following values:
//
//   - ok: TRUE if policy is expired, FALSE otherwise.
//
func (policy *HSTSPolicy) IsExpired() bool {
	var _arg0 *C.SoupHSTSPolicy // out
	var _cret C.gboolean        // in

	_arg0 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy)))

	_cret = C.soup_hsts_policy_is_expired(_arg0)
	runtime.KeepAlive(policy)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSessionPolicy gets whether policy is a non-permanent, non-expirable session
// policy.
//
// See hstspolicy.NewSessionPolicy for details.
//
// The function returns the following values:
//
//   - ok: TRUE if policy is permanent, FALSE otherwise.
//
func (policy *HSTSPolicy) IsSessionPolicy() bool {
	var _arg0 *C.SoupHSTSPolicy // out
	var _cret C.gboolean        // in

	_arg0 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy)))

	_cret = C.soup_hsts_policy_is_session_policy(_arg0)
	runtime.KeepAlive(policy)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MessageMetrics contains metrics collected while loading a message either from
// the network or the disk cache.
//
// Metrics are not collected by default for a message, you need to add the flag
// SOUP_MESSAGE_COLLECT_METRICS to enable the feature.
//
// Temporal metrics are expressed as a monotonic time and always start with
// a fetch start event and finish with response end. All other events are
// optional. An event can be 0 because it hasn't happened yet, because it's
// optional or because the load failed before the event reached.
//
// Size metrics are expressed in bytes and are updated while the message is
// being loaded. You can connect to different message signals to get the final
// result of every value.
//
// An instance of this type is always passed by reference.
type MessageMetrics struct {
	*messageMetrics
}

// messageMetrics is the struct that's finalized.
type messageMetrics struct {
	native *C.SoupMessageMetrics
}

func marshalMessageMetrics(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MessageMetrics{&messageMetrics{(*C.SoupMessageMetrics)(b)}}, nil
}

// Copy copies metrics.
//
// The function returns the following values:
//
//   - messageMetrics: copy of metrics.
//
func (metrics *MessageMetrics) Copy() *MessageMetrics {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret *C.SoupMessageMetrics // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_copy(_arg0)
	runtime.KeepAlive(metrics)

	var _messageMetrics *MessageMetrics // out

	_messageMetrics = (*MessageMetrics)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_messageMetrics)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_message_metrics_free((*C.SoupMessageMetrics)(intern.C))
		},
	)

	return _messageMetrics
}

// ConnectEnd: get the time immediately after the message completed the
// connection to the server. This includes the time for the proxy negotiation
// and TLS handshake.
//
// It will be 0 if no network connection was required to fetch the resource (a
// persistent connection was used or resource was loaded from the local disk
// cache).
//
// The function returns the following values:
//
//   - guint64: connection end time.
//
func (metrics *MessageMetrics) ConnectEnd() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_connect_end(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ConnectStart: get the time immediately before the message started to
// establish the connection to the server.
//
// It will be 0 if no network connection was required to fetch the resource (a
// persistent connection was used or resource was loaded from the local disk
// cache).
//
// The function returns the following values:
//
//   - guint64: connection start time.
//
func (metrics *MessageMetrics) ConnectStart() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_connect_start(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// DnsEnd: get the time immediately after the message completed the domain
// lookup name for the resource.
//
// It will be 0 if no domain lookup was required to fetch the resource (a
// persistent connection was used or resource was loaded from the local disk
// cache).
//
// The function returns the following values:
//
//   - guint64: domain lookup end time.
//
func (metrics *MessageMetrics) DnsEnd() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_dns_end(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// DnsStart: get the time immediately before the message started the domain
// lookup name for the resource.
//
// It will be 0 if no domain lookup was required to fetch the resource (a
// persistent connection was used or resource was loaded from the local disk
// cache).
//
// The function returns the following values:
//
//   - guint64: domain lookup start time.
//
func (metrics *MessageMetrics) DnsStart() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_dns_start(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// FetchStart: get the time immediately before the message started to fetch a
// resource either from a remote server or local disk cache.
//
// The function returns the following values:
//
//   - guint64: fetch start time.
//
func (metrics *MessageMetrics) FetchStart() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_fetch_start(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// RequestBodyBytesSent: get the number of bytes sent to the network for the
// request body.
//
// This is the size of the body sent, after encodings are applied, so it might
// be greater than the value returned by messagemetrics.GetRequestBodySize.
// This value is available right before message::wrote-body signal is emitted,
// but you might get an intermediate value if called before.
//
// The function returns the following values:
//
//   - guint64: request body bytes sent.
//
func (metrics *MessageMetrics) RequestBodyBytesSent() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_request_body_bytes_sent(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// RequestBodySize: get the request body size in bytes. This is the size of the
// original body given to the request before any encoding is applied.
//
// This value is available right before message::wrote-body signal is emitted,
// but you might get an intermediate value if called before.
//
// The function returns the following values:
//
//   - guint64: request body size.
//
func (metrics *MessageMetrics) RequestBodySize() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_request_body_size(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// RequestHeaderBytesSent: get the number of bytes sent to the network for the
// request headers.
//
// This value is available right before message::wrote-headers signal is
// emitted, but you might get an intermediate value if called before.
//
// The function returns the following values:
//
//   - guint64: request headers bytes sent.
//
func (metrics *MessageMetrics) RequestHeaderBytesSent() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_request_header_bytes_sent(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// RequestStart: get the time immediately before the message started the request
// of the resource from the server or the local disk cache.
//
// The function returns the following values:
//
//   - guint64: request start time.
//
func (metrics *MessageMetrics) RequestStart() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_request_start(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ResponseBodyBytesReceived: get the number of bytes received from the network
// for the response body.
//
// This value is available right before message::got-body signal is emitted,
// but you might get an intermediate value if called before. For resources
// loaded from the disk cache this value is always 0.
//
// The function returns the following values:
//
//   - guint64: response body bytes received.
//
func (metrics *MessageMetrics) ResponseBodyBytesReceived() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_response_body_bytes_received(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ResponseBodySize: get the response body size in bytes.
//
// This is the size of the body as given to the user after all encodings
// are applied, so it might be greater than the value returned by
// messagemetrics.GetResponseBodyBytesReceived. This value is available right
// before message::got-body signal is emitted, but you might get an intermediate
// value if called before.
//
// The function returns the following values:
//
//   - guint64: response body size.
//
func (metrics *MessageMetrics) ResponseBodySize() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_response_body_size(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ResponseEnd: get the time immediately after the message received the last
// bytes of the response from the server or the local disk cache.
//
// In case of load failure, this returns the time immediately before the fetch
// is aborted.
//
// The function returns the following values:
//
//   - guint64: response end time.
//
func (metrics *MessageMetrics) ResponseEnd() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_response_end(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ResponseHeaderBytesReceived: get the number of bytes received from the
// network for the response headers.
//
// This value is available right before message::got-headers signal is emitted,
// but you might get an intermediate value if called before. For resources
// loaded from the disk cache this value is always 0.
//
// The function returns the following values:
//
//   - guint64: response headers bytes received.
//
func (metrics *MessageMetrics) ResponseHeaderBytesReceived() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_response_header_bytes_received(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ResponseStart: get the time immediately after the message received the first
// bytes of the response from the server or the local disk cache.
//
// The function returns the following values:
//
//   - guint64: response start time.
//
func (metrics *MessageMetrics) ResponseStart() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_response_start(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// TLSStart: get the time immediately before the message started the TLS
// handshake.
//
// It will be 0 if no TLS handshake was required to fetch the resource
// (connection was not secure, a persistent connection was used or resource was
// loaded from the local disk cache).
//
// The function returns the following values:
//
//   - guint64 tls start time.
//
func (metrics *MessageMetrics) TLSStart() uint64 {
	var _arg0 *C.SoupMessageMetrics // out
	var _cret C.guint64             // in

	_arg0 = (*C.SoupMessageMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.soup_message_metrics_get_tls_start(_arg0)
	runtime.KeepAlive(metrics)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}
