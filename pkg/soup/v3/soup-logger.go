// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_soup3_LoggerPrinter(SoupLogger*, SoupLoggerLogLevel, char, char*, gpointer);
// extern SoupLoggerLogLevel _gotk4_soup3_LoggerFilter(SoupLogger*, SoupMessage*, gpointer);
import "C"

// GType values.
var (
	GTypeLoggerLogLevel = coreglib.Type(C.soup_logger_log_level_get_type())
	GTypeLogger         = coreglib.Type(C.soup_logger_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeLoggerLogLevel, F: marshalLoggerLogLevel},
		coreglib.TypeMarshaler{T: GTypeLogger, F: marshalLogger},
	})
}

// LoggerLogLevel describes the level of logging output to provide.
type LoggerLogLevel C.gint

const (
	// LoggerLogNone: no logging.
	LoggerLogNone LoggerLogLevel = iota
	// LoggerLogMinimal: log the Request-Line or Status-Line and the Soup-Debug
	// pseudo-headers.
	LoggerLogMinimal
	// LoggerLogHeaders: log the full request/response headers.
	LoggerLogHeaders
	// LoggerLogBody: log the full headers and request/response bodies.
	LoggerLogBody
)

func marshalLoggerLogLevel(p uintptr) (interface{}, error) {
	return LoggerLogLevel(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for LoggerLogLevel.
func (l LoggerLogLevel) String() string {
	switch l {
	case LoggerLogNone:
		return "None"
	case LoggerLogMinimal:
		return "Minimal"
	case LoggerLogHeaders:
		return "Headers"
	case LoggerLogBody:
		return "Body"
	default:
		return fmt.Sprintf("LoggerLogLevel(%d)", l)
	}
}

// LoggerFilter: prototype for a logging filter.
//
// The filter callback will be invoked for each request or response, and should
// analyze it and return a loggerloglevel value indicating how much of the
// message to log.
type LoggerFilter func(logger *Logger, msg *Message) (loggerLogLevel LoggerLogLevel)

// LoggerPrinter: prototype for a custom printing callback.
//
// level indicates what kind of information is being printed. Eg, it will be
// SOUP_LOGGER_LOG_HEADERS if data is header data.
//
// direction is either '<', '>', or ' ', and data is the single line to print;
// the printer is expected to add a terminating newline.
//
// To get the effect of the default printer, you would do:
//
//    printf ("c s\n", direction, data);.
type LoggerPrinter func(logger *Logger, level LoggerLogLevel, direction byte, data string)

// LoggerOverrides contains methods that are overridable.
type LoggerOverrides struct {
}

func defaultLoggerOverrides(v *Logger) LoggerOverrides {
	return LoggerOverrides{}
}

// Logger: debug logging support
//
// Logger watches a session and logs the HTTP traffic that it generates,
// for debugging purposes. Many applications use an environment variable to
// determine whether or not to use Logger, and to determine the amount of
// debugging output.
//
// To use Logger, first create a logger with logger.New, optionally
// configure it with logger.SetRequestFilter, logger.SetResponseFilter,
// and logger.SetPrinter, and then attach it to a session (or multiple sessions)
// with session.AddFeature.
//
// By default, the debugging output is sent to stdout, and looks something like:
//
//    > POST /unauth HTTP/1.1
//    > Soup-Debug-Timestamp: 1200171744
//    > Soup-Debug: SoupSession 1 (0x612190), SoupMessage 1 (0x617000), GSocket 1 (0x612220)
//    > Host: localhost
//    > Content-Type: text/plain
//    > Connection: close
//
//    &lt; HTTP/1.1 201 Created
//    &lt; Soup-Debug-Timestamp: 1200171744
//    &lt; Soup-Debug: SoupMessage 1 (0x617000)
//    &lt; Date: Sun, 12 Jan 2008 21:02:24 GMT
//    &lt; Content-Length: 0
//
// The Soup-Debug-Timestamp line gives the time (as a time_t) when the request
// was sent, or the response fully received.
//
// The Soup-Debug line gives further debugging information about the session,
// message, and gio.Socket involved; the hex numbers are the addresses of the
// objects in question (which may be useful if you are running in a debugger).
// The decimal IDs are simply counters that uniquely identify objects across
// the lifetime of the Logger. In particular, this can be used to identify when
// multiple messages are sent across the same connection.
//
// Currently, the request half of the message is logged just before the first
// byte of the request gets written to the network (from the message::starting
// signal).
//
// The response is logged just after the last byte of the response body is read
// from the network (from the message::got-body or message::got-informational
// signal), which means that the message::got-headers signal, and anything
// triggered off it (such as Message::authenticate) will be emitted *before* the
// response headers are actually logged.
//
// If the response doesn't happen to trigger the message::got-body nor
// message::got-informational signals due to, for example, a cancellation before
// receiving the last byte of the response body, the response will still be
// logged on the event of the message::finished signal.
type Logger struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SessionFeature
}

var (
	_ coreglib.Objector = (*Logger)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Logger, *LoggerClass, LoggerOverrides](
		GTypeLogger,
		initLoggerClass,
		wrapLogger,
		defaultLoggerOverrides,
	)
}

func initLoggerClass(gclass unsafe.Pointer, overrides LoggerOverrides, classInitFunc func(*LoggerClass)) {
	if classInitFunc != nil {
		class := (*LoggerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapLogger(obj *coreglib.Object) *Logger {
	return &Logger{
		Object: obj,
		SessionFeature: SessionFeature{
			Object: obj,
		},
	}
}

func marshalLogger(p uintptr) (interface{}, error) {
	return wrapLogger(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewLogger creates a new Logger with the given debug level.
//
// If you need finer control over what message parts are and aren't logged,
// use logger.SetRequestFilter and logger.SetResponseFilter.
//
// The function takes the following parameters:
//
//   - level: debug level.
//
// The function returns the following values:
//
//   - logger: new Logger.
//
func NewLogger(level LoggerLogLevel) *Logger {
	var _arg1 C.SoupLoggerLogLevel // out
	var _cret *C.SoupLogger        // in

	_arg1 = C.SoupLoggerLogLevel(level)

	_cret = C.soup_logger_new(_arg1)
	runtime.KeepAlive(level)

	var _logger *Logger // out

	_logger = wrapLogger(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _logger
}

// MaxBodySize: get the maximum body size for logger.
//
// The function returns the following values:
//
//   - gint: maximum body size, or -1 if unlimited.
//
func (logger *Logger) MaxBodySize() int {
	var _arg0 *C.SoupLogger // out
	var _cret C.int         // in

	_arg0 = (*C.SoupLogger)(unsafe.Pointer(coreglib.InternObject(logger).Native()))

	_cret = C.soup_logger_get_max_body_size(_arg0)
	runtime.KeepAlive(logger)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SetMaxBodySize sets the maximum body size for logger (-1 means no limit).
//
// The function takes the following parameters:
//
//   - maxBodySize: maximum body size to log.
//
func (logger *Logger) SetMaxBodySize(maxBodySize int) {
	var _arg0 *C.SoupLogger // out
	var _arg1 C.int         // out

	_arg0 = (*C.SoupLogger)(unsafe.Pointer(coreglib.InternObject(logger).Native()))
	_arg1 = C.int(maxBodySize)

	C.soup_logger_set_max_body_size(_arg0, _arg1)
	runtime.KeepAlive(logger)
	runtime.KeepAlive(maxBodySize)
}

// SetPrinter sets up an alternate log printing routine, if you don't want the
// log to go to stdout.
//
// The function takes the following parameters:
//
//   - printer: callback for printing logging output.
//
func (logger *Logger) SetPrinter(printer LoggerPrinter) {
	var _arg0 *C.SoupLogger       // out
	var _arg1 C.SoupLoggerPrinter // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.SoupLogger)(unsafe.Pointer(coreglib.InternObject(logger).Native()))
	_arg1 = (*[0]byte)(C._gotk4_soup3_LoggerPrinter)
	_arg2 = C.gpointer(gbox.Assign(printer))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_logger_set_printer(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(logger)
	runtime.KeepAlive(printer)
}

// SetRequestFilter sets up a filter to determine the log level for a given
// request.
//
// For each HTTP request logger will invoke request_filter to determine how
// much (if any) of that request to log. (If you do not set a request filter,
// logger will just always log requests at the level passed to logger.New.).
//
// The function takes the following parameters:
//
//   - requestFilter: callback for request debugging.
//
func (logger *Logger) SetRequestFilter(requestFilter LoggerFilter) {
	var _arg0 *C.SoupLogger      // out
	var _arg1 C.SoupLoggerFilter // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.SoupLogger)(unsafe.Pointer(coreglib.InternObject(logger).Native()))
	_arg1 = (*[0]byte)(C._gotk4_soup3_LoggerFilter)
	_arg2 = C.gpointer(gbox.Assign(requestFilter))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_logger_set_request_filter(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(logger)
	runtime.KeepAlive(requestFilter)
}

// SetResponseFilter sets up a filter to determine the log level for a given
// response.
//
// For each HTTP response logger will invoke response_filter to determine how
// much (if any) of that response to log. (If you do not set a response filter,
// logger will just always log responses at the level passed to logger.New.).
//
// The function takes the following parameters:
//
//   - responseFilter: callback for response debugging.
//
func (logger *Logger) SetResponseFilter(responseFilter LoggerFilter) {
	var _arg0 *C.SoupLogger      // out
	var _arg1 C.SoupLoggerFilter // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.SoupLogger)(unsafe.Pointer(coreglib.InternObject(logger).Native()))
	_arg1 = (*[0]byte)(C._gotk4_soup3_LoggerFilter)
	_arg2 = C.gpointer(gbox.Assign(responseFilter))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_logger_set_response_filter(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(logger)
	runtime.KeepAlive(responseFilter)
}

// LoggerClass: instance of this type is always passed by reference.
type LoggerClass struct {
	*loggerClass
}

// loggerClass is the struct that's finalized.
type loggerClass struct {
	native *C.SoupLoggerClass
}
