// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
import "C"

// GType values.
var (
	GTypeSameSitePolicy = coreglib.Type(C.soup_same_site_policy_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSameSitePolicy, F: marshalSameSitePolicy},
	})
}

// COOKIE_MAX_AGE_ONE_DAY: constant corresponding to 1 day.
//
// For use with cookie.New and cookie.SetMaxAge.
const COOKIE_MAX_AGE_ONE_DAY = 0

// COOKIE_MAX_AGE_ONE_HOUR: constant corresponding to 1 hour.
//
// For use with cookie.New and cookie.SetMaxAge.
const COOKIE_MAX_AGE_ONE_HOUR = 3600

// COOKIE_MAX_AGE_ONE_WEEK: constant corresponding to 1 week.
//
// For use with cookie.New and cookie.SetMaxAge.
const COOKIE_MAX_AGE_ONE_WEEK = 0

// COOKIE_MAX_AGE_ONE_YEAR: constant corresponding to 1 year.
//
// For use with cookie.New and cookie.SetMaxAge.
const COOKIE_MAX_AGE_ONE_YEAR = 0

// SameSitePolicy represents the same-site policies of a cookie.
type SameSitePolicy C.gint

const (
	// SameSitePolicyNone: cookie is exposed with both cross-site and same-site
	// requests.
	SameSitePolicyNone SameSitePolicy = iota
	// SameSitePolicyLax: cookie is withheld on cross-site requests but exposed
	// on cross-site navigations.
	SameSitePolicyLax
	// SameSitePolicyStrict: cookie is only exposed for same-site requests.
	SameSitePolicyStrict
)

func marshalSameSitePolicy(p uintptr) (interface{}, error) {
	return SameSitePolicy(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SameSitePolicy.
func (s SameSitePolicy) String() string {
	switch s {
	case SameSitePolicyNone:
		return "None"
	case SameSitePolicyLax:
		return "Lax"
	case SameSitePolicyStrict:
		return "Strict"
	default:
		return fmt.Sprintf("SameSitePolicy(%d)", s)
	}
}

// CookiesFromRequest parses msg's Cookie request header and returns a
// glib.SList of SoupCookies.
//
// As the "Cookie" header, unlike "Set-Cookie", only contains cookie names
// and values, none of the other Cookie fields will be filled in. (Thus,
// you can't generally pass a cookie returned from this method directly to
// cookies_to_response.).
//
// The function takes the following parameters:
//
//   - msg containing a "Cookie" request header.
//
// The function returns the following values:
//
//   - sList of SoupCookies, which can be freed with cookie.Free.
//
func CookiesFromRequest(msg *Message) []*Cookie {
	var _arg1 *C.SoupMessage // out
	var _cret *C.GSList      // in

	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_cookies_from_request(_arg1)
	runtime.KeepAlive(msg)

	var _sList []*Cookie // out

	_sList = make([]*Cookie, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupCookie)(v)
		var dst *Cookie // out
		dst = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_cookie_free((*C.SoupCookie)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// CookiesFromResponse parses msg's Set-Cookie response headers and returns a
// glib.SList of SoupCookies.
//
// Cookies that do not specify "path" or "domain" attributes will have their
// values defaulted from msg.
//
// The function takes the following parameters:
//
//   - msg containing a "Set-Cookie" response header.
//
// The function returns the following values:
//
//   - sList of SoupCookies, which can be freed with cookie.Free.
//
func CookiesFromResponse(msg *Message) []*Cookie {
	var _arg1 *C.SoupMessage // out
	var _cret *C.GSList      // in

	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_cookies_from_response(_arg1)
	runtime.KeepAlive(msg)

	var _sList []*Cookie // out

	_sList = make([]*Cookie, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupCookie)(v)
		var dst *Cookie // out
		dst = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_cookie_free((*C.SoupCookie)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// CookiesToCookieHeader serializes a glib.SList of Cookie into a string
// suitable for setting as the value of the "Cookie" header.
//
// The function takes the following parameters:
//
//   - cookies of Cookie.
//
// The function returns the following values:
//
//   - utf8: serialization of cookies.
//
func CookiesToCookieHeader(cookies []*Cookie) string {
	var _arg1 *C.GSList // out
	var _cret *C.char   // in

	for i := len(cookies) - 1; i >= 0; i-- {
		src := cookies[i]
		var dst *C.SoupCookie // out
		dst = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(src)))
		_arg1 = C.g_slist_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_slist_free(_arg1)

	_cret = C.soup_cookies_to_cookie_header(_arg1)
	runtime.KeepAlive(cookies)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// CookiesToRequest adds the name and value of each cookie in cookies to msg's
// "Cookie" request.
//
// If msg already has a "Cookie" request header, these cookies will be appended
// to the cookies already present. Be careful that you do not append the same
// cookies twice, eg, when requeuing a message.
//
// The function takes the following parameters:
//
//   - cookies of Cookie.
//   - msg: Message.
//
func CookiesToRequest(cookies []*Cookie, msg *Message) {
	var _arg1 *C.GSList      // out
	var _arg2 *C.SoupMessage // out

	for i := len(cookies) - 1; i >= 0; i-- {
		src := cookies[i]
		var dst *C.SoupCookie // out
		dst = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(src)))
		_arg1 = C.g_slist_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_slist_free(_arg1)
	_arg2 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_cookies_to_request(_arg1, _arg2)
	runtime.KeepAlive(cookies)
	runtime.KeepAlive(msg)
}

// CookiesToResponse appends a "Set-Cookie" response header to msg for each
// cookie in cookies.
//
// This is in addition to any other "Set-Cookie" headers msg may already have.
//
// The function takes the following parameters:
//
//   - cookies of Cookie.
//   - msg: Message.
//
func CookiesToResponse(cookies []*Cookie, msg *Message) {
	var _arg1 *C.GSList      // out
	var _arg2 *C.SoupMessage // out

	for i := len(cookies) - 1; i >= 0; i-- {
		src := cookies[i]
		var dst *C.SoupCookie // out
		dst = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(src)))
		_arg1 = C.g_slist_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_slist_free(_arg1)
	_arg2 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_cookies_to_response(_arg1, _arg2)
	runtime.KeepAlive(cookies)
	runtime.KeepAlive(msg)
}

// CookieParse parses header and returns a Cookie.
//
// If header contains multiple cookies, only the first one will be parsed.
//
// If header does not have "path" or "domain" attributes, they will be defaulted
// from origin. If origin is NULL, path will default to "/", but domain will
// be left as NULL. Note that this is not a valid state for a Cookie, and you
// will need to fill in some appropriate string for the domain if you want to
// actually make use of the cookie.
//
// As of version 3.4.0 the default value of a cookie's same-site-policy is
// SOUP_SAME_SITE_POLICY_LAX.
//
// The function takes the following parameters:
//
//   - header: cookie string (eg, the value of a Set-Cookie header).
//   - origin (optional) of the cookie.
//
// The function returns the following values:
//
//   - cookie (optional): new Cookie, or NULL if it could not be parsed,
//     or contained an illegal "domain" attribute for a cookie originating from
//     origin.
//
func CookieParse(header string, origin *glib.URI) *Cookie {
	var _arg1 *C.char       // out
	var _arg2 *C.GUri       // out
	var _cret *C.SoupCookie // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(header)))
	defer C.free(unsafe.Pointer(_arg1))
	if origin != nil {
		_arg2 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(origin)))
	}

	_cret = C.soup_cookie_parse(_arg1, _arg2)
	runtime.KeepAlive(header)
	runtime.KeepAlive(origin)

	var _cookie *Cookie // out

	if _cret != nil {
		_cookie = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_cookie)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_cookie_free((*C.SoupCookie)(intern.C))
			},
		)
	}

	return _cookie
}
