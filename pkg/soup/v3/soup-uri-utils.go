// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
import "C"

// GType values.
var (
	GTypeURIComponent = coreglib.Type(C.soup_uri_component_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeURIComponent, F: marshalURIComponent},
	})
}

// HTTP_URI_FLAGS: set of Flags libsoup expects all #GUri to use.
const HTTP_URI_FLAGS = 482

// URIComponent: enum values passed to uri_copy to indicate the components of
// the URI that should be updated with the given values.
type URIComponent C.gint

const (
	// URINone: no component.
	URINone URIComponent = iota
	// URIScheme: URI scheme component.
	URIScheme
	// URIUser: URI user component.
	URIUser
	// URIPassword: URI password component.
	URIPassword
	// URIAuthParams: URI authentication parameters component.
	URIAuthParams
	// URIHost: URI host component.
	URIHost
	// URIPort: URI port component.
	URIPort
	// URIPath: URI path component.
	URIPath
	// URIQuery: URI query component.
	URIQuery
	// URIFragment: URI fragment component.
	URIFragment
)

func marshalURIComponent(p uintptr) (interface{}, error) {
	return URIComponent(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for URIComponent.
func (u URIComponent) String() string {
	switch u {
	case URINone:
		return "None"
	case URIScheme:
		return "Scheme"
	case URIUser:
		return "User"
	case URIPassword:
		return "Password"
	case URIAuthParams:
		return "AuthParams"
	case URIHost:
		return "Host"
	case URIPort:
		return "Port"
	case URIPath:
		return "Path"
	case URIQuery:
		return "Query"
	case URIFragment:
		return "Fragment"
	default:
		return fmt.Sprintf("URIComponent(%d)", u)
	}
}

// URIDecodeDataURI decodes the given data URI and returns its contents and
// content_type.
//
// The function takes the following parameters:
//
//   - uri: data URI, in string form.
//
// The function returns the following values:
//
//   - contentType (optional): location to store content type.
//   - bytes with the contents of uri, or NULL if uri is not a valid data URI.
//
func URIDecodeDataURI(uri string) (string, *glib.Bytes) {
	var _arg1 *C.char   // out
	var _arg2 *C.char   // in
	var _cret *C.GBytes // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.soup_uri_decode_data_uri(_arg1, &_arg2)
	runtime.KeepAlive(uri)

	var _contentType string // out
	var _bytes *glib.Bytes  // out

	if _arg2 != nil {
		_contentType = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _contentType, _bytes
}

// URIEqual tests whether or not uri1 and uri2 are equal in all parts.
//
// The function takes the following parameters:
//
//   - uri1: #GUri.
//   - uri2: another #GUri.
//
// The function returns the following values:
//
//   - ok: TRUE if equal otherwise FALSE.
//
func URIEqual(uri1, uri2 *glib.URI) bool {
	var _arg1 *C.GUri    // out
	var _arg2 *C.GUri    // out
	var _cret C.gboolean // in

	_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri1)))
	_arg2 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri2)))

	_cret = C.soup_uri_equal(_arg1, _arg2)
	runtime.KeepAlive(uri1)
	runtime.KeepAlive(uri2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
