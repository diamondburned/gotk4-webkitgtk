// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void callbackDelete(gpointer);
// extern gboolean _gotk4_soup3_AuthDomainGenericAuthCallback(SoupAuthDomain*, SoupServerMessage*, char*, gpointer);
// extern gboolean _gotk4_soup3_AuthDomainFilter(SoupAuthDomain*, SoupServerMessage*, gpointer);
// extern gboolean _gotk4_soup3_AuthDomainClass_check_password(SoupAuthDomain*, SoupServerMessage*, char*, char*);
// extern char* _gotk4_soup3_AuthDomainClass_challenge(SoupAuthDomain*, SoupServerMessage*);
// extern char* _gotk4_soup3_AuthDomainClass_accepts(SoupAuthDomain*, SoupServerMessage*, char*);
// char* _gotk4_soup3_AuthDomain_virtual_accepts(void* fnptr, SoupAuthDomain* arg0, SoupServerMessage* arg1, char* arg2) {
//   return ((char* (*)(SoupAuthDomain*, SoupServerMessage*, char*))(fnptr))(arg0, arg1, arg2);
// };
// char* _gotk4_soup3_AuthDomain_virtual_challenge(void* fnptr, SoupAuthDomain* arg0, SoupServerMessage* arg1) {
//   return ((char* (*)(SoupAuthDomain*, SoupServerMessage*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_soup3_AuthDomain_virtual_check_password(void* fnptr, SoupAuthDomain* arg0, SoupServerMessage* arg1, char* arg2, char* arg3) {
//   return ((gboolean (*)(SoupAuthDomain*, SoupServerMessage*, char*, char*))(fnptr))(arg0, arg1, arg2, arg3);
// };
import "C"

// GType values.
var (
	GTypeAuthDomain = coreglib.Type(C.soup_auth_domain_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAuthDomain, F: marshalAuthDomain},
	})
}

// AuthDomainFilter: prototype for a AuthDomain filter.
//
// See authdomain.SetFilter for details.
type AuthDomainFilter func(domain AuthDomainer, msg *ServerMessage) (ok bool)

// AuthDomainGenericAuthCallback: prototype for a AuthDomain generic
// authentication callback.
//
// The callback should look up the user's password, call
// authdomain.CheckPassword, and use the return value from that method as its
// own return value.
//
// In general, for security reasons, it is preferable to use the
// auth-domain-specific auth callbacks (eg, authdomainbasicauthcallback and
// authdomaindigestauthcallback), because they don't require keeping a cleartext
// password database. Most users will use the same password for many different
// sites, meaning if any site with a cleartext password database is compromised,
// accounts on other servers might be compromised as well. For many of the cases
// where server is used, this is not really relevant, but it may still be worth
// considering.
type AuthDomainGenericAuthCallback func(domain AuthDomainer, msg *ServerMessage, username string) (ok bool)

// AuthDomainOverrides contains methods that are overridable.
type AuthDomainOverrides struct {
	// The function takes the following parameters:
	//
	//   - msg
	//   - header
	//
	// The function returns the following values:
	//
	Accepts func(msg *ServerMessage, header string) string
	// Challenge adds a "WWW-Authenticate" or "Proxy-Authenticate" header to
	// msg.
	//
	// It requests that the client authenticate, and sets msg's status
	// accordingly.
	//
	// This is used by server internally and is probably of no use to anyone
	// else.
	//
	// The function takes the following parameters:
	//
	//   - msg: ServerMessage.
	//
	// The function returns the following values:
	//
	Challenge func(msg *ServerMessage) string
	// CheckPassword checks if msg authenticates to domain via username and
	// password.
	//
	// This would normally be called from a authdomaingenericauthcallback.
	//
	// The function takes the following parameters:
	//
	//   - msg: ServerMessage.
	//   - username: username.
	//   - password: password.
	//
	// The function returns the following values:
	//
	//   - ok: whether or not the message is authenticated.
	//
	CheckPassword func(msg *ServerMessage, username, password string) bool
}

func defaultAuthDomainOverrides(v *AuthDomain) AuthDomainOverrides {
	return AuthDomainOverrides{
		Accepts:       v.accepts,
		Challenge:     v.challenge,
		CheckPassword: v.checkPassword,
	}
}

// AuthDomain: server-side authentication.
//
// A AuthDomain manages authentication for all or part of a server. To make
// a server require authentication, first create an appropriate subclass of
// AuthDomain, and then add it to the server with server.AddAuthDomain.
//
// In order for an auth domain to have any effect, you must add one or more
// paths to it (via authdomain.AddPath). To require authentication for all
// ordinary requests, add the path "/". (Note that this does not include the
// special "*" URI (eg, "OPTIONS *"), which must be added as a separate path if
// you want to cover it.)
//
// If you need greater control over which requests should and shouldn't be
// authenticated, add paths covering everything you *might* want authenticated,
// and then use a filter (authdomain.SetFilter to bypass authentication for
// those requests that don't need it.
type AuthDomain struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AuthDomain)(nil)
)

// AuthDomainer describes types inherited from class AuthDomain.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type AuthDomainer interface {
	coreglib.Objector
	baseAuthDomain() *AuthDomain
}

var _ AuthDomainer = (*AuthDomain)(nil)

func init() {
	coreglib.RegisterClassInfo[*AuthDomain, *AuthDomainClass, AuthDomainOverrides](
		GTypeAuthDomain,
		initAuthDomainClass,
		wrapAuthDomain,
		defaultAuthDomainOverrides,
	)
}

func initAuthDomainClass(gclass unsafe.Pointer, overrides AuthDomainOverrides, classInitFunc func(*AuthDomainClass)) {
	pclass := (*C.SoupAuthDomainClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAuthDomain))))

	if overrides.Accepts != nil {
		pclass.accepts = (*[0]byte)(C._gotk4_soup3_AuthDomainClass_accepts)
	}

	if overrides.Challenge != nil {
		pclass.challenge = (*[0]byte)(C._gotk4_soup3_AuthDomainClass_challenge)
	}

	if overrides.CheckPassword != nil {
		pclass.check_password = (*[0]byte)(C._gotk4_soup3_AuthDomainClass_check_password)
	}

	if classInitFunc != nil {
		class := (*AuthDomainClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAuthDomain(obj *coreglib.Object) *AuthDomain {
	return &AuthDomain{
		Object: obj,
	}
}

func marshalAuthDomain(p uintptr) (interface{}, error) {
	return wrapAuthDomain(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (domain *AuthDomain) baseAuthDomain() *AuthDomain {
	return domain
}

// BaseAuthDomain returns the underlying base object.
func BaseAuthDomain(obj AuthDomainer) *AuthDomain {
	return obj.baseAuthDomain()
}

// Accepts checks if msg contains appropriate authorization for domain to accept
// it.
//
// Mirroring authdomain.Covers, this does not check whether or not domain
// *cares* if msg is authorized.
//
// This is used by server internally and is probably of no use to anyone else.
//
// The function takes the following parameters:
//
//   - msg: ServerMessage.
//
// The function returns the following values:
//
//   - utf8 (optional): username that msg has authenticated as, if in fact it
//     has authenticated. NULL otherwise.
//
func (domain *AuthDomain) Accepts(msg *ServerMessage) string {
	var _arg0 *C.SoupAuthDomain    // out
	var _arg1 *C.SoupServerMessage // out
	var _cret *C.char              // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_auth_domain_accepts(_arg0, _arg1)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msg)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// AddPath adds path to domain.
//
// Requests under path on domain's server will require authentication (unless
// overridden by authdomain.RemovePath or authdomain.SetFilter).
//
// The function takes the following parameters:
//
//   - path to add to domain.
//
func (domain *AuthDomain) AddPath(path string) {
	var _arg0 *C.SoupAuthDomain // out
	var _arg1 *C.char           // out

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_auth_domain_add_path(_arg0, _arg1)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(path)
}

// Challenge adds a "WWW-Authenticate" or "Proxy-Authenticate" header to msg.
//
// It requests that the client authenticate, and sets msg's status accordingly.
//
// This is used by server internally and is probably of no use to anyone else.
//
// The function takes the following parameters:
//
//   - msg: ServerMessage.
//
func (domain *AuthDomain) Challenge(msg *ServerMessage) {
	var _arg0 *C.SoupAuthDomain    // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_auth_domain_challenge(_arg0, _arg1)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msg)
}

// CheckPassword checks if msg authenticates to domain via username and
// password.
//
// This would normally be called from a authdomaingenericauthcallback.
//
// The function takes the following parameters:
//
//   - msg: ServerMessage.
//   - username: username.
//   - password: password.
//
// The function returns the following values:
//
//   - ok: whether or not the message is authenticated.
//
func (domain *AuthDomain) CheckPassword(msg *ServerMessage, username, password string) bool {
	var _arg0 *C.SoupAuthDomain    // out
	var _arg1 *C.SoupServerMessage // out
	var _arg2 *C.char              // out
	var _arg3 *C.char              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(username)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(password)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.soup_auth_domain_check_password(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(username)
	runtime.KeepAlive(password)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Covers checks if domain requires msg to be authenticated (according to its
// paths and filter function).
//
// This does not actually look at whether msg *is* authenticated, merely whether
// or not it needs to be.
//
// This is used by server internally and is probably of no use to anyone else.
//
// The function takes the following parameters:
//
//   - msg: ServerMessage.
//
// The function returns the following values:
//
//   - ok: TRUE if domain requires msg to be authenticated.
//
func (domain *AuthDomain) Covers(msg *ServerMessage) bool {
	var _arg0 *C.SoupAuthDomain    // out
	var _arg1 *C.SoupServerMessage // out
	var _cret C.gboolean           // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_auth_domain_covers(_arg0, _arg1)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Realm gets the realm name associated with domain.
//
// The function returns the following values:
//
//   - utf8 domain's realm.
//
func (domain *AuthDomain) Realm() string {
	var _arg0 *C.SoupAuthDomain // out
	var _cret *C.char           // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))

	_cret = C.soup_auth_domain_get_realm(_arg0)
	runtime.KeepAlive(domain)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// RemovePath removes path from domain.
//
// Requests under path on domain's server will NOT require authentication.
//
// This is not simply an undo-er for authdomain.AddPath; it can be used to
// "carve out" a subtree that does not require authentication inside a hierarchy
// that does. Note also that unlike with authdomain.AddPath, this cannot be
// overridden by adding a filter, as filters can only bypass authentication
// that would otherwise be required, not require it where it would otherwise be
// unnecessary.
//
// The function takes the following parameters:
//
//   - path to remove from domain.
//
func (domain *AuthDomain) RemovePath(path string) {
	var _arg0 *C.SoupAuthDomain // out
	var _arg1 *C.char           // out

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_auth_domain_remove_path(_arg0, _arg1)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(path)
}

// SetFilter adds filter as an authentication filter to domain.
//
// The filter gets a chance to bypass authentication for certain requests that
// would otherwise require it. Eg, it might check the message's path in some way
// that is too complicated to do via the other methods, or it might check the
// message's method, and allow GETs but not PUTs.
//
// The filter function returns TRUE if the request should still require
// authentication, or FALSE if authentication is unnecessary for this request.
//
// To help prevent security holes, your filter should return TRUE by default,
// and only return FALSE under specifically-tested circumstances, rather
// than the other way around. Eg, in the example above, where you want to
// authenticate PUTs but not GETs, you should check if the method is GET and
// return FALSE in that case, and then return TRUE for all other methods (rather
// than returning TRUE for PUT and FALSE for all other methods). This way if
// it turned out (now or later) that some paths supported additional methods
// besides GET and PUT, those methods would default to being NOT allowed for
// unauthenticated users.
//
// You can also set the filter by setting the SoupAuthDomain:filter and
// authdomain:filter-data properties, which can also be used to set the filter
// at construct time.
//
// The function takes the following parameters:
//
//   - filter: auth filter for domain.
//
func (domain *AuthDomain) SetFilter(filter AuthDomainFilter) {
	var _arg0 *C.SoupAuthDomain      // out
	var _arg1 C.SoupAuthDomainFilter // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))
	_arg1 = (*[0]byte)(C._gotk4_soup3_AuthDomainFilter)
	_arg2 = C.gpointer(gbox.Assign(filter))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_auth_domain_set_filter(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(filter)
}

// SetGenericAuthCallback sets auth_callback as an authentication-handling
// callback for domain.
//
// Whenever a request comes in to domain which cannot be authenticated via
// a domain-specific auth callback (eg, authdomaindigestauthcallback), the
// generic auth callback will be invoked. See authdomaingenericauthcallback for
// information on what the callback should do.
//
// The function takes the following parameters:
//
//   - authCallback: auth callback.
//
func (domain *AuthDomain) SetGenericAuthCallback(authCallback AuthDomainGenericAuthCallback) {
	var _arg0 *C.SoupAuthDomain                   // out
	var _arg1 C.SoupAuthDomainGenericAuthCallback // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))
	_arg1 = (*[0]byte)(C._gotk4_soup3_AuthDomainGenericAuthCallback)
	_arg2 = C.gpointer(gbox.Assign(authCallback))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_auth_domain_set_generic_auth_callback(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(authCallback)
}

// The function takes the following parameters:
//
//   - msg
//   - header
//
// The function returns the following values:
//
func (domain *AuthDomain) accepts(msg *ServerMessage, header string) string {
	gclass := (*C.SoupAuthDomainClass)(coreglib.PeekParentClass(domain))
	fnarg := gclass.accepts

	var _arg0 *C.SoupAuthDomain    // out
	var _arg1 *C.SoupServerMessage // out
	var _arg2 *C.char              // out
	var _cret *C.char              // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(header)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C._gotk4_soup3_AuthDomain_virtual_accepts(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(header)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Challenge adds a "WWW-Authenticate" or "Proxy-Authenticate" header to msg.
//
// It requests that the client authenticate, and sets msg's status accordingly.
//
// This is used by server internally and is probably of no use to anyone else.
//
// The function takes the following parameters:
//
//   - msg: ServerMessage.
//
// The function returns the following values:
//
func (domain *AuthDomain) challenge(msg *ServerMessage) string {
	gclass := (*C.SoupAuthDomainClass)(coreglib.PeekParentClass(domain))
	fnarg := gclass.challenge

	var _arg0 *C.SoupAuthDomain    // out
	var _arg1 *C.SoupServerMessage // out
	var _cret *C.char              // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C._gotk4_soup3_AuthDomain_virtual_challenge(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msg)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// checkPassword checks if msg authenticates to domain via username and
// password.
//
// This would normally be called from a authdomaingenericauthcallback.
//
// The function takes the following parameters:
//
//   - msg: ServerMessage.
//   - username: username.
//   - password: password.
//
// The function returns the following values:
//
//   - ok: whether or not the message is authenticated.
//
func (domain *AuthDomain) checkPassword(msg *ServerMessage, username, password string) bool {
	gclass := (*C.SoupAuthDomainClass)(coreglib.PeekParentClass(domain))
	fnarg := gclass.check_password

	var _arg0 *C.SoupAuthDomain    // out
	var _arg1 *C.SoupServerMessage // out
	var _arg2 *C.char              // out
	var _arg3 *C.char              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(domain).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(username)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(password)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C._gotk4_soup3_AuthDomain_virtual_check_password(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(username)
	runtime.KeepAlive(password)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AuthDomainClass: instance of this type is always passed by reference.
type AuthDomainClass struct {
	*authDomainClass
}

// authDomainClass is the struct that's finalized.
type authDomainClass struct {
	native *C.SoupAuthDomainClass
}

func (a *AuthDomainClass) Padding() [6]unsafe.Pointer {
	valptr := &a.native.padding
	var _v [6]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 6; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}
