// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void _gotk4_soup3_CookieJar_ConnectChanged(gpointer, SoupCookie*, SoupCookie*, guintptr);
// extern void _gotk4_soup3_CookieJarClass_save(SoupCookieJar*);
// extern void _gotk4_soup3_CookieJarClass_changed(SoupCookieJar*, SoupCookie*, SoupCookie*);
// extern gboolean _gotk4_soup3_CookieJarClass_is_persistent(SoupCookieJar*);
// gboolean _gotk4_soup3_CookieJar_virtual_is_persistent(void* fnptr, SoupCookieJar* arg0) {
//   return ((gboolean (*)(SoupCookieJar*))(fnptr))(arg0);
// };
// void _gotk4_soup3_CookieJar_virtual_changed(void* fnptr, SoupCookieJar* arg0, SoupCookie* arg1, SoupCookie* arg2) {
//   ((void (*)(SoupCookieJar*, SoupCookie*, SoupCookie*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_soup3_CookieJar_virtual_save(void* fnptr, SoupCookieJar* arg0) {
//   ((void (*)(SoupCookieJar*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeCookieJarAcceptPolicy = coreglib.Type(C.soup_cookie_jar_accept_policy_get_type())
	GTypeCookieJar             = coreglib.Type(C.soup_cookie_jar_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCookieJarAcceptPolicy, F: marshalCookieJarAcceptPolicy},
		coreglib.TypeMarshaler{T: GTypeCookieJar, F: marshalCookieJar},
	})
}

// CookieJarAcceptPolicy: policy for accepting or rejecting cookies returned in
// responses.
type CookieJarAcceptPolicy C.gint

const (
	// CookieJarAcceptAlways: accept all cookies unconditionally.
	CookieJarAcceptAlways CookieJarAcceptPolicy = iota
	// CookieJarAcceptNever: reject all cookies unconditionally.
	CookieJarAcceptNever
	// CookieJarAcceptNoThirdParty: accept all cookies set by the main
	// document loaded in the application using libsoup. An example of the
	// most common case, web browsers, would be: If http://www.example.com
	// is the page loaded, accept all cookies set by example.com, but if a
	// resource from http://www.third-party.com is loaded from that page
	// reject any cookie that it could try to set. For libsoup to be able to
	// tell apart first party cookies from the rest, the application must call
	// message.SetFirstParty on each outgoing message, setting the glib.URI of
	// the main document. If no first party is set in a message when this policy
	// is in effect, cookies will be assumed to be third party by default.
	CookieJarAcceptNoThirdParty
	// CookieJarAcceptGrandfatheredThirdParty: accept all cookies set by the
	// main document loaded in the application using libsoup, and from domains
	// that have previously set at least one cookie when loaded as the main
	// document. An example of the most common case, web browsers, would be:
	// if http://www.example.com is the page loaded, accept all cookies set
	// by example.com, but if a resource from http://www.third-party.com is
	// loaded from that page, reject any cookie that it could try to set unless
	// it already has a cookie in the cookie jar. For libsoup to be able to
	// tell apart first party cookies from the rest, the application must call
	// message.SetFirstParty on each outgoing Message, setting the glib.URI of
	// the main document. If no first party is set in a message when this policy
	// is in effect, cookies will be assumed to be third party by default.
	CookieJarAcceptGrandfatheredThirdParty
)

func marshalCookieJarAcceptPolicy(p uintptr) (interface{}, error) {
	return CookieJarAcceptPolicy(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CookieJarAcceptPolicy.
func (c CookieJarAcceptPolicy) String() string {
	switch c {
	case CookieJarAcceptAlways:
		return "Always"
	case CookieJarAcceptNever:
		return "Never"
	case CookieJarAcceptNoThirdParty:
		return "NoThirdParty"
	case CookieJarAcceptGrandfatheredThirdParty:
		return "GrandfatheredThirdParty"
	default:
		return fmt.Sprintf("CookieJarAcceptPolicy(%d)", c)
	}
}

// CookieJarOverrides contains methods that are overridable.
type CookieJarOverrides struct {
	// The function takes the following parameters:
	//
	//   - oldCookie
	//   - newCookie
	//
	Changed func(oldCookie, newCookie *Cookie)
	// IsPersistent gets whether jar stores cookies persistenly.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if jar storage is persistent or FALSE otherwise.
	//
	IsPersistent func() bool
	Save         func()
}

func defaultCookieJarOverrides(v *CookieJar) CookieJarOverrides {
	return CookieJarOverrides{
		Changed:      v.changed,
		IsPersistent: v.isPersistent,
		Save:         v.save,
	}
}

// CookieJar: automatic cookie handling for SoupSession.
//
// A CookieJar stores cookies and arrange for them to be sent with the
// appropriate messages. CookieJar implements sessionfeature, so you can add a
// cookie jar to a session with session.AddFeature or session.AddFeatureByType.
//
// Note that the base CookieJar class does not support any form of long-term
// cookie persistence.
type CookieJar struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SessionFeature
}

var (
	_ coreglib.Objector = (*CookieJar)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CookieJar, *CookieJarClass, CookieJarOverrides](
		GTypeCookieJar,
		initCookieJarClass,
		wrapCookieJar,
		defaultCookieJarOverrides,
	)
}

func initCookieJarClass(gclass unsafe.Pointer, overrides CookieJarOverrides, classInitFunc func(*CookieJarClass)) {
	pclass := (*C.SoupCookieJarClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeCookieJar))))

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_soup3_CookieJarClass_changed)
	}

	if overrides.IsPersistent != nil {
		pclass.is_persistent = (*[0]byte)(C._gotk4_soup3_CookieJarClass_is_persistent)
	}

	if overrides.Save != nil {
		pclass.save = (*[0]byte)(C._gotk4_soup3_CookieJarClass_save)
	}

	if classInitFunc != nil {
		class := (*CookieJarClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCookieJar(obj *coreglib.Object) *CookieJar {
	return &CookieJar{
		Object: obj,
		SessionFeature: SessionFeature{
			Object: obj,
		},
	}
}

func marshalCookieJar(p uintptr) (interface{}, error) {
	return wrapCookieJar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when jar changes.
//
// If a cookie has been added, new_cookie will contain the newly-added cookie
// and old_cookie will be NULL. If a cookie has been deleted, old_cookie will
// contain the to-be-deleted cookie and new_cookie will be NULL. If a cookie has
// been changed, old_cookie will contain its old value, and new_cookie its new
// value.
func (jar *CookieJar) ConnectChanged(f func(oldCookie, newCookie *Cookie)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(jar, "changed", false, unsafe.Pointer(C._gotk4_soup3_CookieJar_ConnectChanged), f)
}

// NewCookieJar creates a new CookieJar.
//
// The base CookieJar class does not support persistent storage of cookies;
// use a subclass for that.
//
// The function returns the following values:
//
//   - cookieJar: new CookieJar.
//
func NewCookieJar() *CookieJar {
	var _cret *C.SoupCookieJar // in

	_cret = C.soup_cookie_jar_new()

	var _cookieJar *CookieJar // out

	_cookieJar = wrapCookieJar(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cookieJar
}

// AddCookie adds cookie to jar.
//
// Emits the cookiejar::changed signal if we are modifying an existing cookie or
// adding a valid new cookie ('valid' means that the cookie's expire date is not
// in the past).
//
// cookie will be 'stolen' by the jar, so don't free it afterwards.
//
// The function takes the following parameters:
//
//   - cookie: Cookie.
//
func (jar *CookieJar) AddCookie(cookie *Cookie) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupCookie    // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(cookie)), nil)

	C.soup_cookie_jar_add_cookie(_arg0, _arg1)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(cookie)
}

// AddCookieFull adds cookie to jar.
//
// Emits the cookiejar::changed signal if we are modifying an existing cookie or
// adding a valid new cookie ('valid' means that the cookie's expire date is not
// in the past).
//
// first_party will be used to reject cookies coming from third party resources
// in case such a security policy is set in the jar.
//
// uri will be used to reject setting or overwriting secure cookies from
// insecure origins. NULL is treated as secure.
//
// cookie will be 'stolen' by the jar, so don't free it afterwards.
//
// The function takes the following parameters:
//
//   - cookie: Cookie.
//   - uri (optional): URI setting the cookie.
//   - firstParty (optional): URI for the main document.
//
func (jar *CookieJar) AddCookieFull(cookie *Cookie, uri, firstParty *glib.URI) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupCookie    // out
	var _arg2 *C.GUri          // out
	var _arg3 *C.GUri          // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(cookie)), nil)
	if uri != nil {
		_arg2 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if firstParty != nil {
		_arg3 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(firstParty)))
	}

	C.soup_cookie_jar_add_cookie_full(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(firstParty)
}

// AddCookieWithFirstParty adds cookie to jar.
//
// Emits the cookiejar::changed signal if we are modifying an existing cookie or
// adding a valid new cookie ('valid' means that the cookie's expire date is not
// in the past).
//
// first_party will be used to reject cookies coming from third party resources
// in case such a security policy is set in the jar.
//
// cookie will be 'stolen' by the jar, so don't free it afterwards.
//
// For secure cookies to work properly you may want to use
// cookiejar.AddCookieFull.
//
// The function takes the following parameters:
//
//   - firstParty: URI for the main document.
//   - cookie: Cookie.
//
func (jar *CookieJar) AddCookieWithFirstParty(firstParty *glib.URI, cookie *Cookie) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.GUri          // out
	var _arg2 *C.SoupCookie    // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))
	_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(firstParty)))
	_arg2 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(cookie)), nil)

	C.soup_cookie_jar_add_cookie_with_first_party(_arg0, _arg1, _arg2)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(firstParty)
	runtime.KeepAlive(cookie)
}

// AllCookies constructs a glib.List with every cookie inside the jar.
//
// The cookies in the list are a copy of the original, so you have to free them
// when you are done with them.
//
// The function returns the following values:
//
//   - sList: List with all the cookies in the jar.
//
func (jar *CookieJar) AllCookies() []*Cookie {
	var _arg0 *C.SoupCookieJar // out
	var _cret *C.GSList        // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))

	_cret = C.soup_cookie_jar_all_cookies(_arg0)
	runtime.KeepAlive(jar)

	var _sList []*Cookie // out

	_sList = make([]*Cookie, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupCookie)(v)
		var dst *Cookie // out
		dst = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_cookie_free((*C.SoupCookie)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// DeleteCookie deletes cookie from jar.
//
// Emits the cookiejar::changed signal.
//
// The function takes the following parameters:
//
//   - cookie: Cookie.
//
func (jar *CookieJar) DeleteCookie(cookie *Cookie) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupCookie    // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	C.soup_cookie_jar_delete_cookie(_arg0, _arg1)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(cookie)
}

// AcceptPolicy gets jar's cookiejaracceptpolicy.
//
// The function returns the following values:
//
//   - cookieJarAcceptPolicy set in the jar.
//
func (jar *CookieJar) AcceptPolicy() CookieJarAcceptPolicy {
	var _arg0 *C.SoupCookieJar            // out
	var _cret C.SoupCookieJarAcceptPolicy // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))

	_cret = C.soup_cookie_jar_get_accept_policy(_arg0)
	runtime.KeepAlive(jar)

	var _cookieJarAcceptPolicy CookieJarAcceptPolicy // out

	_cookieJarAcceptPolicy = CookieJarAcceptPolicy(_cret)

	return _cookieJarAcceptPolicy
}

// CookieList retrieves the list of cookies that would be sent with a request to
// uri as a glib.List of Cookie objects.
//
// If for_http is TRUE, the return value will include cookies marked "HttpOnly"
// (that is, cookies that the server wishes to keep hidden from client-side
// scripting operations such as the JavaScript document.cookies property). Since
// CookieJar sets the Cookie header itself when making the actual HTTP request,
// you should almost certainly be setting for_http to FALSE if you are calling
// this.
//
// The function takes the following parameters:
//
//   - uri: #GUri.
//   - forHttp: whether or not the return value is being passed directly to an
//     HTTP operation.
//
// The function returns the following values:
//
//   - sList: List with the cookies in the jar that would be sent with a request
//     to uri.
//
func (jar *CookieJar) CookieList(uri *glib.URI, forHttp bool) []*Cookie {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.GUri          // out
	var _arg2 C.gboolean       // out
	var _cret *C.GSList        // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))
	_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))
	if forHttp {
		_arg2 = C.TRUE
	}

	_cret = C.soup_cookie_jar_get_cookie_list(_arg0, _arg1, _arg2)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(forHttp)

	var _sList []*Cookie // out

	_sList = make([]*Cookie, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupCookie)(v)
		var dst *Cookie // out
		dst = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_cookie_free((*C.SoupCookie)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// CookieListWithSameSiteInfo: this is an extended version of
// cookiejar.GetCookieList that provides more information required to use
// SameSite cookies.
//
// See the [SameSite cookies
// spec](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for
// more detailed information.
//
// The function takes the following parameters:
//
//   - uri: #GUri.
//   - topLevel (optional) for the top level document.
//   - siteForCookies (optional) indicating the origin to get cookies for.
//   - forHttp: whether or not the return value is being passed directly to an
//     HTTP operation.
//   - isSafeMethod: if the HTTP method is safe, as defined by RFC 7231, ignored
//     when for_http is FALSE.
//   - isTopLevelNavigation: whether or not the HTTP request is part of top
//     level navigation.
//
// The function returns the following values:
//
//   - sList: List with the cookies in the jar that would be sent with a request
//     to uri.
//
func (jar *CookieJar) CookieListWithSameSiteInfo(uri, topLevel, siteForCookies *glib.URI, forHttp, isSafeMethod, isTopLevelNavigation bool) []*Cookie {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.GUri          // out
	var _arg2 *C.GUri          // out
	var _arg3 *C.GUri          // out
	var _arg4 C.gboolean       // out
	var _arg5 C.gboolean       // out
	var _arg6 C.gboolean       // out
	var _cret *C.GSList        // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))
	_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))
	if topLevel != nil {
		_arg2 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(topLevel)))
	}
	if siteForCookies != nil {
		_arg3 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(siteForCookies)))
	}
	if forHttp {
		_arg4 = C.TRUE
	}
	if isSafeMethod {
		_arg5 = C.TRUE
	}
	if isTopLevelNavigation {
		_arg6 = C.TRUE
	}

	_cret = C.soup_cookie_jar_get_cookie_list_with_same_site_info(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(topLevel)
	runtime.KeepAlive(siteForCookies)
	runtime.KeepAlive(forHttp)
	runtime.KeepAlive(isSafeMethod)
	runtime.KeepAlive(isTopLevelNavigation)

	var _sList []*Cookie // out

	_sList = make([]*Cookie, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupCookie)(v)
		var dst *Cookie // out
		dst = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_cookie_free((*C.SoupCookie)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// Cookies retrieves (in Cookie-header form) the list of cookies that would be
// sent with a request to uri.
//
// If for_http is TRUE, the return value will include cookies marked "HttpOnly"
// (that is, cookies that the server wishes to keep hidden from client-side
// scripting operations such as the JavaScript document.cookies property). Since
// CookieJar sets the Cookie header itself when making the actual HTTP request,
// you should almost certainly be setting for_http to FALSE if you are calling
// this.
//
// The function takes the following parameters:
//
//   - uri: #GUri.
//   - forHttp: whether or not the return value is being passed directly to an
//     HTTP operation.
//
// The function returns the following values:
//
//   - utf8 (optional): cookies, in string form, or NULL if there are no cookies
//     for uri.
//
func (jar *CookieJar) Cookies(uri *glib.URI, forHttp bool) string {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.GUri          // out
	var _arg2 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))
	_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))
	if forHttp {
		_arg2 = C.TRUE
	}

	_cret = C.soup_cookie_jar_get_cookies(_arg0, _arg1, _arg2)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(forHttp)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// IsPersistent gets whether jar stores cookies persistenly.
//
// The function returns the following values:
//
//   - ok: TRUE if jar storage is persistent or FALSE otherwise.
//
func (jar *CookieJar) IsPersistent() bool {
	var _arg0 *C.SoupCookieJar // out
	var _cret C.gboolean       // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))

	_cret = C.soup_cookie_jar_is_persistent(_arg0)
	runtime.KeepAlive(jar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAcceptPolicy sets policy as the cookie acceptance policy for jar.
//
// The function takes the following parameters:
//
//   - policy: CookieJarAcceptPolicy.
//
func (jar *CookieJar) SetAcceptPolicy(policy CookieJarAcceptPolicy) {
	var _arg0 *C.SoupCookieJar            // out
	var _arg1 C.SoupCookieJarAcceptPolicy // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))
	_arg1 = C.SoupCookieJarAcceptPolicy(policy)

	C.soup_cookie_jar_set_accept_policy(_arg0, _arg1)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(policy)
}

// SetCookie adds cookie to jar, exactly as though it had appeared in a
// Set-Cookie header returned from a request to uri.
//
// Keep in mind that if the cookiejaracceptpolicy set
// is either SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY or
// SOUP_COOKIE_JAR_ACCEPT_GRANDFATHERED_THIRD_PARTY you'll need to use
// cookiejar.SetCookieWithFirstParty, otherwise the jar will have no way of
// knowing if the cookie is being set by a third party or not.
//
// The function takes the following parameters:
//
//   - uri: URI setting the cookie.
//   - cookie: stringified cookie to set.
//
func (jar *CookieJar) SetCookie(uri *glib.URI, cookie string) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.GUri          // out
	var _arg2 *C.char          // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))
	_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(cookie)))
	defer C.free(unsafe.Pointer(_arg2))

	C.soup_cookie_jar_set_cookie(_arg0, _arg1, _arg2)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(cookie)
}

// SetCookieWithFirstParty adds cookie to jar, exactly as though it had appeared
// in a Set-Cookie header returned from a request to uri.
//
// first_party will be used to reject cookies coming from third party resources
// in case such a security policy is set in the jar.
//
// The function takes the following parameters:
//
//   - uri: URI setting the cookie.
//   - firstParty: URI for the main document.
//   - cookie: stringified cookie to set.
//
func (jar *CookieJar) SetCookieWithFirstParty(uri, firstParty *glib.URI, cookie string) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.GUri          // out
	var _arg2 *C.GUri          // out
	var _arg3 *C.char          // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))
	_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))
	_arg2 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(firstParty)))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(cookie)))
	defer C.free(unsafe.Pointer(_arg3))

	C.soup_cookie_jar_set_cookie_with_first_party(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(firstParty)
	runtime.KeepAlive(cookie)
}

// The function takes the following parameters:
//
//   - oldCookie
//   - newCookie
//
func (jar *CookieJar) changed(oldCookie, newCookie *Cookie) {
	gclass := (*C.SoupCookieJarClass)(coreglib.PeekParentClass(jar))
	fnarg := gclass.changed

	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupCookie    // out
	var _arg2 *C.SoupCookie    // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(oldCookie)))
	_arg2 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(newCookie)))

	C._gotk4_soup3_CookieJar_virtual_changed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(oldCookie)
	runtime.KeepAlive(newCookie)
}

// isPersistent gets whether jar stores cookies persistenly.
//
// The function returns the following values:
//
//   - ok: TRUE if jar storage is persistent or FALSE otherwise.
//
func (jar *CookieJar) isPersistent() bool {
	gclass := (*C.SoupCookieJarClass)(coreglib.PeekParentClass(jar))
	fnarg := gclass.is_persistent

	var _arg0 *C.SoupCookieJar // out
	var _cret C.gboolean       // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))

	_cret = C._gotk4_soup3_CookieJar_virtual_is_persistent(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(jar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (jar *CookieJar) save() {
	gclass := (*C.SoupCookieJarClass)(coreglib.PeekParentClass(jar))
	fnarg := gclass.save

	var _arg0 *C.SoupCookieJar // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(coreglib.InternObject(jar).Native()))

	C._gotk4_soup3_CookieJar_virtual_save(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(jar)
}

// CookieJarClass: instance of this type is always passed by reference.
type CookieJarClass struct {
	*cookieJarClass
}

// cookieJarClass is the struct that's finalized.
type cookieJarClass struct {
	native *C.SoupCookieJarClass
}

func (c *CookieJarClass) Padding() [6]unsafe.Pointer {
	valptr := &c.native.padding
	var _v [6]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 6; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}
