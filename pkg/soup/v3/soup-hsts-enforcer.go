// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void _gotk4_soup3_HSTSEnforcer_ConnectChanged(gpointer, SoupHSTSPolicy*, SoupHSTSPolicy*, guintptr);
// extern void _gotk4_soup3_HSTSEnforcerClass_changed(SoupHSTSEnforcer*, SoupHSTSPolicy*, SoupHSTSPolicy*);
// extern gboolean _gotk4_soup3_HSTSEnforcerClass_is_persistent(SoupHSTSEnforcer*);
// extern gboolean _gotk4_soup3_HSTSEnforcerClass_has_valid_policy(SoupHSTSEnforcer*, char*);
// gboolean _gotk4_soup3_HSTSEnforcer_virtual_has_valid_policy(void* fnptr, SoupHSTSEnforcer* arg0, char* arg1) {
//   return ((gboolean (*)(SoupHSTSEnforcer*, char*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_soup3_HSTSEnforcer_virtual_is_persistent(void* fnptr, SoupHSTSEnforcer* arg0) {
//   return ((gboolean (*)(SoupHSTSEnforcer*))(fnptr))(arg0);
// };
// void _gotk4_soup3_HSTSEnforcer_virtual_changed(void* fnptr, SoupHSTSEnforcer* arg0, SoupHSTSPolicy* arg1, SoupHSTSPolicy* arg2) {
//   ((void (*)(SoupHSTSEnforcer*, SoupHSTSPolicy*, SoupHSTSPolicy*))(fnptr))(arg0, arg1, arg2);
// };
import "C"

// GType values.
var (
	GTypeHSTSEnforcer = coreglib.Type(C.soup_hsts_enforcer_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeHSTSEnforcer, F: marshalHSTSEnforcer},
	})
}

// HSTSEnforcerOverrides contains methods that are overridable.
type HSTSEnforcerOverrides struct {
	// The function takes the following parameters:
	//
	//   - oldPolicy
	//   - newPolicy
	//
	Changed func(oldPolicy, newPolicy *HSTSPolicy)
	// HasValidPolicy gets whether hsts_enforcer has a currently valid policy
	// for domain.
	//
	// The function takes the following parameters:
	//
	//   - domain: domain.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if access to domain should happen over HTTPS, false
	//     otherwise.
	//
	HasValidPolicy func(domain string) bool
	// IsPersistent gets whether hsts_enforcer stores policies persistenly.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if hsts_enforcer storage is persistent or FALSE otherwise.
	//
	IsPersistent func() bool
}

func defaultHSTSEnforcerOverrides(v *HSTSEnforcer) HSTSEnforcerOverrides {
	return HSTSEnforcerOverrides{
		Changed:        v.changed,
		HasValidPolicy: v.hasValidPolicy,
		IsPersistent:   v.isPersistent,
	}
}

// HSTSEnforcer: automatic HTTP Strict Transport Security enforcing for session.
//
// A HSTSEnforcer stores HSTS policies and enforces them when required.
// HSTSEnforcer implements sessionfeature, so you can add an HSTS enforcer to a
// session with session.AddFeature or session.AddFeatureByType.
//
// HSTSEnforcer keeps track of all the HTTPS destinations that, when connected
// to, return the Strict-Transport-Security header with valid values.
// HSTSEnforcer will forget those destinations upon expiry or when the server
// requests it.
//
// When the session the HSTSEnforcer is attached to queues or restarts a
// message, the HSTSEnforcer will rewrite the URI to HTTPS if the destination
// is a known HSTS host and is contacted over an insecure transport protocol
// (HTTP). Users of HSTSEnforcer are advised to listen to changes in the
// message:uri property in order to be aware of changes in the message URI.
//
// Note that HSTSEnforcer does not support any form of long-term HSTS policy
// persistence. See hstsenforcerdb for a persistent enforcer.
type HSTSEnforcer struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SessionFeature
}

var (
	_ coreglib.Objector = (*HSTSEnforcer)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*HSTSEnforcer, *HSTSEnforcerClass, HSTSEnforcerOverrides](
		GTypeHSTSEnforcer,
		initHSTSEnforcerClass,
		wrapHSTSEnforcer,
		defaultHSTSEnforcerOverrides,
	)
}

func initHSTSEnforcerClass(gclass unsafe.Pointer, overrides HSTSEnforcerOverrides, classInitFunc func(*HSTSEnforcerClass)) {
	pclass := (*C.SoupHSTSEnforcerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeHSTSEnforcer))))

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_soup3_HSTSEnforcerClass_changed)
	}

	if overrides.HasValidPolicy != nil {
		pclass.has_valid_policy = (*[0]byte)(C._gotk4_soup3_HSTSEnforcerClass_has_valid_policy)
	}

	if overrides.IsPersistent != nil {
		pclass.is_persistent = (*[0]byte)(C._gotk4_soup3_HSTSEnforcerClass_is_persistent)
	}

	if classInitFunc != nil {
		class := (*HSTSEnforcerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapHSTSEnforcer(obj *coreglib.Object) *HSTSEnforcer {
	return &HSTSEnforcer{
		Object: obj,
		SessionFeature: SessionFeature{
			Object: obj,
		},
	}
}

func marshalHSTSEnforcer(p uintptr) (interface{}, error) {
	return wrapHSTSEnforcer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when hsts_enforcer changes.
//
// If a policy has been added, new_policy will contain the newly-added policy
// and old_policy will be NULL. If a policy has been deleted, old_policy will
// contain the to-be-deleted policy and new_policy will be NULL. If a policy has
// been changed, old_policy will contain its old value, and new_policy its new
// value.
//
// Note that you shouldn't modify the policies from a callback to this signal.
func (hstsEnforcer *HSTSEnforcer) ConnectChanged(f func(oldPolicy, newPolicy *HSTSPolicy)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(hstsEnforcer, "changed", false, unsafe.Pointer(C._gotk4_soup3_HSTSEnforcer_ConnectChanged), f)
}

// NewHSTSEnforcer creates a new HSTSEnforcer.
//
// The base HSTSEnforcer class does not support persistent storage of HSTS
// policies, see hstsenforcerdb for that.
//
// The function returns the following values:
//
//   - hstsEnforcer: new HSTSEnforcer.
//
func NewHSTSEnforcer() *HSTSEnforcer {
	var _cret *C.SoupHSTSEnforcer // in

	_cret = C.soup_hsts_enforcer_new()

	var _hstsEnforcer *HSTSEnforcer // out

	_hstsEnforcer = wrapHSTSEnforcer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _hstsEnforcer
}

// Domains gets a list of domains for which there are policies in enforcer.
//
// The function takes the following parameters:
//
//   - sessionPolicies: whether to include session policies.
//
// The function returns the following values:
//
//   - list: newly allocated list of domains. Use glib.List().FreeFull and
//     glib.Free() to free the list.
//
func (hstsEnforcer *HSTSEnforcer) Domains(sessionPolicies bool) []string {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 C.gboolean          // out
	var _cret *C.GList            // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	if sessionPolicies {
		_arg1 = C.TRUE
	}

	_cret = C.soup_hsts_enforcer_get_domains(_arg0, _arg1)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(sessionPolicies)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_list = append(_list, dst)
	})

	return _list
}

// Policies gets a list with the policies in enforcer.
//
// The function takes the following parameters:
//
//   - sessionPolicies: whether to include session policies.
//
// The function returns the following values:
//
//   - list: newly allocated list of policies. Use glib.List().FreeFull and
//     hstspolicy.Free to free the list.
//
func (hstsEnforcer *HSTSEnforcer) Policies(sessionPolicies bool) []*HSTSPolicy {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 C.gboolean          // out
	var _cret *C.GList            // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	if sessionPolicies {
		_arg1 = C.TRUE
	}

	_cret = C.soup_hsts_enforcer_get_policies(_arg0, _arg1)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(sessionPolicies)

	var _list []*HSTSPolicy // out

	_list = make([]*HSTSPolicy, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupHSTSPolicy)(v)
		var dst *HSTSPolicy // out
		dst = (*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_hsts_policy_free((*C.SoupHSTSPolicy)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// HasValidPolicy gets whether hsts_enforcer has a currently valid policy for
// domain.
//
// The function takes the following parameters:
//
//   - domain: domain.
//
// The function returns the following values:
//
//   - ok: TRUE if access to domain should happen over HTTPS, false otherwise.
//
func (hstsEnforcer *HSTSEnforcer) HasValidPolicy(domain string) bool {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.soup_hsts_enforcer_has_valid_policy(_arg0, _arg1)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(domain)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsPersistent gets whether hsts_enforcer stores policies persistenly.
//
// The function returns the following values:
//
//   - ok: TRUE if hsts_enforcer storage is persistent or FALSE otherwise.
//
func (hstsEnforcer *HSTSEnforcer) IsPersistent() bool {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _cret C.gboolean          // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))

	_cret = C.soup_hsts_enforcer_is_persistent(_arg0)
	runtime.KeepAlive(hstsEnforcer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPolicy sets policy to hsts_enforcer.
//
// If policy is expired, any existing HSTS policy for its host will be removed
// instead. If a policy existed for this host, it will be replaced. Otherwise,
// the new policy will be inserted. If the policy is a session policy, that is,
// one created with hstspolicy.NewSessionPolicy, the policy will not expire and
// will be enforced during the lifetime of hsts_enforcer's session.
//
// The function takes the following parameters:
//
//   - policy of the HSTS host.
//
func (hstsEnforcer *HSTSEnforcer) SetPolicy(policy *HSTSPolicy) {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.SoupHSTSPolicy   // out

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	_arg1 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy)))

	C.soup_hsts_enforcer_set_policy(_arg0, _arg1)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(policy)
}

// SetSessionPolicy sets a session policy for domain.
//
// A session policy is a policy that is permanent to the lifetime of
// hsts_enforcer's session and doesn't expire.
//
// The function takes the following parameters:
//
//   - domain: policy domain or hostname.
//   - includeSubdomains: TRUE if the policy applies on sub domains.
//
func (hstsEnforcer *HSTSEnforcer) SetSessionPolicy(domain string, includeSubdomains bool) {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.char             // out
	var _arg2 C.gboolean          // out

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))
	if includeSubdomains {
		_arg2 = C.TRUE
	}

	C.soup_hsts_enforcer_set_session_policy(_arg0, _arg1, _arg2)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(includeSubdomains)
}

// The function takes the following parameters:
//
//   - oldPolicy
//   - newPolicy
//
func (enforcer *HSTSEnforcer) changed(oldPolicy, newPolicy *HSTSPolicy) {
	gclass := (*C.SoupHSTSEnforcerClass)(coreglib.PeekParentClass(enforcer))
	fnarg := gclass.changed

	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.SoupHSTSPolicy   // out
	var _arg2 *C.SoupHSTSPolicy   // out

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(enforcer).Native()))
	_arg1 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(oldPolicy)))
	_arg2 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(newPolicy)))

	C._gotk4_soup3_HSTSEnforcer_virtual_changed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(enforcer)
	runtime.KeepAlive(oldPolicy)
	runtime.KeepAlive(newPolicy)
}

// hasValidPolicy gets whether hsts_enforcer has a currently valid policy for
// domain.
//
// The function takes the following parameters:
//
//   - domain: domain.
//
// The function returns the following values:
//
//   - ok: TRUE if access to domain should happen over HTTPS, false otherwise.
//
func (hstsEnforcer *HSTSEnforcer) hasValidPolicy(domain string) bool {
	gclass := (*C.SoupHSTSEnforcerClass)(coreglib.PeekParentClass(hstsEnforcer))
	fnarg := gclass.has_valid_policy

	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_soup3_HSTSEnforcer_virtual_has_valid_policy(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(domain)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// isPersistent gets whether hsts_enforcer stores policies persistenly.
//
// The function returns the following values:
//
//   - ok: TRUE if hsts_enforcer storage is persistent or FALSE otherwise.
//
func (hstsEnforcer *HSTSEnforcer) isPersistent() bool {
	gclass := (*C.SoupHSTSEnforcerClass)(coreglib.PeekParentClass(hstsEnforcer))
	fnarg := gclass.is_persistent

	var _arg0 *C.SoupHSTSEnforcer // out
	var _cret C.gboolean          // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))

	_cret = C._gotk4_soup3_HSTSEnforcer_virtual_is_persistent(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(hstsEnforcer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HSTSEnforcerClass class structure for HSTSEnforcer.
//
// An instance of this type is always passed by reference.
type HSTSEnforcerClass struct {
	*hstsEnforcerClass
}

// hstsEnforcerClass is the struct that's finalized.
type hstsEnforcerClass struct {
	native *C.SoupHSTSEnforcerClass
}
