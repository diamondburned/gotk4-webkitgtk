// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"context"
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void _gotk4_soup3_Session_ConnectRequestUnqueued(gpointer, SoupMessage*, guintptr);
// extern void _gotk4_soup3_Session_ConnectRequestQueued(gpointer, SoupMessage*, guintptr);
// extern void _gotk4_soup3_SessionClass_request_unqueued(SoupSession*, SoupMessage*);
// extern void _gotk4_soup3_SessionClass_request_queued(SoupSession*, SoupMessage*);
// void _gotk4_soup3_Session_virtual_request_queued(void* fnptr, SoupSession* arg0, SoupMessage* arg1) {
//   ((void (*)(SoupSession*, SoupMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_soup3_Session_virtual_request_unqueued(void* fnptr, SoupSession* arg0, SoupMessage* arg1) {
//   ((void (*)(SoupSession*, SoupMessage*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeSessionError = coreglib.Type(C.soup_session_error_get_type())
	GTypeSession      = coreglib.Type(C.soup_session_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSessionError, F: marshalSessionError},
		coreglib.TypeMarshaler{T: GTypeSession, F: marshalSession},
	})
}

// SessionError: Session error.
type SessionError C.gint

const (
	// SessionErrorParsing server's response could not be parsed.
	SessionErrorParsing SessionError = iota
	// SessionErrorEncoding server's response was in an unsupported format.
	SessionErrorEncoding
	// SessionErrorTooManyRedirects: message has been redirected too many times.
	SessionErrorTooManyRedirects
	// SessionErrorTooManyRestarts: message has been restarted too many times.
	SessionErrorTooManyRestarts
	// SessionErrorRedirectNoLocation: failed to redirect message because
	// Location header was missing or empty in response.
	SessionErrorRedirectNoLocation
	// SessionErrorRedirectBadURI: failed to redirect message because Location
	// header contains an invalid URI.
	SessionErrorRedirectBadURI
	// SessionErrorMessageAlreadyInQueue: message is already in the session
	// queue. Messages can only be reused after unqueued.
	SessionErrorMessageAlreadyInQueue
)

func marshalSessionError(p uintptr) (interface{}, error) {
	return SessionError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SessionError.
func (s SessionError) String() string {
	switch s {
	case SessionErrorParsing:
		return "Parsing"
	case SessionErrorEncoding:
		return "Encoding"
	case SessionErrorTooManyRedirects:
		return "TooManyRedirects"
	case SessionErrorTooManyRestarts:
		return "TooManyRestarts"
	case SessionErrorRedirectNoLocation:
		return "RedirectNoLocation"
	case SessionErrorRedirectBadURI:
		return "RedirectBadURI"
	case SessionErrorMessageAlreadyInQueue:
		return "MessageAlreadyInQueue"
	default:
		return fmt.Sprintf("SessionError(%d)", s)
	}
}

// SessionErrorQuark registers error quark for SoupSession if needed.
//
// The function returns the following values:
//
//   - quark: error quark for SoupSession.
//
func SessionErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.soup_session_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// SessionOverrides contains methods that are overridable.
type SessionOverrides struct {
	// The function takes the following parameters:
	//
	RequestQueued func(msg *Message)
	// The function takes the following parameters:
	//
	RequestUnqueued func(msg *Message)
}

func defaultSessionOverrides(v *Session) SessionOverrides {
	return SessionOverrides{
		RequestQueued:   v.requestQueued,
		RequestUnqueued: v.requestUnqueued,
	}
}

// Session: soup session state object.
//
// Session is the object that controls client-side HTTP. A Session encapsulates
// all of the state that libsoup is keeping on behalf of your program; cached
// HTTP connections, authentication information, etc. It also keeps track of
// various global options and features that you are using.
//
// Most applications will only need a single Session; the primary reason you
// might need multiple sessions is if you need to have multiple independent
// authentication contexts. (Eg, you are connecting to a server and
// authenticating as two different users at different times; the easiest way
// to ensure that each message is sent with the authentication information you
// intended is to use one session for the first user, and a second session for
// the other user.)
//
// Additional Session functionality is provided by sessionfeature objects, which
// can be added to a session with session.AddFeature or session.AddFeatureByType
// For example, logger provides support for logging HTTP traffic, contentdecoder
// provides support for compressed response handling, and contentsniffer
// provides support for HTML5-style response body content sniffing.
// Additionally, subtypes of auth can be added as features, to add support for
// additional authentication types.
//
// All SoupSessions are created with a authmanager, and support for
// SOUP_TYPE_AUTH_BASIC and SOUP_TYPE_AUTH_DIGEST. Additionally, sessions using
// the plain Session class (rather than one of its deprecated subtypes) have a
// contentdecoder by default.
//
// Note that all async methods will invoke their callbacks on the thread-default
// context at the time of the function call.
type Session struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Session)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Session, *SessionClass, SessionOverrides](
		GTypeSession,
		initSessionClass,
		wrapSession,
		defaultSessionOverrides,
	)
}

func initSessionClass(gclass unsafe.Pointer, overrides SessionOverrides, classInitFunc func(*SessionClass)) {
	pclass := (*C.SoupSessionClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSession))))

	if overrides.RequestQueued != nil {
		pclass.request_queued = (*[0]byte)(C._gotk4_soup3_SessionClass_request_queued)
	}

	if overrides.RequestUnqueued != nil {
		pclass.request_unqueued = (*[0]byte)(C._gotk4_soup3_SessionClass_request_unqueued)
	}

	if classInitFunc != nil {
		class := (*SessionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSession(obj *coreglib.Object) *Session {
	return &Session{
		Object: obj,
	}
}

func marshalSession(p uintptr) (interface{}, error) {
	return wrapSession(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectRequestQueued is emitted when a request is queued on session.
//
// When sending a request, first session::request-queued is emitted, indicating
// that the session has become aware of the request.
//
// After a connection is available to send the request various message signals
// are emitted as the message is processed. If the message is requeued, it will
// emit message::restarted, which will then be followed by other message signals
// when the message is re-sent.
//
// Eventually, the message will emit message::finished. Normally, this signals
// the completion of message processing. However, it is possible that the
// application will requeue the message from the "finished" handler. In that
// case the process will loop back.
//
// Eventually, a message will reach "finished" and not be requeued. At that
// point, the session will emit session::request-unqueued to indicate that it is
// done with the message.
//
// To sum up: session::request-queued and session::request-unqueued are
// guaranteed to be emitted exactly once, but message::finished (and all of the
// other message signals) may be invoked multiple times for a given message.
func (session *Session) ConnectRequestQueued(f func(msg *Message)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "request-queued", false, unsafe.Pointer(C._gotk4_soup3_Session_ConnectRequestQueued), f)
}

// ConnectRequestUnqueued is emitted when a request is removed from session's
// queue, indicating that session is done with it.
//
// See session::request-queued for a detailed description of the message
// lifecycle within a session.
func (session *Session) ConnectRequestUnqueued(f func(msg *Message)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "request-unqueued", false, unsafe.Pointer(C._gotk4_soup3_Session_ConnectRequestUnqueued), f)
}

// NewSession creates a Session with the default options.
//
// The function returns the following values:
//
//   - session: new session.
//
func NewSession() *Session {
	var _cret *C.SoupSession // in

	_cret = C.soup_session_new()

	var _session *Session // out

	_session = wrapSession(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _session
}

// Abort cancels all pending requests in session and closes all idle persistent
// connections.
func (session *Session) Abort() {
	var _arg0 *C.SoupSession // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	C.soup_session_abort(_arg0)
	runtime.KeepAlive(session)
}

// AddFeature adds feature's functionality to session. You cannot add multiple
// features of the same glib.Type to a session.
//
// See the main Session documentation for information on what features are
// present in sessions by default.
//
// The function takes the following parameters:
//
//   - feature: object that implements SessionFeature.
//
func (session *Session) AddFeature(feature SessionFeaturer) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupSessionFeature // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupSessionFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	C.soup_session_add_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(feature)
}

// AddFeatureByType: if feature_type is the type of a class that implements
// sessionfeature, this creates a new feature of that type and adds it to
// session as with session.AddFeature. You can use this when you don't need to
// customize the new feature in any way. Adding multiple features of the same
// feature_type is not allowed.
//
// If feature_type is not a sessionfeature type, this gives each existing
// feature on session the chance to accept feature_type as a "subfeature".
// This can be used to add new auth types, for instance.
//
// See the main Session documentation for information on what features are
// present in sessions by default.
//
// The function takes the following parameters:
//
//   - featureType: #GType.
//
func (session *Session) AddFeatureByType(featureType coreglib.Type) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	C.soup_session_add_feature_by_type(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)
}

// AcceptLanguage: get the value used by session for the "Accept-Language"
// header on new requests.
//
// The function returns the following values:
//
//   - utf8 (optional): accept language string.
//
func (session *Session) AcceptLanguage() string {
	var _arg0 *C.SoupSession // out
	var _cret *C.char        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_accept_language(_arg0)
	runtime.KeepAlive(session)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// AcceptLanguageAuto gets whether session automatically sets the
// "Accept-Language" header on new requests.
//
// The function returns the following values:
//
//   - ok: TRUE if session sets "Accept-Language" header automatically, or FALSE
//     otherwise.
//
func (session *Session) AcceptLanguageAuto() bool {
	var _arg0 *C.SoupSession // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_accept_language_auto(_arg0)
	runtime.KeepAlive(session)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AsyncResultMessage gets the message of the result asynchronous operation This
// is useful to get the message of an asynchronous operation started by session
// from its gio.AsyncReadyCallback.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - message (optional) or NULL if result is not a valid session async
//     operation result.
//
func (session *Session) AsyncResultMessage(result gio.AsyncResulter) *Message {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.SoupMessage  // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_get_async_result_message(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _message *Message // out

	if _cret != nil {
		_message = wrapMessage(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _message
}

// Feature gets the feature in session of type feature_type.
//
// The function takes the following parameters:
//
//   - featureType of the feature to get.
//
// The function returns the following values:
//
//   - sessionFeature (optional) or NULL. The feature is owned by session.
//
func (session *Session) Feature(featureType coreglib.Type) *SessionFeature {
	var _arg0 *C.SoupSession        // out
	var _arg1 C.GType               // out
	var _cret *C.SoupSessionFeature // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_session_get_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)

	var _sessionFeature *SessionFeature // out

	if _cret != nil {
		_sessionFeature = wrapSessionFeature(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _sessionFeature
}

// FeatureForMessage gets the feature in session of type feature_type, provided
// that it is not disabled for msg.
//
// The function takes the following parameters:
//
//   - featureType of the feature to get.
//   - msg: Message.
//
// The function returns the following values:
//
//   - sessionFeature (optional) The feature is owned by session.
//
func (session *Session) FeatureForMessage(featureType coreglib.Type, msg *Message) *SessionFeature {
	var _arg0 *C.SoupSession        // out
	var _arg1 C.GType               // out
	var _arg2 *C.SoupMessage        // out
	var _cret *C.SoupSessionFeature // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)
	_arg2 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_get_feature_for_message(_arg0, _arg1, _arg2)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)
	runtime.KeepAlive(msg)

	var _sessionFeature *SessionFeature // out

	if _cret != nil {
		_sessionFeature = wrapSessionFeature(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _sessionFeature
}

// IdleTimeout: get the timeout in seconds for idle connection lifetime
// currently used by session.
//
// The function returns the following values:
//
//   - guint: timeout in seconds.
//
func (session *Session) IdleTimeout() uint {
	var _arg0 *C.SoupSession // out
	var _cret C.guint        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_idle_timeout(_arg0)
	runtime.KeepAlive(session)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// LocalAddress: get the gio.InetSocketAddress to use for the client side of
// connections in session.
//
// The function returns the following values:
//
//   - inetSocketAddress (optional): SocketAddress.
//
func (session *Session) LocalAddress() *gio.InetSocketAddress {
	var _arg0 *C.SoupSession        // out
	var _cret *C.GInetSocketAddress // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_local_address(_arg0)
	runtime.KeepAlive(session)

	var _inetSocketAddress *gio.InetSocketAddress // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_inetSocketAddress = &gio.InetSocketAddress{
				SocketAddress: gio.SocketAddress{
					Object: obj,
					SocketConnectable: gio.SocketConnectable{
						Object: obj,
					},
				},
			}
		}
	}

	return _inetSocketAddress
}

// MaxConns: get the maximum number of connections that session can open at
// once.
//
// The function returns the following values:
//
//   - guint: maximum number of connections.
//
func (session *Session) MaxConns() uint {
	var _arg0 *C.SoupSession // out
	var _cret C.guint        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_max_conns(_arg0)
	runtime.KeepAlive(session)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MaxConnsPerHost: get the maximum number of connections that session can open
// at once to a given host.
//
// The function returns the following values:
//
//   - guint: maximum number of connections per host.
//
func (session *Session) MaxConnsPerHost() uint {
	var _arg0 *C.SoupSession // out
	var _cret C.guint        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_max_conns_per_host(_arg0)
	runtime.KeepAlive(session)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ProxyResolver: get the gio.ProxyResolver currently used by session.
//
// The function returns the following values:
//
//   - proxyResolver (optional) or NULL if proxies are disabled in session.
//
func (session *Session) ProxyResolver() *gio.ProxyResolver {
	var _arg0 *C.SoupSession    // out
	var _cret *C.GProxyResolver // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_proxy_resolver(_arg0)
	runtime.KeepAlive(session)

	var _proxyResolver *gio.ProxyResolver // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_proxyResolver = &gio.ProxyResolver{
				Object: obj,
			}
		}
	}

	return _proxyResolver
}

// RemoteConnectable gets the remote connectable if one set.
//
// The function returns the following values:
//
//   - socketConnectable (optional): Connectable.
//
func (session *Session) RemoteConnectable() *gio.SocketConnectable {
	var _arg0 *C.SoupSession        // out
	var _cret *C.GSocketConnectable // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_remote_connectable(_arg0)
	runtime.KeepAlive(session)

	var _socketConnectable *gio.SocketConnectable // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_socketConnectable = &gio.SocketConnectable{
				Object: obj,
			}
		}
	}

	return _socketConnectable
}

// Timeout: get the timeout in seconds for socket I/O operations currently used
// by session.
//
// The function returns the following values:
//
//   - guint: timeout in seconds.
//
func (session *Session) Timeout() uint {
	var _arg0 *C.SoupSession // out
	var _cret C.guint        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_timeout(_arg0)
	runtime.KeepAlive(session)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TLSDatabase: get the gio.TLSDatabase currently used by session.
//
// The function returns the following values:
//
//   - tlsDatabase (optional): Database.
//
func (session *Session) TLSDatabase() gio.TLSDatabaser {
	var _arg0 *C.SoupSession  // out
	var _cret *C.GTlsDatabase // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_tls_database(_arg0)
	runtime.KeepAlive(session)

	var _tlsDatabase gio.TLSDatabaser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.TLSDatabaser)
				return ok
			})
			rv, ok := casted.(gio.TLSDatabaser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSDatabaser")
			}
			_tlsDatabase = rv
		}
	}

	return _tlsDatabase
}

// TLSInteraction: get the gio.TLSInteraction currently used by session.
//
// The function returns the following values:
//
//   - tlsInteraction (optional): Interaction.
//
func (session *Session) TLSInteraction() *gio.TLSInteraction {
	var _arg0 *C.SoupSession     // out
	var _cret *C.GTlsInteraction // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_tls_interaction(_arg0)
	runtime.KeepAlive(session)

	var _tlsInteraction *gio.TLSInteraction // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_tlsInteraction = &gio.TLSInteraction{
				Object: obj,
			}
		}
	}

	return _tlsInteraction
}

// UserAgent: get the value used by session for the "User-Agent" header on new
// requests.
//
// The function returns the following values:
//
//   - utf8 (optional): user agent string.
//
func (session *Session) UserAgent() string {
	var _arg0 *C.SoupSession // out
	var _cret *C.char        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_user_agent(_arg0)
	runtime.KeepAlive(session)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// HasFeature tests if session has at a feature of type feature_type (which
// can be the type of either a sessionfeature, or else a subtype of some class
// managed by another feature, such as auth).
//
// The function takes the following parameters:
//
//   - featureType of the class of features to check for.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE.
//
func (session *Session) HasFeature(featureType coreglib.Type) bool {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_session_has_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PreconnectFinish: complete a preconnect async operation started with
// session.PreconnectAsync.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
func (session *Session) PreconnectFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.soup_session_preconnect_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveFeature removes feature's functionality from session.
//
// The function takes the following parameters:
//
//   - feature that has previously been added to session.
//
func (session *Session) RemoveFeature(feature SessionFeaturer) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupSessionFeature // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupSessionFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	C.soup_session_remove_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(feature)
}

// RemoveFeatureByType removes all features of type feature_type (or any
// subclass of feature_type) from session.
//
// The function takes the following parameters:
//
//   - featureType: #GType.
//
func (session *Session) RemoveFeatureByType(featureType coreglib.Type) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	C.soup_session_remove_feature_by_type(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)
}

// Send: synchronously sends msg and waits for the beginning of a response.
//
// On success, a gio.InputStream will be returned which you can use to read the
// response body. ("Success" here means only that an HTTP response was received
// and understood; it does not necessarily mean that a 2xx class status code was
// received.)
//
// If non-NULL, cancellable can be used to cancel the request; session.Send
// will return a G_IO_ERROR_CANCELLED error. Note that with requests that have
// side effects (eg, POST, PUT, DELETE) it is possible that you might cancel
// the request after the server acts on it, but before it returns a response,
// leaving the remote resource in an unknown state.
//
// If msg is requeued due to a redirect or authentication, the initial
// (3xx/401/407) response body will be suppressed, and session.Send will only
// return once a final response has been received.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - msg: Message.
//
// The function returns the following values:
//
//   - inputStream for reading the response body, or NULL on error.
//
func (session *Session) Send(ctx context.Context, msg *Message) (gio.InputStreamer, error) {
	var _arg0 *C.SoupSession  // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.SoupMessage  // out
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_send(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(msg)

	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.InputStreamer)
			return ok
		})
		rv, ok := casted.(gio.InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}

// SendAndRead: synchronously sends msg and reads the response body.
//
// On success, a glib.Bytes will be returned with the response body. This
// function should only be used when the resource to be retrieved is not too
// long and can be stored in memory.
//
// See session.Send for more details on the general semantics.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - msg: Message.
//
// The function returns the following values:
//
//   - bytes or NULL on error.
//
func (session *Session) SendAndRead(ctx context.Context, msg *Message) (*glib.Bytes, error) {
	var _arg0 *C.SoupSession  // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.SoupMessage  // out
	var _cret *C.GBytes       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_send_and_read(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(msg)

	var _bytes *glib.Bytes // out
	var _goerr error       // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// SendAndReadFinish gets the response to a session.SendAndReadAsync.
//
// If successful, returns a glib.Bytes with the response body.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - bytes or NULL on error.
//
func (session *Session) SendAndReadFinish(result gio.AsyncResulter) (*glib.Bytes, error) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GBytes       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_send_and_read_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _bytes *glib.Bytes // out
	var _goerr error       // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// SendAndSplice: synchronously sends msg and splices the response body stream
// into out_stream.
//
// See session.Send for more details on the general semantics.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - msg: Message.
//   - outStream: Stream.
//   - flags: set of StreamSpliceFlags.
//
// The function returns the following values:
//
//   - gssize containing the size of the data spliced, or -1 if an error
//     occurred.
//
func (session *Session) SendAndSplice(ctx context.Context, msg *Message, outStream gio.OutputStreamer, flags gio.OutputStreamSpliceFlags) (int, error) {
	var _arg0 *C.SoupSession             // out
	var _arg4 *C.GCancellable            // out
	var _arg1 *C.SoupMessage             // out
	var _arg2 *C.GOutputStream           // out
	var _arg3 C.GOutputStreamSpliceFlags // out
	var _cret C.gssize                   // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(outStream).Native()))
	_arg3 = C.GOutputStreamSpliceFlags(flags)

	_cret = C.soup_session_send_and_splice(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(outStream)
	runtime.KeepAlive(flags)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// SendAndSpliceFinish gets the response to a session.SendAndSpliceAsync.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - gssize containing the size of the data spliced, or -1 if an error
//     occurred.
//
func (session *Session) SendAndSpliceFinish(result gio.AsyncResulter) (int, error) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_send_and_splice_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// SendFinish gets the response to a session.SendAsync call.
//
// If successful returns a gio.InputStream that can be used to read the response
// body.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - inputStream for reading the response body, or NULL on error.
//
func (session *Session) SendFinish(result gio.AsyncResulter) (gio.InputStreamer, error) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_send_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.InputStreamer)
			return ok
		})
		rv, ok := casted.(gio.InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}

// SetAcceptLanguage: set the value to use for the "Accept-Language" header on
// messages sent from session.
//
// If accept_language is NULL then no "Accept-Language" will be included in
// requests. See session:accept-language for more information.
//
// The function takes the following parameters:
//
//   - acceptLanguage languages string.
//
func (session *Session) SetAcceptLanguage(acceptLanguage string) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.char        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(acceptLanguage)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_session_set_accept_language(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(acceptLanguage)
}

// SetAcceptLanguageAuto: set whether session will automatically set the
// "Accept-Language" header on requests using a value generated from system
// languages based on glib.GetLanguageNames().
//
// See session:accept-language-auto for more information.
//
// The function takes the following parameters:
//
//   - acceptLanguageAuto: value to set.
//
func (session *Session) SetAcceptLanguageAuto(acceptLanguageAuto bool) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	if acceptLanguageAuto {
		_arg1 = C.TRUE
	}

	C.soup_session_set_accept_language_auto(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(acceptLanguageAuto)
}

// SetIdleTimeout: set a timeout in seconds for idle connection lifetime to be
// used by session on new connections.
//
// See session:idle-timeout for more information.
//
// The function takes the following parameters:
//
//   - timeout in seconds.
//
func (session *Session) SetIdleTimeout(timeout uint) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.guint        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.guint(timeout)

	C.soup_session_set_idle_timeout(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(timeout)
}

// SetProxyResolver: set a gio.ProxyResolver to be used by session on new
// connections.
//
// If proxy_resolver is NULL then no proxies will be used. See
// session:proxy-resolver for more information.
//
// The function takes the following parameters:
//
//   - proxyResolver (optional) or NULL.
//
func (session *Session) SetProxyResolver(proxyResolver gio.ProxyResolverer) {
	var _arg0 *C.SoupSession    // out
	var _arg1 *C.GProxyResolver // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	if proxyResolver != nil {
		_arg1 = (*C.GProxyResolver)(unsafe.Pointer(coreglib.InternObject(proxyResolver).Native()))
	}

	C.soup_session_set_proxy_resolver(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(proxyResolver)
}

// SetTimeout: set a timeout in seconds for socket I/O operations to be used by
// session on new connections.
//
// See session:timeout for more information.
//
// The function takes the following parameters:
//
//   - timeout in seconds.
//
func (session *Session) SetTimeout(timeout uint) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.guint        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.guint(timeout)

	C.soup_session_set_timeout(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(timeout)
}

// SetTLSDatabase: set a gio.TLSDatabase to be used by session on new
// connections.
//
// If tls_database is NULL then certificate validation will always fail.
// See session:tls-database for more information.
//
// The function takes the following parameters:
//
//   - tlsDatabase (optional): Database.
//
func (session *Session) SetTLSDatabase(tlsDatabase gio.TLSDatabaser) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GTlsDatabase // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	if tlsDatabase != nil {
		_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(tlsDatabase).Native()))
	}

	C.soup_session_set_tls_database(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(tlsDatabase)
}

// SetTLSInteraction: set a gio.TLSInteraction to be used by session on new
// connections.
//
// If tls_interaction is NULL then client certificate validation will always
// fail.
//
// See session:tls-interaction for more information.
//
// The function takes the following parameters:
//
//   - tlsInteraction (optional): Interaction.
//
func (session *Session) SetTLSInteraction(tlsInteraction *gio.TLSInteraction) {
	var _arg0 *C.SoupSession     // out
	var _arg1 *C.GTlsInteraction // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	if tlsInteraction != nil {
		_arg1 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(tlsInteraction).Native()))
	}

	C.soup_session_set_tls_interaction(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(tlsInteraction)
}

// SetUserAgent: set the value to use for the "User-Agent" header on messages
// sent from session.
//
// If user_agent has trailing whitespace, session will append its own
// product token (eg, libsoup/3.0.0) to the end of the header for you.
// If user_agent is NULL then no "User-Agent" will be included in requests.
// See session:user-agent for more information.
//
// The function takes the following parameters:
//
//   - userAgent: user agent string.
//
func (session *Session) SetUserAgent(userAgent string) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.char        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(userAgent)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_session_set_user_agent(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(userAgent)
}

// WebsocketConnectFinish gets the websocketconnection response to a
// session.WebsocketConnectAsync call.
//
// If successful, returns a websocketconnection that can be used to communicate
// with the server.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - websocketConnection: new WebsocketConnection, or NULL on error.
//
func (session *Session) WebsocketConnectFinish(result gio.AsyncResulter) (*WebsocketConnection, error) {
	var _arg0 *C.SoupSession             // out
	var _arg1 *C.GAsyncResult            // out
	var _cret *C.SoupWebsocketConnection // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_websocket_connect_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _websocketConnection *WebsocketConnection // out
	var _goerr error                              // out

	_websocketConnection = wrapWebsocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _websocketConnection, _goerr
}

// The function takes the following parameters:
//
func (session *Session) requestQueued(msg *Message) {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.request_queued

	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Session_virtual_request_queued(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (session *Session) requestUnqueued(msg *Message) {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.request_unqueued

	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Session_virtual_request_unqueued(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
}

// SessionClass: instance of this type is always passed by reference.
type SessionClass struct {
	*sessionClass
}

// sessionClass is the struct that's finalized.
type sessionClass struct {
	native *C.SoupSessionClass
}
