// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern SoupCacheability _gotk4_soup3_CacheClass_get_cacheability(SoupCache*, SoupMessage*);
// SoupCacheability _gotk4_soup3_Cache_virtual_get_cacheability(void* fnptr, SoupCache* arg0, SoupMessage* arg1) {
//   return ((SoupCacheability (*)(SoupCache*, SoupMessage*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeCacheType    = coreglib.Type(C.soup_cache_type_get_type())
	GTypeCacheability = coreglib.Type(C.soup_cacheability_get_type())
	GTypeCache        = coreglib.Type(C.soup_cache_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCacheType, F: marshalCacheType},
		coreglib.TypeMarshaler{T: GTypeCacheability, F: marshalCacheability},
		coreglib.TypeMarshaler{T: GTypeCache, F: marshalCache},
	})
}

// CacheType: type of cache; this affects what kinds of responses will be saved.
type CacheType C.gint

const (
	// CacheSingleUser: single-user cache.
	CacheSingleUser CacheType = iota
	// CacheShared: shared cache.
	CacheShared
)

func marshalCacheType(p uintptr) (interface{}, error) {
	return CacheType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CacheType.
func (c CacheType) String() string {
	switch c {
	case CacheSingleUser:
		return "SingleUser"
	case CacheShared:
		return "Shared"
	default:
		return fmt.Sprintf("CacheType(%d)", c)
	}
}

// Cacheability indicates if a message should or shouldn't be cached.
type Cacheability C.guint

const (
	// CacheCacheable: message should be cached.
	CacheCacheable Cacheability = 0b1
	// CacheUncacheable: message shouldn't be cached.
	CacheUncacheable Cacheability = 0b10
	// CacheInvalidates messages cache should be invalidated.
	CacheInvalidates Cacheability = 0b100
	// CacheValidates messages cache should be updated.
	CacheValidates Cacheability = 0b1000
)

func marshalCacheability(p uintptr) (interface{}, error) {
	return Cacheability(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for Cacheability.
func (c Cacheability) String() string {
	if c == 0 {
		return "Cacheability(0)"
	}

	var builder strings.Builder
	builder.Grow(63)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case CacheCacheable:
			builder.WriteString("Cacheable|")
		case CacheUncacheable:
			builder.WriteString("Uncacheable|")
		case CacheInvalidates:
			builder.WriteString("Invalidates|")
		case CacheValidates:
			builder.WriteString("Validates|")
		default:
			builder.WriteString(fmt.Sprintf("Cacheability(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c Cacheability) Has(other Cacheability) bool {
	return (c & other) == other
}

// CacheOverrides contains methods that are overridable.
type CacheOverrides struct {
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Cacheability func(msg *Message) Cacheability
}

func defaultCacheOverrides(v *Cache) CacheOverrides {
	return CacheOverrides{
		Cacheability: v.cacheability,
	}
}

// Cache: file-based cache for HTTP resources.
type Cache struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SessionFeature
}

var (
	_ coreglib.Objector = (*Cache)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Cache, *CacheClass, CacheOverrides](
		GTypeCache,
		initCacheClass,
		wrapCache,
		defaultCacheOverrides,
	)
}

func initCacheClass(gclass unsafe.Pointer, overrides CacheOverrides, classInitFunc func(*CacheClass)) {
	pclass := (*C.SoupCacheClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeCache))))

	if overrides.Cacheability != nil {
		pclass.get_cacheability = (*[0]byte)(C._gotk4_soup3_CacheClass_get_cacheability)
	}

	if classInitFunc != nil {
		class := (*CacheClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCache(obj *coreglib.Object) *Cache {
	return &Cache{
		Object: obj,
		SessionFeature: SessionFeature{
			Object: obj,
		},
	}
}

func marshalCache(p uintptr) (interface{}, error) {
	return wrapCache(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCache creates a new Cache.
//
// The function takes the following parameters:
//
//   - cacheDir (optional): directory to store the cached data, or NULL to
//     use the default one. Note that since the cache isn't safe to access for
//     multiple processes at once, and the default directory isn't namespaced by
//     process, clients are strongly discouraged from passing NULL.
//   - cacheType of the cache.
//
// The function returns the following values:
//
//   - cache: new Cache.
//
func NewCache(cacheDir string, cacheType CacheType) *Cache {
	var _arg1 *C.char         // out
	var _arg2 C.SoupCacheType // out
	var _cret *C.SoupCache    // in

	if cacheDir != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(cacheDir)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.SoupCacheType(cacheType)

	_cret = C.soup_cache_new(_arg1, _arg2)
	runtime.KeepAlive(cacheDir)
	runtime.KeepAlive(cacheType)

	var _cache *Cache // out

	_cache = wrapCache(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cache
}

// Clear will remove all entries in the cache plus all the cache files.
//
// This is not thread safe and must be called only from the thread that created
// the Cache.
func (cache *Cache) Clear() {
	var _arg0 *C.SoupCache // out

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))

	C.soup_cache_clear(_arg0)
	runtime.KeepAlive(cache)
}

// Dump: synchronously writes the cache index out to disk.
//
// Contrast with cache.Flush, which writes pending cache *entries* to disk.
//
// You must call this before exiting if you want your cache data to persist
// between sessions.
//
// This is not thread safe and must be called only from the thread that created
// the Cache.
func (cache *Cache) Dump() {
	var _arg0 *C.SoupCache // out

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))

	C.soup_cache_dump(_arg0)
	runtime.KeepAlive(cache)
}

// Flush forces all pending writes in the cache to be committed to disk.
//
// For doing so it will iterate the glib.MainContext associated with cache's
// session as long as needed.
//
// Contrast with cache.Dump, which writes out the cache index file.
func (cache *Cache) Flush() {
	var _arg0 *C.SoupCache // out

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))

	C.soup_cache_flush(_arg0)
	runtime.KeepAlive(cache)
}

// MaxSize gets the maximum size of the cache.
//
// The function returns the following values:
//
//   - guint: maximum size of the cache, in bytes.
//
func (cache *Cache) MaxSize() uint {
	var _arg0 *C.SoupCache // out
	var _cret C.guint      // in

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))

	_cret = C.soup_cache_get_max_size(_arg0)
	runtime.KeepAlive(cache)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Load loads the contents of cache's index into memory.
//
// This is not thread safe and must be called only from the thread that created
// the Cache.
func (cache *Cache) Load() {
	var _arg0 *C.SoupCache // out

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))

	C.soup_cache_load(_arg0)
	runtime.KeepAlive(cache)
}

// SetMaxSize sets the maximum size of the cache.
//
// The function takes the following parameters:
//
//   - maxSize: maximum size of the cache, in bytes.
//
func (cache *Cache) SetMaxSize(maxSize uint) {
	var _arg0 *C.SoupCache // out
	var _arg1 C.guint      // out

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))
	_arg1 = C.guint(maxSize)

	C.soup_cache_set_max_size(_arg0, _arg1)
	runtime.KeepAlive(cache)
	runtime.KeepAlive(maxSize)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (cache *Cache) cacheability(msg *Message) Cacheability {
	gclass := (*C.SoupCacheClass)(coreglib.PeekParentClass(cache))
	fnarg := gclass.get_cacheability

	var _arg0 *C.SoupCache       // out
	var _arg1 *C.SoupMessage     // out
	var _cret C.SoupCacheability // in

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C._gotk4_soup3_Cache_virtual_get_cacheability(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(cache)
	runtime.KeepAlive(msg)

	var _cacheability Cacheability // out

	_cacheability = Cacheability(_cret)

	return _cacheability
}

// CacheClass: instance of this type is always passed by reference.
type CacheClass struct {
	*cacheClass
}

// cacheClass is the struct that's finalized.
type cacheClass struct {
	native *C.SoupCacheClass
}

func (c *CacheClass) Padding() [4]unsafe.Pointer {
	valptr := &c.native.padding
	var _v [4]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}
