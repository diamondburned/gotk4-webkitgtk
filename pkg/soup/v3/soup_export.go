// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <libsoup/soup.h>
import "C"

//export _gotk4_soup3_AuthClass_authenticate
func _gotk4_soup3_AuthClass_authenticate(arg0 *C.SoupAuth, arg1 *C.char, arg2 *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.Authenticate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.Authenticate, got none")
	}

	var _username string // out
	var _password string // out

	_username = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_password = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.Authenticate(_username, _password)
}

//export _gotk4_soup3_AuthClass_can_authenticate
func _gotk4_soup3_AuthClass_can_authenticate(arg0 *C.SoupAuth) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.CanAuthenticate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.CanAuthenticate, got none")
	}

	ok := overrides.CanAuthenticate()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup3_AuthClass_get_authorization
func _gotk4_soup3_AuthClass_get_authorization(arg0 *C.SoupAuth, arg1 *C.SoupMessage) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.Authorization == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.Authorization, got none")
	}

	var _msg *Message // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	utf8 := overrides.Authorization(_msg)

	var _ string

	cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_soup3_AuthClass_get_protection_space
func _gotk4_soup3_AuthClass_get_protection_space(arg0 *C.SoupAuth, arg1 *C.GUri) (cret *C.GSList) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.ProtectionSpace == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.ProtectionSpace, got none")
	}

	var _sourceUri *glib.URI // out

	_sourceUri = (*glib.URI)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	sList := overrides.ProtectionSpace(_sourceUri)

	var _ []string

	for i := len(sList) - 1; i >= 0; i-- {
		src := sList[i]
		var dst *C.gchar // out
		dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
		cret = C.g_slist_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}

	return cret
}

//export _gotk4_soup3_AuthClass_is_authenticated
func _gotk4_soup3_AuthClass_is_authenticated(arg0 *C.SoupAuth) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.IsAuthenticated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.IsAuthenticated, got none")
	}

	ok := overrides.IsAuthenticated()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup3_AuthClass_is_ready
func _gotk4_soup3_AuthClass_is_ready(arg0 *C.SoupAuth, arg1 *C.SoupMessage) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.IsReady == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.IsReady, got none")
	}

	var _msg *Message // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	ok := overrides.IsReady(_msg)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup3_AuthClass_update
func _gotk4_soup3_AuthClass_update(arg0 *C.SoupAuth, arg1 *C.SoupMessage, arg2 *C.GHashTable) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.Update == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.Update, got none")
	}

	var _msg *Message                                 // out
	var _authHeader map[unsafe.Pointer]unsafe.Pointer // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_authHeader = make(map[unsafe.Pointer]unsafe.Pointer, gextras.HashTableSize(unsafe.Pointer(arg2)))
	gextras.MoveHashTable(unsafe.Pointer(arg2), false, func(k, v unsafe.Pointer) {
		ksrc := *(**C.gpointer)(k)
		vsrc := *(**C.gpointer)(v)
		var kdst unsafe.Pointer // out
		var vdst unsafe.Pointer // out
		kdst = (unsafe.Pointer)(unsafe.Pointer(ksrc))
		vdst = (unsafe.Pointer)(unsafe.Pointer(vsrc))
		_authHeader[kdst] = vdst
	})

	ok := overrides.Update(_msg, _authHeader)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup3_AuthDomainClass_accepts
func _gotk4_soup3_AuthDomainClass_accepts(arg0 *C.SoupAuthDomain, arg1 *C.SoupServerMessage, arg2 *C.char) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthDomainOverrides](instance0)
	if overrides.Accepts == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthDomainOverrides.Accepts, got none")
	}

	var _msg *ServerMessage // out
	var _header string      // out

	_msg = wrapServerMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_header = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	utf8 := overrides.Accepts(_msg, _header)

	var _ string

	cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_soup3_AuthDomainClass_challenge
func _gotk4_soup3_AuthDomainClass_challenge(arg0 *C.SoupAuthDomain, arg1 *C.SoupServerMessage) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthDomainOverrides](instance0)
	if overrides.Challenge == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthDomainOverrides.Challenge, got none")
	}

	var _msg *ServerMessage // out

	_msg = wrapServerMessage(coreglib.Take(unsafe.Pointer(arg1)))

	utf8 := overrides.Challenge(_msg)

	var _ string

	cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_soup3_AuthDomainClass_check_password
func _gotk4_soup3_AuthDomainClass_check_password(arg0 *C.SoupAuthDomain, arg1 *C.SoupServerMessage, arg2 *C.char, arg3 *C.char) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthDomainOverrides](instance0)
	if overrides.CheckPassword == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthDomainOverrides.CheckPassword, got none")
	}

	var _msg *ServerMessage // out
	var _username string    // out
	var _password string    // out

	_msg = wrapServerMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_username = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_password = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	ok := overrides.CheckPassword(_msg, _username, _password)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup3_CacheClass_get_cacheability
func _gotk4_soup3_CacheClass_get_cacheability(arg0 *C.SoupCache, arg1 *C.SoupMessage) (cret C.SoupCacheability) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CacheOverrides](instance0)
	if overrides.Cacheability == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CacheOverrides.Cacheability, got none")
	}

	var _msg *Message // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	cacheability := overrides.Cacheability(_msg)

	var _ Cacheability

	cret = C.SoupCacheability(cacheability)

	return cret
}

//export _gotk4_soup3_CookieJarClass_changed
func _gotk4_soup3_CookieJarClass_changed(arg0 *C.SoupCookieJar, arg1 *C.SoupCookie, arg2 *C.SoupCookie) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CookieJarOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CookieJarOverrides.Changed, got none")
	}

	var _oldCookie *Cookie // out
	var _newCookie *Cookie // out

	_oldCookie = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_newCookie = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.Changed(_oldCookie, _newCookie)
}

//export _gotk4_soup3_CookieJarClass_is_persistent
func _gotk4_soup3_CookieJarClass_is_persistent(arg0 *C.SoupCookieJar) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CookieJarOverrides](instance0)
	if overrides.IsPersistent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CookieJarOverrides.IsPersistent, got none")
	}

	ok := overrides.IsPersistent()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup3_CookieJarClass_save
func _gotk4_soup3_CookieJarClass_save(arg0 *C.SoupCookieJar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CookieJarOverrides](instance0)
	if overrides.Save == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CookieJarOverrides.Save, got none")
	}

	overrides.Save()
}

//export _gotk4_soup3_HSTSEnforcerClass_changed
func _gotk4_soup3_HSTSEnforcerClass_changed(arg0 *C.SoupHSTSEnforcer, arg1 *C.SoupHSTSPolicy, arg2 *C.SoupHSTSPolicy) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HSTSEnforcerOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HSTSEnforcerOverrides.Changed, got none")
	}

	var _oldPolicy *HSTSPolicy // out
	var _newPolicy *HSTSPolicy // out

	_oldPolicy = (*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_newPolicy = (*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.Changed(_oldPolicy, _newPolicy)
}

//export _gotk4_soup3_HSTSEnforcerClass_has_valid_policy
func _gotk4_soup3_HSTSEnforcerClass_has_valid_policy(arg0 *C.SoupHSTSEnforcer, arg1 *C.char) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HSTSEnforcerOverrides](instance0)
	if overrides.HasValidPolicy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HSTSEnforcerOverrides.HasValidPolicy, got none")
	}

	var _domain string // out

	_domain = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := overrides.HasValidPolicy(_domain)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup3_HSTSEnforcerClass_is_persistent
func _gotk4_soup3_HSTSEnforcerClass_is_persistent(arg0 *C.SoupHSTSEnforcer) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HSTSEnforcerOverrides](instance0)
	if overrides.IsPersistent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HSTSEnforcerOverrides.IsPersistent, got none")
	}

	ok := overrides.IsPersistent()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup3_ServerClass_request_aborted
func _gotk4_soup3_ServerClass_request_aborted(arg0 *C.SoupServer, arg1 *C.SoupServerMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ServerOverrides](instance0)
	if overrides.RequestAborted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ServerOverrides.RequestAborted, got none")
	}

	var _msg *ServerMessage // out

	_msg = wrapServerMessage(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.RequestAborted(_msg)
}

//export _gotk4_soup3_ServerClass_request_finished
func _gotk4_soup3_ServerClass_request_finished(arg0 *C.SoupServer, arg1 *C.SoupServerMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ServerOverrides](instance0)
	if overrides.RequestFinished == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ServerOverrides.RequestFinished, got none")
	}

	var _msg *ServerMessage // out

	_msg = wrapServerMessage(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.RequestFinished(_msg)
}

//export _gotk4_soup3_ServerClass_request_read
func _gotk4_soup3_ServerClass_request_read(arg0 *C.SoupServer, arg1 *C.SoupServerMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ServerOverrides](instance0)
	if overrides.RequestRead == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ServerOverrides.RequestRead, got none")
	}

	var _msg *ServerMessage // out

	_msg = wrapServerMessage(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.RequestRead(_msg)
}

//export _gotk4_soup3_ServerClass_request_started
func _gotk4_soup3_ServerClass_request_started(arg0 *C.SoupServer, arg1 *C.SoupServerMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ServerOverrides](instance0)
	if overrides.RequestStarted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ServerOverrides.RequestStarted, got none")
	}

	var _msg *ServerMessage // out

	_msg = wrapServerMessage(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.RequestStarted(_msg)
}

//export _gotk4_soup3_SessionClass_request_queued
func _gotk4_soup3_SessionClass_request_queued(arg0 *C.SoupSession, arg1 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SessionOverrides](instance0)
	if overrides.RequestQueued == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SessionOverrides.RequestQueued, got none")
	}

	var _msg *Message // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.RequestQueued(_msg)
}

//export _gotk4_soup3_SessionClass_request_unqueued
func _gotk4_soup3_SessionClass_request_unqueued(arg0 *C.SoupSession, arg1 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SessionOverrides](instance0)
	if overrides.RequestUnqueued == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SessionOverrides.RequestUnqueued, got none")
	}

	var _msg *Message // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.RequestUnqueued(_msg)
}

//export _gotk4_soup3_WebsocketExtensionClass_configure
func _gotk4_soup3_WebsocketExtensionClass_configure(arg0 *C.SoupWebsocketExtension, arg1 C.SoupWebsocketConnectionType, arg2 *C.GHashTable, _cerr **C.GError) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebsocketExtensionOverrides](instance0)
	if overrides.Configure == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebsocketExtensionOverrides.Configure, got none")
	}

	var _connectionType WebsocketConnectionType   // out
	var _params map[unsafe.Pointer]unsafe.Pointer // out

	_connectionType = WebsocketConnectionType(arg1)
	if arg2 != nil {
		_params = make(map[unsafe.Pointer]unsafe.Pointer, gextras.HashTableSize(unsafe.Pointer(arg2)))
		gextras.MoveHashTable(unsafe.Pointer(arg2), false, func(k, v unsafe.Pointer) {
			ksrc := *(**C.gpointer)(k)
			vsrc := *(**C.gpointer)(v)
			var kdst unsafe.Pointer // out
			var vdst unsafe.Pointer // out
			kdst = (unsafe.Pointer)(unsafe.Pointer(ksrc))
			vdst = (unsafe.Pointer)(unsafe.Pointer(vsrc))
			_params[kdst] = vdst
		})
	}

	_goerr := overrides.Configure(_connectionType, _params)

	var _ error

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_soup3_WebsocketExtensionClass_get_request_params
func _gotk4_soup3_WebsocketExtensionClass_get_request_params(arg0 *C.SoupWebsocketExtension) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebsocketExtensionOverrides](instance0)
	if overrides.RequestParams == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebsocketExtensionOverrides.RequestParams, got none")
	}

	utf8 := overrides.RequestParams()

	var _ string

	if utf8 != "" {
		cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
	}

	return cret
}

//export _gotk4_soup3_WebsocketExtensionClass_get_response_params
func _gotk4_soup3_WebsocketExtensionClass_get_response_params(arg0 *C.SoupWebsocketExtension) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebsocketExtensionOverrides](instance0)
	if overrides.ResponseParams == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebsocketExtensionOverrides.ResponseParams, got none")
	}

	utf8 := overrides.ResponseParams()

	var _ string

	if utf8 != "" {
		cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
	}

	return cret
}
