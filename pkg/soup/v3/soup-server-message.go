// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void _gotk4_soup3_ServerMessage_ConnectWroteInformational(gpointer, guintptr);
// extern void _gotk4_soup3_ServerMessage_ConnectWroteHeaders(gpointer, guintptr);
// extern void _gotk4_soup3_ServerMessage_ConnectWroteChunk(gpointer, guintptr);
// extern void _gotk4_soup3_ServerMessage_ConnectWroteBodyData(gpointer, guint, guintptr);
// extern void _gotk4_soup3_ServerMessage_ConnectWroteBody(gpointer, guintptr);
// extern void _gotk4_soup3_ServerMessage_ConnectGotHeaders(gpointer, guintptr);
// extern void _gotk4_soup3_ServerMessage_ConnectGotChunk(gpointer, GBytes*, guintptr);
// extern void _gotk4_soup3_ServerMessage_ConnectGotBody(gpointer, guintptr);
// extern void _gotk4_soup3_ServerMessage_ConnectFinished(gpointer, guintptr);
// extern void _gotk4_soup3_ServerMessage_ConnectDisconnected(gpointer, guintptr);
// extern void _gotk4_soup3_ServerMessage_ConnectConnected(gpointer, guintptr);
// extern gboolean _gotk4_soup3_ServerMessage_ConnectAcceptCertificate(gpointer, GTlsCertificate*, GTlsCertificateFlags, guintptr);
import "C"

// GType values.
var (
	GTypeServerMessage = coreglib.Type(C.soup_server_message_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeServerMessage, F: marshalServerMessage},
	})
}

// ServerMessageOverrides contains methods that are overridable.
type ServerMessageOverrides struct {
}

func defaultServerMessageOverrides(v *ServerMessage) ServerMessageOverrides {
	return ServerMessageOverrides{}
}

// ServerMessage: HTTP server request and response pair.
//
// A SoupServerMessage represents an HTTP message that is being sent or received
// on a server.
//
// server will create SoupServerMessages automatically for incoming requests,
// which your application will receive via handlers.
//
// Note that libsoup's terminology here does not quite match the HTTP
// specification: in RFC 2616, an "HTTP-message" is *either* a Request,
// *or* a Response. In libsoup, a ServerMessage combines both the request and
// the response.
type ServerMessage struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ServerMessage)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ServerMessage, *ServerMessageClass, ServerMessageOverrides](
		GTypeServerMessage,
		initServerMessageClass,
		wrapServerMessage,
		defaultServerMessageOverrides,
	)
}

func initServerMessageClass(gclass unsafe.Pointer, overrides ServerMessageOverrides, classInitFunc func(*ServerMessageClass)) {
	if classInitFunc != nil {
		class := (*ServerMessageClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapServerMessage(obj *coreglib.Object) *ServerMessage {
	return &ServerMessage{
		Object: obj,
	}
}

func marshalServerMessage(p uintptr) (interface{}, error) {
	return wrapServerMessage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAcceptCertificate is emitted during the msg's connection TLS handshake
// after client TLS certificate has been received. You can return TRUE to accept
// tls_certificate despite tls_errors.
func (msg *ServerMessage) ConnectAcceptCertificate(f func(tlsPeerCertificate gio.TLSCertificater, tlsPeerErrors gio.TLSCertificateFlags) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "accept-certificate", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectAcceptCertificate), f)
}

// ConnectConnected is emitted when the msg's socket is connected and the TLS
// handshake completed.
func (msg *ServerMessage) ConnectConnected(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "connected", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectConnected), f)
}

// ConnectDisconnected is emitted when the msg's socket is disconnected.
func (msg *ServerMessage) ConnectDisconnected(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "disconnected", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectDisconnected), f)
}

// ConnectFinished is emitted when all HTTP processing is finished for a
// message. (After servermessage::wrote-body).
func (msg *ServerMessage) ConnectFinished(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "finished", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectFinished), f)
}

// ConnectGotBody is emitted after receiving the complete request body.
func (msg *ServerMessage) ConnectGotBody(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "got-body", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectGotBody), f)
}

// ConnectGotChunk is emitted after receiving a chunk of a message body.
//
// Note that "chunk" in this context means any subpiece of the body, not
// necessarily the specific HTTP 1.1 chunks sent by the other side.
func (msg *ServerMessage) ConnectGotChunk(f func(chunk *glib.Bytes)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "got-chunk", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectGotChunk), f)
}

// ConnectGotHeaders is emitted after receiving the Request-Line and request
// headers.
func (msg *ServerMessage) ConnectGotHeaders(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "got-headers", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectGotHeaders), f)
}

// ConnectWroteBody is emitted immediately after writing the complete response
// body for a message.
func (msg *ServerMessage) ConnectWroteBody(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-body", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectWroteBody), f)
}

// ConnectWroteBodyData is emitted immediately after writing a portion of the
// message body to the network.
func (msg *ServerMessage) ConnectWroteBodyData(f func(chunkSize uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-body-data", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectWroteBodyData), f)
}

// ConnectWroteChunk is emitted immediately after writing a body chunk for a
// message.
//
// Note that this signal is not parallel to servermessage::got-chunk;
// it is emitted only when a complete chunk (added with messagebody.Append
// or messagebody.AppendBytes has been written. To get more useful continuous
// progress information, use servermessage::wrote-body-data.
func (msg *ServerMessage) ConnectWroteChunk(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-chunk", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectWroteChunk), f)
}

// ConnectWroteHeaders is emitted immediately after writing the response headers
// for a message.
func (msg *ServerMessage) ConnectWroteHeaders(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-headers", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectWroteHeaders), f)
}

// ConnectWroteInformational is emitted immediately after writing a 1xx
// (Informational) response.
func (msg *ServerMessage) ConnectWroteInformational(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-informational", false, unsafe.Pointer(C._gotk4_soup3_ServerMessage_ConnectWroteInformational), f)
}

// HTTPVersion: get the HTTP version of msg.
//
// The function returns the following values:
//
//   - httpVersion: HTTPVersion.
//
func (msg *ServerMessage) HTTPVersion() HTTPVersion {
	var _arg0 *C.SoupServerMessage // out
	var _cret C.SoupHTTPVersion    // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_http_version(_arg0)
	runtime.KeepAlive(msg)

	var _httpVersion HTTPVersion // out

	_httpVersion = HTTPVersion(_cret)

	return _httpVersion
}

// LocalAddress retrieves the gio.SocketAddress associated with the local end of
// a connection.
//
// The function returns the following values:
//
//   - socketAddress (optional): Address associated with the local end of a
//     connection, it may be NULL if you used server.AcceptIostream.
//
func (msg *ServerMessage) LocalAddress() gio.SocketAddresser {
	var _arg0 *C.SoupServerMessage // out
	var _cret *C.GSocketAddress    // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_local_address(_arg0)
	runtime.KeepAlive(msg)

	var _socketAddress gio.SocketAddresser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.SocketAddresser)
				return ok
			})
			rv, ok := casted.(gio.SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}

	return _socketAddress
}

// Method: get the HTTP method of msg.
//
// The function returns the following values:
//
//   - utf8: HTTP method.
//
func (msg *ServerMessage) Method() string {
	var _arg0 *C.SoupServerMessage // out
	var _cret *C.char              // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_method(_arg0)
	runtime.KeepAlive(msg)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ReasonPhrase: get the HTTP reason phrase of msg.
//
// The function returns the following values:
//
//   - utf8 (optional): reason phrase.
//
func (msg *ServerMessage) ReasonPhrase() string {
	var _arg0 *C.SoupServerMessage // out
	var _cret *C.char              // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_reason_phrase(_arg0)
	runtime.KeepAlive(msg)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// RemoteAddress retrieves the gio.SocketAddress associated with the remote end
// of a connection.
//
// The function returns the following values:
//
//   - socketAddress (optional): Address associated with the remote end of a
//     connection, it may be NULL if you used server.AcceptIostream.
//
func (msg *ServerMessage) RemoteAddress() gio.SocketAddresser {
	var _arg0 *C.SoupServerMessage // out
	var _cret *C.GSocketAddress    // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_remote_address(_arg0)
	runtime.KeepAlive(msg)

	var _socketAddress gio.SocketAddresser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.SocketAddresser)
				return ok
			})
			rv, ok := casted.(gio.SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}

	return _socketAddress
}

// RemoteHost retrieves the IP address associated with the remote end of a
// connection.
//
// The function returns the following values:
//
//   - utf8 (optional): IP address associated with the remote end of a
//     connection, it may be NULL if you used server.AcceptIostream.
//
func (msg *ServerMessage) RemoteHost() string {
	var _arg0 *C.SoupServerMessage // out
	var _cret *C.char              // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_remote_host(_arg0)
	runtime.KeepAlive(msg)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// RequestBody: get the request body of msg.
//
// The function returns the following values:
//
//   - messageBody: MessageBody.
//
func (msg *ServerMessage) RequestBody() *MessageBody {
	var _arg0 *C.SoupServerMessage // out
	var _cret *C.SoupMessageBody   // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_request_body(_arg0)
	runtime.KeepAlive(msg)

	var _messageBody *MessageBody // out

	_messageBody = (*MessageBody)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.soup_message_body_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_messageBody)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_message_body_unref((*C.SoupMessageBody)(intern.C))
		},
	)

	return _messageBody
}

// RequestHeaders: get the request headers of msg.
//
// The function returns the following values:
//
//   - messageHeaders with the request headers.
//
func (msg *ServerMessage) RequestHeaders() *MessageHeaders {
	var _arg0 *C.SoupServerMessage  // out
	var _cret *C.SoupMessageHeaders // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_request_headers(_arg0)
	runtime.KeepAlive(msg)

	var _messageHeaders *MessageHeaders // out

	_messageHeaders = (*MessageHeaders)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.soup_message_headers_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_messageHeaders)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_message_headers_unref((*C.SoupMessageHeaders)(intern.C))
		},
	)

	return _messageHeaders
}

// ResponseBody: get the response body of msg.
//
// The function returns the following values:
//
//   - messageBody: MessageBody.
//
func (msg *ServerMessage) ResponseBody() *MessageBody {
	var _arg0 *C.SoupServerMessage // out
	var _cret *C.SoupMessageBody   // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_response_body(_arg0)
	runtime.KeepAlive(msg)

	var _messageBody *MessageBody // out

	_messageBody = (*MessageBody)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.soup_message_body_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_messageBody)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_message_body_unref((*C.SoupMessageBody)(intern.C))
		},
	)

	return _messageBody
}

// ResponseHeaders: get the response headers of msg.
//
// The function returns the following values:
//
//   - messageHeaders with the response headers.
//
func (msg *ServerMessage) ResponseHeaders() *MessageHeaders {
	var _arg0 *C.SoupServerMessage  // out
	var _cret *C.SoupMessageHeaders // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_response_headers(_arg0)
	runtime.KeepAlive(msg)

	var _messageHeaders *MessageHeaders // out

	_messageHeaders = (*MessageHeaders)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.soup_message_headers_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_messageHeaders)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_message_headers_unref((*C.SoupMessageHeaders)(intern.C))
		},
	)

	return _messageHeaders
}

// Socket retrieves the gio.Socket that msg is associated with.
//
// If you are using this method to observe when multiple requests are made on
// the same persistent HTTP connection (eg, as the ntlm-test test program does),
// you will need to pay attention to socket destruction as well (eg, by using
// weak references), so that you do not get fooled when the allocator reuses the
// memory address of a previously-destroyed socket to represent a new socket.
//
// The function returns the following values:
//
//   - socket (optional) that msg is associated with, NULL if you used
//     server.AcceptIostream.
//
func (msg *ServerMessage) Socket() *gio.Socket {
	var _arg0 *C.SoupServerMessage // out
	var _cret *C.GSocket           // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_socket(_arg0)
	runtime.KeepAlive(msg)

	var _socket *gio.Socket // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_socket = &gio.Socket{
				Object: obj,
				DatagramBased: gio.DatagramBased{
					Object: obj,
				},
				Initable: gio.Initable{
					Object: obj,
				},
			}
		}
	}

	return _socket
}

// Status: get the HTTP status code of msg.
//
// The function returns the following values:
//
//   - guint: HTTP status code.
//
func (msg *ServerMessage) Status() uint {
	var _arg0 *C.SoupServerMessage // out
	var _cret C.guint              // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_status(_arg0)
	runtime.KeepAlive(msg)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TLSPeerCertificate gets the peer's Certificate associated with msg's
// connection. Note that this is not set yet during the emission of
// SoupServerMessage::accept-certificate signal.
//
// The function returns the following values:
//
//   - tlsCertificate (optional) msg's TLS peer certificate, or NULL if msg's
//     connection is not SSL.
//
func (msg *ServerMessage) TLSPeerCertificate() gio.TLSCertificater {
	var _arg0 *C.SoupServerMessage // out
	var _cret *C.GTlsCertificate   // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_tls_peer_certificate(_arg0)
	runtime.KeepAlive(msg)

	var _tlsCertificate gio.TLSCertificater // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.TLSCertificater)
				return ok
			})
			rv, ok := casted.(gio.TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			_tlsCertificate = rv
		}
	}

	return _tlsCertificate
}

// TLSPeerCertificateErrors gets the errors associated with validating msg's
// TLS peer certificate. Note that this is not set yet during the emission of
// SoupServerMessage::accept-certificate signal.
//
// The function returns the following values:
//
//   - tlsCertificateFlags with msg's TLS peer certificate errors.
//
func (msg *ServerMessage) TLSPeerCertificateErrors() gio.TLSCertificateFlags {
	var _arg0 *C.SoupServerMessage   // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_tls_peer_certificate_errors(_arg0)
	runtime.KeepAlive(msg)

	var _tlsCertificateFlags gio.TLSCertificateFlags // out

	_tlsCertificateFlags = gio.TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

// URI: get msg's URI.
//
// The function returns the following values:
//
//   - uri: #GUri.
//
func (msg *ServerMessage) URI() *glib.URI {
	var _arg0 *C.SoupServerMessage // out
	var _cret *C.GUri              // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_get_uri(_arg0)
	runtime.KeepAlive(msg)

	var _uri *glib.URI // out

	_uri = (*glib.URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _uri
}

// IsOptionsPing gets if msg represents an OPTIONS message with the path *.
//
// The function returns the following values:
//
//   - ok: TRUE if is an OPTIONS ping.
//
func (msg *ServerMessage) IsOptionsPing() bool {
	var _arg0 *C.SoupServerMessage // out
	var _cret C.gboolean           // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_is_options_ping(_arg0)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pause pauses I/O on msg.
//
// This can be used when you need to return from the server handler without
// having the full response ready yet. Use servermessage.Unpause to resume I/O.
func (msg *ServerMessage) Pause() {
	var _arg0 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_server_message_pause(_arg0)
	runtime.KeepAlive(msg)
}

// SetHTTPVersion: set the HTTP version of msg.
//
// The function takes the following parameters:
//
//   - version: HTTPVersion.
//
func (msg *ServerMessage) SetHTTPVersion(version HTTPVersion) {
	var _arg0 *C.SoupServerMessage // out
	var _arg1 C.SoupHTTPVersion    // out

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.SoupHTTPVersion(version)

	C.soup_server_message_set_http_version(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(version)
}

// SetRedirect sets msg's status_code to status_code and adds a Location header
// pointing to redirect_uri. Use this from a server when you want to redirect
// the client to another URI.
//
// redirect_uri can be a relative URI, in which case it is interpreted relative
// to msg's current URI. In particular, if redirect_uri is just a path, it will
// replace the path *and query* of msg's URI.
//
// The function takes the following parameters:
//
//   - statusCode: 3xx status code.
//   - redirectUri: URI to redirect msg to.
//
func (msg *ServerMessage) SetRedirect(statusCode uint, redirectUri string) {
	var _arg0 *C.SoupServerMessage // out
	var _arg1 C.guint              // out
	var _arg2 *C.char              // out

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.guint(statusCode)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(redirectUri)))
	defer C.free(unsafe.Pointer(_arg2))

	C.soup_server_message_set_redirect(_arg0, _arg1, _arg2)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(statusCode)
	runtime.KeepAlive(redirectUri)
}

// SetResponse: convenience function to set the response body of a
// ServerMessage. If content_type is NULL, the response body must be empty as
// well.
//
// The function takes the following parameters:
//
//   - contentType (optional): MIME Content-Type of the body.
//   - respUse describing how to handle resp_body.
//   - respBody (optional): a data buffer containing the body of the message
//     response.
//
func (msg *ServerMessage) SetResponse(contentType string, respUse MemoryUse, respBody string) {
	var _arg0 *C.SoupServerMessage // out
	var _arg1 *C.char              // out
	var _arg2 C.SoupMemoryUse      // out
	var _arg3 *C.char              // out
	var _arg4 C.gsize

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if contentType != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.SoupMemoryUse(respUse)
	_arg4 = (C.gsize)(len(respBody))
	_arg3 = (*C.char)(C.calloc(C.size_t((len(respBody) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg3)), len(respBody)), respBody)
	defer C.free(unsafe.Pointer(_arg3))

	C.soup_server_message_set_response(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(respUse)
	runtime.KeepAlive(respBody)
}

// SetStatus sets msg's status code to status_code.
//
// If status_code is a known value and reason_phrase is NULL, the reason_phrase
// will be set automatically.
//
// The function takes the following parameters:
//
//   - statusCode: HTTP status code.
//   - reasonPhrase (optional): reason phrase.
//
func (msg *ServerMessage) SetStatus(statusCode uint, reasonPhrase string) {
	var _arg0 *C.SoupServerMessage // out
	var _arg1 C.guint              // out
	var _arg2 *C.char              // out

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.guint(statusCode)
	if reasonPhrase != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(reasonPhrase)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.soup_server_message_set_status(_arg0, _arg1, _arg2)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(statusCode)
	runtime.KeepAlive(reasonPhrase)
}

// StealConnection: "Steals" the HTTP connection associated with msg from
// its Server. This happens immediately, regardless of the current state of
// the connection; if the response to msg has not yet finished being sent,
// then it will be discarded; you can steal the connection from a
// servermessage::wrote-informational or servermessage::wrote-body signal
// handler if you need to wait for part or all of the response to be sent.
//
// Note that when calling this function from C, msg will most likely be freed as
// a side effect.
//
// The function returns the following values:
//
//   - ioStream formerly associated with msg (or NULL if msg was no longer
//     associated with a connection). No guarantees are made about what kind of
//     OStream is returned.
//
func (msg *ServerMessage) StealConnection() gio.IOStreamer {
	var _arg0 *C.SoupServerMessage // out
	var _cret *C.GIOStream         // in

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_server_message_steal_connection(_arg0)
	runtime.KeepAlive(msg)

	var _ioStream gio.IOStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.IOStreamer)
			return ok
		})
		rv, ok := casted.(gio.IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}

	return _ioStream
}

// Unpause resumes I/O on msg.
//
// Use this to resume after calling servermessage.Pause, or after adding a new
// chunk to a chunked response. I/O won't actually resume until you return to
// the main loop.
func (msg *ServerMessage) Unpause() {
	var _arg0 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_server_message_unpause(_arg0)
	runtime.KeepAlive(msg)
}

// ServerMessageClass: instance of this type is always passed by reference.
type ServerMessageClass struct {
	*serverMessageClass
}

// serverMessageClass is the struct that's finalized.
type serverMessageClass struct {
	native *C.SoupServerMessageClass
}
