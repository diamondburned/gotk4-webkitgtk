// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void _gotk4_soup3_Message_ConnectWroteHeaders(gpointer, guintptr);
// extern void _gotk4_soup3_Message_ConnectWroteBodyData(gpointer, guint, guintptr);
// extern void _gotk4_soup3_Message_ConnectWroteBody(gpointer, guintptr);
// extern void _gotk4_soup3_Message_ConnectStarting(gpointer, guintptr);
// extern void _gotk4_soup3_Message_ConnectRestarted(gpointer, guintptr);
// extern void _gotk4_soup3_Message_ConnectNetworkEvent(gpointer, GSocketClientEvent, GIOStream*, guintptr);
// extern void _gotk4_soup3_Message_ConnectHstsEnforced(gpointer, guintptr);
// extern void _gotk4_soup3_Message_ConnectGotInformational(gpointer, guintptr);
// extern void _gotk4_soup3_Message_ConnectGotHeaders(gpointer, guintptr);
// extern void _gotk4_soup3_Message_ConnectGotBodyData(gpointer, guint, guintptr);
// extern void _gotk4_soup3_Message_ConnectGotBody(gpointer, guintptr);
// extern void _gotk4_soup3_Message_ConnectFinished(gpointer, guintptr);
// extern void _gotk4_soup3_Message_ConnectContentSniffed(gpointer, gchar*, GHashTable*, guintptr);
// extern gboolean _gotk4_soup3_Message_ConnectRequestCertificatePassword(gpointer, GTlsPassword*, guintptr);
// extern gboolean _gotk4_soup3_Message_ConnectRequestCertificate(gpointer, GTlsClientConnection*, guintptr);
// extern gboolean _gotk4_soup3_Message_ConnectAuthenticate(gpointer, SoupAuth*, gboolean, guintptr);
// extern gboolean _gotk4_soup3_Message_ConnectAcceptCertificate(gpointer, GTlsCertificate*, GTlsCertificateFlags, guintptr);
import "C"

// GType values.
var (
	GTypeMessagePriority = coreglib.Type(C.soup_message_priority_get_type())
	GTypeMessageFlags    = coreglib.Type(C.soup_message_flags_get_type())
	GTypeMessage         = coreglib.Type(C.soup_message_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeMessagePriority, F: marshalMessagePriority},
		coreglib.TypeMarshaler{T: GTypeMessageFlags, F: marshalMessageFlags},
		coreglib.TypeMarshaler{T: GTypeMessage, F: marshalMessage},
	})
}

// MessagePriority priorities that can be set on a message to instruct the
// message queue to process it before any other message with lower priority.
type MessagePriority C.gint

const (
	// MessagePriorityVeryLow: lowest priority, the messages with this priority
	// will be the last ones to be attended.
	MessagePriorityVeryLow MessagePriority = iota
	// MessagePriorityLow: use this for low priority messages, a Message with
	// the default priority will be processed first.
	MessagePriorityLow
	// MessagePriorityNormal: default priotity, this is the priority assigned to
	// the Message by default.
	MessagePriorityNormal
	// MessagePriorityHigh: high priority, a Message with this priority will be
	// processed before the ones with the default priority.
	MessagePriorityHigh
	// MessagePriorityVeryHigh: highest priority, use this for very urgent
	// Message as they will be the first ones to be attended.
	MessagePriorityVeryHigh
)

func marshalMessagePriority(p uintptr) (interface{}, error) {
	return MessagePriority(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MessagePriority.
func (m MessagePriority) String() string {
	switch m {
	case MessagePriorityVeryLow:
		return "VeryLow"
	case MessagePriorityLow:
		return "Low"
	case MessagePriorityNormal:
		return "Normal"
	case MessagePriorityHigh:
		return "High"
	case MessagePriorityVeryHigh:
		return "VeryHigh"
	default:
		return fmt.Sprintf("MessagePriority(%d)", m)
	}
}

// MessageFlags various flags that can be set on a Message to alter its
// behavior.
type MessageFlags C.guint

const (
	// MessageNoRedirect: session should not follow redirect (3xx) responses
	// received by this message.
	MessageNoRedirect MessageFlags = 0b10
	// MessageNewConnection requests that the message should be sent on a
	// newly-created connection, not reusing an existing persistent connection.
	// Note that messages with non-idempotent message:methods behave this way by
	// default, unless UP_MESSAGE_IDEMPOTENT is set.
	MessageNewConnection MessageFlags = 0b100
	// MessageIdempotent: message is considered idempotent, regardless its
	// message:method, and allows reuse of existing idle connections, instead of
	// always requiring a new one, unless UP_MESSAGE_NEW_CONNECTION is set.
	MessageIdempotent MessageFlags = 0b1000
	// MessageDoNotUseAuthCache: authmanager should not use the credentials
	// cache for this message, neither to use cached credentials to
	// automatically authenticate this message nor to cache the credentials
	// after the message is successfully authenticated. This applies to both
	// server and proxy authentication. Note that message::authenticate signal
	// will be emitted, if you want to disable authentication for a message use
	// message.DisableFeature passing UP_TYPE_AUTH_MANAGER instead.
	MessageDoNotUseAuthCache MessageFlags = 0b10000
	// MessageCollectMetrics metrics will be collected for this message.
	MessageCollectMetrics MessageFlags = 0b100000
)

func marshalMessageFlags(p uintptr) (interface{}, error) {
	return MessageFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MessageFlags.
func (m MessageFlags) String() string {
	if m == 0 {
		return "MessageFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(103)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MessageNoRedirect:
			builder.WriteString("NoRedirect|")
		case MessageNewConnection:
			builder.WriteString("NewConnection|")
		case MessageIdempotent:
			builder.WriteString("Idempotent|")
		case MessageDoNotUseAuthCache:
			builder.WriteString("DoNotUseAuthCache|")
		case MessageCollectMetrics:
			builder.WriteString("CollectMetrics|")
		default:
			builder.WriteString(fmt.Sprintf("MessageFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MessageFlags) Has(other MessageFlags) bool {
	return (m & other) == other
}

// MessageOverrides contains methods that are overridable.
type MessageOverrides struct {
}

func defaultMessageOverrides(v *Message) MessageOverrides {
	return MessageOverrides{}
}

// Message represents an HTTP message being sent or received.
//
// A Message represents an HTTP message that is being sent or received.
//
// You would create a Message with message.New or message.NewFromURI, set up its
// fields appropriately, and send it.
//
// message:status-code will normally be a status value, eg, SOUP_STATUS_OK,
// though of course it might actually be an unknown status code.
// message:reason-phrase is the actual text returned from the server, which may
// or may not correspond to the "standard" description of status_code. At any
// rate, it is almost certainly not localized, and not very descriptive even
// if it is in the user's language; you should not use message:reason-phrase
// in user-visible messages. Rather, you should look at message:status-code,
// and determine an end-user-appropriate message based on that and on what you
// were trying to do.
//
// Note that libsoup's terminology here does not quite match the HTTP
// specification: in RFC 2616, an "HTTP-message" is *either* a Request, *or* a
// Response. In libsoup, a Message combines both the request and the response.
type Message struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Message)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Message, *MessageClass, MessageOverrides](
		GTypeMessage,
		initMessageClass,
		wrapMessage,
		defaultMessageOverrides,
	)
}

func initMessageClass(gclass unsafe.Pointer, overrides MessageOverrides, classInitFunc func(*MessageClass)) {
	if classInitFunc != nil {
		class := (*MessageClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMessage(obj *coreglib.Object) *Message {
	return &Message{
		Object: obj,
	}
}

func marshalMessage(p uintptr) (interface{}, error) {
	return wrapMessage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAcceptCertificate is emitted during the msg's connection TLS handshake
// after an unacceptable TLS certificate has been received.
//
// You can return TRUE to accept tls_certificate despite tls_errors.
func (msg *Message) ConnectAcceptCertificate(f func(tlsPeerCertificate gio.TLSCertificater, tlsPeerErrors gio.TLSCertificateFlags) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "accept-certificate", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectAcceptCertificate), f)
}

// ConnectAuthenticate is emitted when the message requires authentication.
//
// If credentials are available call auth.Authenticate on auth. If these
// credentials fail, the signal will be emitted again, with retrying set to
// TRUE, which will continue until you return without calling auth.Authenticate
// on auth.
//
// Note that this may be emitted before msg's body has been fully read.
//
// You can authenticate auth asynchronously by calling gobject.Object.Ref()
// on auth and returning TRUE. The operation will complete once either
// auth.Authenticate or auth.Cancel are called.
func (msg *Message) ConnectAuthenticate(f func(auth Auther, retrying bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "authenticate", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectAuthenticate), f)
}

// ConnectContentSniffed: this signal is emitted after message::got-headers.
//
// If content sniffing is disabled, or no content sniffing will be performed,
// due to the sniffer deciding to trust the Content-Type sent by the server,
// this signal is emitted immediately after message::got-headers, and type is
// NULL.
func (msg *Message) ConnectContentSniffed(f func(typ string, params map[string]string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "content-sniffed", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectContentSniffed), f)
}

// ConnectFinished is emitted when all HTTP processing is finished for a
// message.
//
// (After message::got_body).
func (msg *Message) ConnectFinished(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "finished", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectFinished), f)
}

// ConnectGotBody is emitted after receiving the complete message response body.
func (msg *Message) ConnectGotBody(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "got-body", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectGotBody), f)
}

// ConnectGotBodyData is emitted after reading a portion of the message body
// from the network.
func (msg *Message) ConnectGotBodyData(f func(chunkSize uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "got-body-data", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectGotBodyData), f)
}

// ConnectGotHeaders is emitted after receiving the Status-Line and response
// headers.
//
// See also message.AddHeaderHandler and message.AddStatusCodeHandler, which can
// be used to connect to a subset of emissions of this signal.
//
// If you cancel or requeue msg while processing this signal, then the current
// HTTP I/O will be stopped after this signal emission finished, and msg's
// connection will be closed. (If you need to requeue a message--eg, after
// handling authentication or redirection--it is usually better to requeue it
// from a message::got-body handler rather than a message::got_headers handler,
// so that the existing HTTP connection can be reused.).
func (msg *Message) ConnectGotHeaders(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "got-headers", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectGotHeaders), f)
}

// ConnectGotInformational is emitted after receiving a 1xx (Informational)
// response for a (client-side) message.
//
// The response_headers will be filled in with the headers associated with the
// informational response; however, those header values will be erased after
// this signal is done.
//
// If you cancel or requeue msg while processing this signal, then the current
// HTTP I/O will be stopped after this signal emission finished, and msg's
// connection will be closed.
func (msg *Message) ConnectGotInformational(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "got-informational", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectGotInformational), f)
}

// ConnectHstsEnforced is emitted when hstsenforcer has upgraded the protocol
// for msg to HTTPS as a result of matching its domain with a HSTS policy.
func (msg *Message) ConnectHstsEnforced(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "hsts-enforced", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectHstsEnforced), f)
}

// ConnectNetworkEvent is emitted to indicate that some network-related event
// related to msg has occurred.
//
// This essentially proxies the gio.SocketClient::event signal, but only
// for events that occur while msg "owns" the connection; if msg is sent on
// an existing persistent connection, then this signal will not be emitted.
// (If you want to force the message to be sent on a new connection, set the
// SOUP_MESSAGE_NEW_CONNECTION flag on it.)
//
// See gio.SocketClient::event for more information on what the different values
// of event correspond to, and what connection will be in each case.
func (msg *Message) ConnectNetworkEvent(f func(event gio.SocketClientEvent, connection gio.IOStreamer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "network-event", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectNetworkEvent), f)
}

// ConnectRequestCertificate is emitted during the msg's connection TLS
// handshake when tls_connection requests a certificate from the client.
//
// You can set the client certificate by calling message.SetTLSClientCertificate
// and returning TRUE. It's possible to handle the request asynchornously
// by returning TRUE and call message.SetTLSClientCertificate later once
// the certificate is available. Note that this signal is not emitted if
// session:tls-interaction was set, or if message.SetTLSClientCertificate was
// called before the connection TLS handshake started.
func (msg *Message) ConnectRequestCertificate(f func(tlsConnection gio.TLSClientConnectioner) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "request-certificate", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectRequestCertificate), f)
}

// ConnectRequestCertificatePassword is emitted during the msg's connection
// TLS handshake when tls_connection requests a certificate password from the
// client.
//
// You can set the certificate password on password, then call
// message.TLSClientCertificatePasswordRequestComplete and return TRUE to
// handle the signal synchronously. It's possible to handle the request
// asynchornously by calling gobject.Object.Ref() on password, then returning
// TRUE and call message.TLSClientCertificatePasswordRequestComplete later after
// setting the password on password. Note that this signal is not emitted if
// session:tls-interaction was set.
func (msg *Message) ConnectRequestCertificatePassword(f func(tlsPassword *gio.TLSPassword) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "request-certificate-password", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectRequestCertificatePassword), f)
}

// ConnectRestarted is emitted when a request that was already sent once is now
// being sent again.
//
// e.g. because the first attempt received a redirection response, or because we
// needed to use authentication.
func (msg *Message) ConnectRestarted(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "restarted", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectRestarted), f)
}

// ConnectStarting is emitted just before a message is sent.
func (msg *Message) ConnectStarting(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "starting", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectStarting), f)
}

// ConnectWroteBody is emitted immediately after writing the complete body for a
// message.
func (msg *Message) ConnectWroteBody(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-body", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectWroteBody), f)
}

// ConnectWroteBodyData is emitted immediately after writing a portion of the
// message body to the network.
func (msg *Message) ConnectWroteBodyData(f func(chunkSize uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-body-data", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectWroteBodyData), f)
}

// ConnectWroteHeaders is emitted immediately after writing the request headers
// for a message.
func (msg *Message) ConnectWroteHeaders(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-headers", false, unsafe.Pointer(C._gotk4_soup3_Message_ConnectWroteHeaders), f)
}

// NewMessage creates a new empty Message, which will connect to uri.
//
// The function takes the following parameters:
//
//   - method: HTTP method for the created request.
//   - uriString: destination endpoint (as a string).
//
// The function returns the following values:
//
//   - message (optional): new Message (or NULL if uri could not be parsed).
//
func NewMessage(method, uriString string) *Message {
	var _arg1 *C.char        // out
	var _arg2 *C.char        // out
	var _cret *C.SoupMessage // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.soup_message_new(_arg1, _arg2)
	runtime.KeepAlive(method)
	runtime.KeepAlive(uriString)

	var _message *Message // out

	if _cret != nil {
		_message = wrapMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _message
}

// NewMessageFromEncodedForm creates a new Message and sets it up to send the
// given encoded_form to uri via method. If method is "GET", it will include
// the form data into uri's query field, and if method is "POST" or "PUT",
// it will be set as request body.
//
// This function takes the ownership of encoded_form, that will be released with
// glib.Free() when no longer in use. See also form_encode, form_encode_hash and
// form_encode_datalist.
//
// The function takes the following parameters:
//
//   - method: HTTP method for the created request (GET, POST or PUT).
//   - uriString: destination endpoint (as a string).
//   - encodedForm: encoded form.
//
// The function returns the following values:
//
//   - message (optional): new Message, or NULL if uri_string could not be
//     parsed or method is not "GET, "POST" or "PUT".
//
func NewMessageFromEncodedForm(method, uriString, encodedForm string) *Message {
	var _arg1 *C.char        // out
	var _arg2 *C.char        // out
	var _arg3 *C.char        // out
	var _cret *C.SoupMessage // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(encodedForm)))

	_cret = C.soup_message_new_from_encoded_form(_arg1, _arg2, _arg3)
	runtime.KeepAlive(method)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(encodedForm)

	var _message *Message // out

	if _cret != nil {
		_message = wrapMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _message
}

// NewMessageFromMultipart creates a new Message and sets it up to send
// multipart to uri_string via POST.
//
// The function takes the following parameters:
//
//   - uriString: destination endpoint.
//   - multipart: Multipart.
//
// The function returns the following values:
//
//   - message (optional): new Message, or NULL if uri_string could not be
//     parsed.
//
func NewMessageFromMultipart(uriString string, multipart *Multipart) *Message {
	var _arg1 *C.char          // out
	var _arg2 *C.SoupMultipart // out
	var _cret *C.SoupMessage   // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.SoupMultipart)(gextras.StructNative(unsafe.Pointer(multipart)))

	_cret = C.soup_message_new_from_multipart(_arg1, _arg2)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(multipart)

	var _message *Message // out

	if _cret != nil {
		_message = wrapMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _message
}

// NewMessageFromURI creates a new empty Message, which will connect to uri.
//
// The function takes the following parameters:
//
//   - method: HTTP method for the created request.
//   - uri: destination endpoint.
//
// The function returns the following values:
//
//   - message: new Message.
//
func NewMessageFromURI(method string, uri *glib.URI) *Message {
	var _arg1 *C.char        // out
	var _arg2 *C.GUri        // out
	var _cret *C.SoupMessage // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.soup_message_new_from_uri(_arg1, _arg2)
	runtime.KeepAlive(method)
	runtime.KeepAlive(uri)

	var _message *Message // out

	_message = wrapMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _message
}

// NewMessageOptionsPing creates a new Message to send OPTIONS * to a server.
// The path of base_uri will be ignored.
//
// The function takes the following parameters:
//
//   - baseUri: destination endpoint.
//
// The function returns the following values:
//
//   - message: new Message.
//
func NewMessageOptionsPing(baseUri *glib.URI) *Message {
	var _arg1 *C.GUri        // out
	var _cret *C.SoupMessage // in

	_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(baseUri)))

	_cret = C.soup_message_new_options_ping(_arg1)
	runtime.KeepAlive(baseUri)

	var _message *Message // out

	_message = wrapMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _message
}

// AddFlags adds flags to the set of msg's flags.
//
// The function takes the following parameters:
//
//   - flags: set of MessageFlags values.
//
func (msg *Message) AddFlags(flags MessageFlags) {
	var _arg0 *C.SoupMessage     // out
	var _arg1 C.SoupMessageFlags // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.SoupMessageFlags(flags)

	C.soup_message_add_flags(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(flags)
}

// DisableFeature disables the actions of sessionfeatures with the given
// feature_type (or a subclass of that type) on msg.
//
// msg is processed as though the feature(s) hadn't been added to the session.
// Eg, passing UP_TYPE_CONTENT_SNIFFER for feature_type will disable
// Content-Type sniffing on the message.
//
// You must call this before queueing msg on a session; calling it on a message
// that has already been queued is undefined. In particular, you cannot call
// this on a message that is being requeued after a redirect or authentication.
//
// The function takes the following parameters:
//
//   - featureType of a SessionFeature.
//
func (msg *Message) DisableFeature(featureType coreglib.Type) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.GType        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.GType(featureType)

	C.soup_message_disable_feature(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(featureType)
}

// ConnectionID returns the unique idenfier for the last connection used.
//
// This may be 0 if it was a cached resource or it has not gotten a connection
// yet.
//
// The function returns the following values:
//
//   - guint64: id or 0 if no connection.
//
func (msg *Message) ConnectionID() uint64 {
	var _arg0 *C.SoupMessage // out
	var _cret C.guint64      // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_connection_id(_arg0)
	runtime.KeepAlive(msg)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// FirstParty gets msg's first-party glib.URI.
//
// The function returns the following values:
//
//   - uri msg's first party #GUri.
//
func (msg *Message) FirstParty() *glib.URI {
	var _arg0 *C.SoupMessage // out
	var _cret *C.GUri        // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_first_party(_arg0)
	runtime.KeepAlive(msg)

	var _uri *glib.URI // out

	_uri = (*glib.URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _uri
}

// Flags gets the flags on msg.
//
// The function returns the following values:
//
//   - messageFlags: flags.
//
func (msg *Message) Flags() MessageFlags {
	var _arg0 *C.SoupMessage     // out
	var _cret C.SoupMessageFlags // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_flags(_arg0)
	runtime.KeepAlive(msg)

	var _messageFlags MessageFlags // out

	_messageFlags = MessageFlags(_cret)

	return _messageFlags
}

// ForceHTTP1 returns whether HTTP/1 version is currently demanded for the msg
// send.
//
// The function returns the following values:
//
//   - ok: TRUE, when HTTP/1 is demanded, FALSE otherwise.
//
func (msg *Message) ForceHTTP1() bool {
	var _arg0 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_force_http1(_arg0)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HTTPVersion gets the HTTP version of msg.
//
// This is the minimum of the version from the request and the version from the
// response.
//
// The function returns the following values:
//
//   - httpVersion: HTTP version.
//
func (msg *Message) HTTPVersion() HTTPVersion {
	var _arg0 *C.SoupMessage    // out
	var _cret C.SoupHTTPVersion // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_http_version(_arg0)
	runtime.KeepAlive(msg)

	var _httpVersion HTTPVersion // out

	_httpVersion = HTTPVersion(_cret)

	return _httpVersion
}

// IsOptionsPing gets whether msg is intended to be used to send OPTIONS * to a
// server.
//
// The function returns the following values:
//
//   - ok: TRUE if the message is options ping, or FALSE otherwise.
//
func (msg *Message) IsOptionsPing() bool {
	var _arg0 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_is_options_ping(_arg0)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsTopLevelNavigation returns if this message is set as a top level
// navigation.
//
// Used for same-site policy checks.
//
// The function returns the following values:
//
//   - ok: whether the current request is a top-level navitation.
//
func (msg *Message) IsTopLevelNavigation() bool {
	var _arg0 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_is_top_level_navigation(_arg0)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Method returns the method of this message.
//
// The function returns the following values:
//
//   - utf8: method such as SOUP_METHOD_GET.
//
func (msg *Message) Method() string {
	var _arg0 *C.SoupMessage // out
	var _cret *C.char        // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_method(_arg0)
	runtime.KeepAlive(msg)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Metrics: get the messagemetrics of msg.
//
// If the flag SOUP_MESSAGE_COLLECT_METRICS is not enabled for msg this will
// return NULL.
//
// The function returns the following values:
//
//   - messageMetrics (optional): MessageMetrics.
//
func (msg *Message) Metrics() *MessageMetrics {
	var _arg0 *C.SoupMessage        // out
	var _cret *C.SoupMessageMetrics // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_metrics(_arg0)
	runtime.KeepAlive(msg)

	var _messageMetrics *MessageMetrics // out

	if _cret != nil {
		_messageMetrics = (*MessageMetrics)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _messageMetrics
}

// Priority retrieves the messagepriority.
//
// If not set this value defaults to UP_MESSAGE_PRIORITY_NORMAL.
//
// The function returns the following values:
//
//   - messagePriority: priority of the message.
//
func (msg *Message) Priority() MessagePriority {
	var _arg0 *C.SoupMessage        // out
	var _cret C.SoupMessagePriority // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_priority(_arg0)
	runtime.KeepAlive(msg)

	var _messagePriority MessagePriority // out

	_messagePriority = MessagePriority(_cret)

	return _messagePriority
}

// ReasonPhrase returns the reason phrase for the status of this message.
//
// The function returns the following values:
//
//   - utf8 (optional): phrase.
//
func (msg *Message) ReasonPhrase() string {
	var _arg0 *C.SoupMessage // out
	var _cret *C.char        // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_reason_phrase(_arg0)
	runtime.KeepAlive(msg)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// RemoteAddress: get the remote gio.SocketAddress of the connection associated
// with the message.
//
// The returned address can be NULL if the connection hasn't been established
// yet, or the resource was loaded from the disk cache. In case of proxy
// connections, the remote address returned is a gio.ProxyAddress. If
// session:remote-connectable is set the returned address id for the connection
// to the session's remote connectable.
//
// The function returns the following values:
//
//   - socketAddress (optional) or NULL if the connection hasn't been
//     established.
//
func (msg *Message) RemoteAddress() gio.SocketAddresser {
	var _arg0 *C.SoupMessage    // out
	var _cret *C.GSocketAddress // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_remote_address(_arg0)
	runtime.KeepAlive(msg)

	var _socketAddress gio.SocketAddresser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.SocketAddresser)
				return ok
			})
			rv, ok := casted.(gio.SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}

	return _socketAddress
}

// RequestHeaders returns the headers sent with the request.
//
// The function returns the following values:
//
//   - messageHeaders: MessageHeaders.
//
func (msg *Message) RequestHeaders() *MessageHeaders {
	var _arg0 *C.SoupMessage        // out
	var _cret *C.SoupMessageHeaders // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_request_headers(_arg0)
	runtime.KeepAlive(msg)

	var _messageHeaders *MessageHeaders // out

	_messageHeaders = (*MessageHeaders)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.soup_message_headers_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_messageHeaders)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_message_headers_unref((*C.SoupMessageHeaders)(intern.C))
		},
	)

	return _messageHeaders
}

// ResponseHeaders returns the headers recieved with the response.
//
// The function returns the following values:
//
//   - messageHeaders: MessageHeaders.
//
func (msg *Message) ResponseHeaders() *MessageHeaders {
	var _arg0 *C.SoupMessage        // out
	var _cret *C.SoupMessageHeaders // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_response_headers(_arg0)
	runtime.KeepAlive(msg)

	var _messageHeaders *MessageHeaders // out

	_messageHeaders = (*MessageHeaders)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.soup_message_headers_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_messageHeaders)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_message_headers_unref((*C.SoupMessageHeaders)(intern.C))
		},
	)

	return _messageHeaders
}

// SiteForCookies gets msg's site for cookies #GUri.
//
// The function returns the following values:
//
//   - uri msg's site for cookies #GUri.
//
func (msg *Message) SiteForCookies() *glib.URI {
	var _arg0 *C.SoupMessage // out
	var _cret *C.GUri        // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_site_for_cookies(_arg0)
	runtime.KeepAlive(msg)

	var _uri *glib.URI // out

	_uri = (*glib.URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _uri
}

// Status returns the set status of this message.
//
// The function returns the following values:
//
//   - status: Status.
//
func (msg *Message) Status() Status {
	var _arg0 *C.SoupMessage // out
	var _cret C.SoupStatus   // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_status(_arg0)
	runtime.KeepAlive(msg)

	var _status Status // out

	_status = Status(_cret)

	return _status
}

// TLSCiphersuiteName gets the name of the TLS ciphersuite negotiated for msg's
// connection.
//
// The function returns the following values:
//
//   - utf8: name of the TLS ciphersuite, or NULL if msg's connection is not
//     SSL.
//
func (msg *Message) TLSCiphersuiteName() string {
	var _arg0 *C.SoupMessage // out
	var _cret *C.char        // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_tls_ciphersuite_name(_arg0)
	runtime.KeepAlive(msg)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TLSPeerCertificate gets the peer's gio.TLSCertificate associated with msg's
// connection.
//
// Note that this is not set yet during the emission of
// message::accept-certificate signal.
//
// The function returns the following values:
//
//   - tlsCertificate (optional) msg's TLS peer certificate, or NULL if msg's
//     connection is not SSL.
//
func (msg *Message) TLSPeerCertificate() gio.TLSCertificater {
	var _arg0 *C.SoupMessage     // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_tls_peer_certificate(_arg0)
	runtime.KeepAlive(msg)

	var _tlsCertificate gio.TLSCertificater // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.TLSCertificater)
				return ok
			})
			rv, ok := casted.(gio.TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			_tlsCertificate = rv
		}
	}

	return _tlsCertificate
}

// TLSPeerCertificateErrors gets the errors associated with validating msg's
// TLS peer certificate. Note that this is not set yet during the emission of
// message::accept-certificate signal.
//
// The function returns the following values:
//
//   - tlsCertificateFlags with msg's TLS peer certificate errors.
//
func (msg *Message) TLSPeerCertificateErrors() gio.TLSCertificateFlags {
	var _arg0 *C.SoupMessage         // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_tls_peer_certificate_errors(_arg0)
	runtime.KeepAlive(msg)

	var _tlsCertificateFlags gio.TLSCertificateFlags // out

	_tlsCertificateFlags = gio.TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

// URI gets msg's URI.
//
// The function returns the following values:
//
//   - uri: URI msg is targeted for.
//
func (msg *Message) URI() *glib.URI {
	var _arg0 *C.SoupMessage // out
	var _cret *C.GUri        // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_uri(_arg0)
	runtime.KeepAlive(msg)

	var _uri *glib.URI // out

	_uri = (*glib.URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _uri
}

// IsFeatureDisabled: get whether sessionfeatures of the given feature_type (or
// a subclass of that type) are disabled on msg.
//
// See message.DisableFeature.
//
// The function takes the following parameters:
//
//   - featureType of a SessionFeature.
//
// The function returns the following values:
//
//   - ok: TRUE if feature is disabled, or FALSE otherwise.
//
func (msg *Message) IsFeatureDisabled(featureType coreglib.Type) bool {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.GType        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_message_is_feature_disabled(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(featureType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsKeepalive determines whether or not msg's connection can be kept alive for
// further requests after processing msg.
//
// The result is based on the HTTP version, Connection header, etc.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE.
//
func (msg *Message) IsKeepalive() bool {
	var _arg0 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_is_keepalive(_arg0)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryFlags queries if flags are present in the set of msg's flags.
//
// The function takes the following parameters:
//
//   - flags: set of MessageFlags values.
//
// The function returns the following values:
//
//   - ok: TRUE if flags are enabled in msg.
//
func (msg *Message) QueryFlags(flags MessageFlags) bool {
	var _arg0 *C.SoupMessage     // out
	var _arg1 C.SoupMessageFlags // out
	var _cret C.gboolean         // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.SoupMessageFlags(flags)

	_cret = C.soup_message_query_flags(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveFlags removes flags from the set of msg's flags.
//
// The function takes the following parameters:
//
//   - flags: set of MessageFlags values.
//
func (msg *Message) RemoveFlags(flags MessageFlags) {
	var _arg0 *C.SoupMessage     // out
	var _arg1 C.SoupMessageFlags // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.SoupMessageFlags(flags)

	C.soup_message_remove_flags(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(flags)
}

// SetFirstParty sets first_party as the main document #GUri for msg.
//
// For details of when and how this is used refer to the documentation for
// cookiejaracceptpolicy.
//
// The function takes the following parameters:
//
//   - firstParty for the msg's first party.
//
func (msg *Message) SetFirstParty(firstParty *glib.URI) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.GUri        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(firstParty)))

	C.soup_message_set_first_party(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(firstParty)
}

// SetFlags sets the specified flags on msg.
//
// The function takes the following parameters:
//
//   - flags: set of MessageFlags values.
//
func (msg *Message) SetFlags(flags MessageFlags) {
	var _arg0 *C.SoupMessage     // out
	var _arg1 C.SoupMessageFlags // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.SoupMessageFlags(flags)

	C.soup_message_set_flags(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(flags)
}

// SetForceHTTP1 sets whether HTTP/1 version should be used when sending this
// message. Some connections can still override it, if needed.
//
// Note the value is unset after the message send is finished.
//
// The function takes the following parameters:
//
//   - value to set.
//
func (msg *Message) SetForceHTTP1(value bool) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if value {
		_arg1 = C.TRUE
	}

	C.soup_message_set_force_http1(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(value)
}

// SetIsOptionsPing: set whether msg is intended to be used to send OPTIONS * to
// a server.
//
// When set to TRUE, the path of message:uri will be ignored and message:method
// set to SOUP_METHOD_OPTIONS.
//
// The function takes the following parameters:
//
//   - isOptionsPing: value to set.
//
func (msg *Message) SetIsOptionsPing(isOptionsPing bool) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if isOptionsPing {
		_arg1 = C.TRUE
	}

	C.soup_message_set_is_options_ping(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(isOptionsPing)
}

// SetIsTopLevelNavigation sets whether the current request is a top-level
// navitation.
//
// See the same-site spec
// (https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for more
// information.
//
// The function takes the following parameters:
//
//   - isTopLevelNavigation: if TRUE indicate the current request is a top-level
//     navigation.
//
func (msg *Message) SetIsTopLevelNavigation(isTopLevelNavigation bool) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if isTopLevelNavigation {
		_arg1 = C.TRUE
	}

	C.soup_message_set_is_top_level_navigation(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(isTopLevelNavigation)
}

// SetMethod: set msg's HTTP method to method.
//
// The function takes the following parameters:
//
//   - method: value to set.
//
func (msg *Message) SetMethod(method string) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.char        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_message_set_method(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(method)
}

// SetPriority sets the priority of a message.
//
// Note that this won't have any effect unless used before the message is added
// to the session's message processing queue.
//
// The message will be placed just before any other previously added message
// with lower priority (messages with the same priority are processed on a FIFO
// basis).
//
// Setting priorities does not currently work with synchronous messages
// because in the synchronous/blocking case, priority ends up being determined
// semi-randomly by thread scheduling.
//
// The function takes the following parameters:
//
//   - priority: MessagePriority.
//
func (msg *Message) SetPriority(priority MessagePriority) {
	var _arg0 *C.SoupMessage        // out
	var _arg1 C.SoupMessagePriority // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.SoupMessagePriority(priority)

	C.soup_message_set_priority(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(priority)
}

// SetRequestBody: set the request body of a Message.
//
// If content_type is NULL and stream is not NULL the Content-Type header will
// not be changed if present. The request body needs to be set again in case msg
// is restarted (in case of redirection or authentication).
//
// The function takes the following parameters:
//
//   - contentType (optional): MIME Content-Type of the body, or NULL if
//     unknown.
//   - stream (optional) to read the request body from.
//   - contentLength: byte length of stream or -1 if unknown.
//
func (msg *Message) SetRequestBody(contentType string, stream gio.InputStreamer, contentLength int) {
	var _arg0 *C.SoupMessage  // out
	var _arg1 *C.char         // out
	var _arg2 *C.GInputStream // out
	var _arg3 C.gssize        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if contentType != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if stream != nil {
		_arg2 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	}
	_arg3 = C.gssize(contentLength)

	C.soup_message_set_request_body(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(contentLength)
}

// SetRequestBodyFromBytes: set the request body of a Message from glib.Bytes.
//
// If content_type is NULL and bytes is not NULL the Content-Type header will
// not be changed if present. The request body needs to be set again in case msg
// is restarted (in case of redirection or authentication).
//
// The function takes the following parameters:
//
//   - contentType (optional): MIME Content-Type of the body, or NULL if
//     unknown.
//   - bytes (optional) with the request body data.
//
func (msg *Message) SetRequestBodyFromBytes(contentType string, bytes *glib.Bytes) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.char        // out
	var _arg2 *C.GBytes      // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if contentType != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if bytes != nil {
		_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	}

	C.soup_message_set_request_body_from_bytes(_arg0, _arg1, _arg2)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(bytes)
}

// SetSiteForCookies sets site_for_cookies as the policy URL for same-site
// cookies for msg.
//
// It is either the URL of the top-level document or NULL depending on whether
// the registrable domain of this document's URL matches the registrable domain
// of its parent's/opener's URL. For the top-level document it is set to the
// document's URL.
//
// See the same-site spec
// (https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for more
// information.
//
// The function takes the following parameters:
//
//   - siteForCookies (optional) for the msg's site for cookies.
//
func (msg *Message) SetSiteForCookies(siteForCookies *glib.URI) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.GUri        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if siteForCookies != nil {
		_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(siteForCookies)))
	}

	C.soup_message_set_site_for_cookies(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(siteForCookies)
}

// SetTLSClientCertificate sets the certificate to be used by msg's connection
// when a client certificate is requested during the TLS handshake.
//
// You can call this as a response to message::request-certificate signal,
// or before the connection is started. If certificate is NULL the
// handshake will continue without providing a GTlsCertificate. Note
// that the gio.TLSCertificate set by this function will be ignored if
// session:tls-interaction is not NULL.
//
// The function takes the following parameters:
//
//   - certificate (optional) to set, or NULL.
//
func (msg *Message) SetTLSClientCertificate(certificate gio.TLSCertificater) {
	var _arg0 *C.SoupMessage     // out
	var _arg1 *C.GTlsCertificate // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if certificate != nil {
		_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))
	}

	C.soup_message_set_tls_client_certificate(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(certificate)
}

// SetURI sets msg's URI to uri.
//
// If msg has already been sent and you want to re-send it with the new URI,
// you need to send it again.
//
// The function takes the following parameters:
//
//   - uri: new #GUri.
//
func (msg *Message) SetURI(uri *glib.URI) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.GUri        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	C.soup_message_set_uri(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(uri)
}

// TLSClientCertificatePasswordRequestComplete completes a certificate password
// request.
//
// You must call this as a response to message::request-certificate-password
// signal, to notify msg that the gio.TLSPassword has already been updated.
func (msg *Message) TLSClientCertificatePasswordRequestComplete() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_message_tls_client_certificate_password_request_complete(_arg0)
	runtime.KeepAlive(msg)
}

// MessageClass: instance of this type is always passed by reference.
type MessageClass struct {
	*messageClass
}

// messageClass is the struct that's finalized.
type messageClass struct {
	native *C.SoupMessageClass
}
