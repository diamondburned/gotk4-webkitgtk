// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_soup2_Message_ConnectWroteInformational(gpointer, guintptr);
// extern void _gotk4_soup2_Message_ConnectWroteHeaders(gpointer, guintptr);
// extern void _gotk4_soup2_Message_ConnectWroteChunk(gpointer, guintptr);
// extern void _gotk4_soup2_Message_ConnectWroteBodyData(gpointer, SoupBuffer*, guintptr);
// extern void _gotk4_soup2_Message_ConnectWroteBody(gpointer, guintptr);
// extern void _gotk4_soup2_Message_ConnectStarting(gpointer, guintptr);
// extern void _gotk4_soup2_Message_ConnectRestarted(gpointer, guintptr);
// extern void _gotk4_soup2_Message_ConnectNetworkEvent(gpointer, GSocketClientEvent, GIOStream*, guintptr);
// extern void _gotk4_soup2_Message_ConnectGotInformational(gpointer, guintptr);
// extern void _gotk4_soup2_Message_ConnectGotHeaders(gpointer, guintptr);
// extern void _gotk4_soup2_Message_ConnectGotChunk(gpointer, SoupBuffer*, guintptr);
// extern void _gotk4_soup2_Message_ConnectGotBody(gpointer, guintptr);
// extern void _gotk4_soup2_Message_ConnectFinished(gpointer, guintptr);
// extern void _gotk4_soup2_Message_ConnectContentSniffed(gpointer, gchar*, GHashTable*, guintptr);
// extern void _gotk4_soup2_MessageClass_wrote_informational(SoupMessage*);
// extern void _gotk4_soup2_MessageClass_wrote_headers(SoupMessage*);
// extern void _gotk4_soup2_MessageClass_wrote_chunk(SoupMessage*);
// extern void _gotk4_soup2_MessageClass_wrote_body(SoupMessage*);
// extern void _gotk4_soup2_MessageClass_starting(SoupMessage*);
// extern void _gotk4_soup2_MessageClass_restarted(SoupMessage*);
// extern void _gotk4_soup2_MessageClass_got_informational(SoupMessage*);
// extern void _gotk4_soup2_MessageClass_got_headers(SoupMessage*);
// extern void _gotk4_soup2_MessageClass_got_chunk(SoupMessage*, SoupBuffer*);
// extern void _gotk4_soup2_MessageClass_got_body(SoupMessage*);
// extern void _gotk4_soup2_MessageClass_finished(SoupMessage*);
// extern SoupBuffer* _gotk4_soup2_ChunkAllocator(SoupMessage*, gsize, gpointer);
// void _gotk4_soup2_Message_virtual_finished(void* fnptr, SoupMessage* arg0) {
//   ((void (*)(SoupMessage*))(fnptr))(arg0);
// };
// void _gotk4_soup2_Message_virtual_got_body(void* fnptr, SoupMessage* arg0) {
//   ((void (*)(SoupMessage*))(fnptr))(arg0);
// };
// void _gotk4_soup2_Message_virtual_got_chunk(void* fnptr, SoupMessage* arg0, SoupBuffer* arg1) {
//   ((void (*)(SoupMessage*, SoupBuffer*))(fnptr))(arg0, arg1);
// };
// void _gotk4_soup2_Message_virtual_got_headers(void* fnptr, SoupMessage* arg0) {
//   ((void (*)(SoupMessage*))(fnptr))(arg0);
// };
// void _gotk4_soup2_Message_virtual_got_informational(void* fnptr, SoupMessage* arg0) {
//   ((void (*)(SoupMessage*))(fnptr))(arg0);
// };
// void _gotk4_soup2_Message_virtual_restarted(void* fnptr, SoupMessage* arg0) {
//   ((void (*)(SoupMessage*))(fnptr))(arg0);
// };
// void _gotk4_soup2_Message_virtual_starting(void* fnptr, SoupMessage* arg0) {
//   ((void (*)(SoupMessage*))(fnptr))(arg0);
// };
// void _gotk4_soup2_Message_virtual_wrote_body(void* fnptr, SoupMessage* arg0) {
//   ((void (*)(SoupMessage*))(fnptr))(arg0);
// };
// void _gotk4_soup2_Message_virtual_wrote_chunk(void* fnptr, SoupMessage* arg0) {
//   ((void (*)(SoupMessage*))(fnptr))(arg0);
// };
// void _gotk4_soup2_Message_virtual_wrote_headers(void* fnptr, SoupMessage* arg0) {
//   ((void (*)(SoupMessage*))(fnptr))(arg0);
// };
// void _gotk4_soup2_Message_virtual_wrote_informational(void* fnptr, SoupMessage* arg0) {
//   ((void (*)(SoupMessage*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeHTTPVersion     = coreglib.Type(C.soup_http_version_get_type())
	GTypeMessagePriority = coreglib.Type(C.soup_message_priority_get_type())
	GTypeMessageFlags    = coreglib.Type(C.soup_message_flags_get_type())
	GTypeMessage         = coreglib.Type(C.soup_message_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeHTTPVersion, F: marshalHTTPVersion},
		coreglib.TypeMarshaler{T: GTypeMessagePriority, F: marshalMessagePriority},
		coreglib.TypeMarshaler{T: GTypeMessageFlags, F: marshalMessageFlags},
		coreglib.TypeMarshaler{T: GTypeMessage, F: marshalMessage},
	})
}

// MESSAGE_FLAGS alias for the Message:flags property. (The message's
// MessageFlags.).
const MESSAGE_FLAGS = "flags"

// MESSAGE_HTTP_VERSION alias for the Message:http-version property. (The
// message's HTTPVersion.).
const MESSAGE_HTTP_VERSION = "http-version"
const MESSAGE_IS_TOP_LEVEL_NAVIGATION = "is-top-level-navigation"

// MESSAGE_METHOD alias for the Message:method property. (The message's HTTP
// method.).
const MESSAGE_METHOD = "method"

// MESSAGE_REASON_PHRASE alias for the Message:reason-phrase property. (The
// message's HTTP response reason phrase.).
const MESSAGE_REASON_PHRASE = "reason-phrase"

// MESSAGE_REQUEST_BODY alias for the Message:request-body property. (The
// message's HTTP request body.).
const MESSAGE_REQUEST_BODY = "request-body"

// MESSAGE_REQUEST_HEADERS alias for the Message:request-headers property.
// (The message's HTTP request headers.).
const MESSAGE_REQUEST_HEADERS = "request-headers"

// MESSAGE_RESPONSE_BODY alias for the Message:response-body property. (The
// message's HTTP response body.).
const MESSAGE_RESPONSE_BODY = "response-body"

// MESSAGE_RESPONSE_HEADERS alias for the Message:response-headers property.
// (The message's HTTP response headers.).
const MESSAGE_RESPONSE_HEADERS = "response-headers"

// MESSAGE_SERVER_SIDE alias for the Message:server-side property. (TRUE if the
// message was created by Server.).
const MESSAGE_SERVER_SIDE = "server-side"
const MESSAGE_SITE_FOR_COOKIES = "site-for-cookies"

// MESSAGE_STATUS_CODE alias for the Message:status-code property. (The
// message's HTTP response status code.).
const MESSAGE_STATUS_CODE = "status-code"

// MESSAGE_URI alias for the Message:uri property. (The message's URI.).
const MESSAGE_URI = "uri"

// HTTPVersion indicates the HTTP protocol version being used.
type HTTPVersion C.gint

const (
	// HTTP10: HTTP 1.0 (RFC 1945).
	HTTP10 HTTPVersion = iota
	// HTTP11: HTTP 1.1 (RFC 2616).
	HTTP11
)

func marshalHTTPVersion(p uintptr) (interface{}, error) {
	return HTTPVersion(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for HTTPVersion.
func (h HTTPVersion) String() string {
	switch h {
	case HTTP10:
		return "HTTP10"
	case HTTP11:
		return "HTTP11"
	default:
		return fmt.Sprintf("HTTPVersion(%d)", h)
	}
}

// MessagePriority priorities that can be set on a Message to instruct the
// message queue to process it before any other message with lower priority.
type MessagePriority C.gint

const (
	// MessagePriorityVeryLow: lowest priority, the messages with this priority
	// will be the last ones to be attended.
	MessagePriorityVeryLow MessagePriority = iota
	// MessagePriorityLow: use this for low priority messages, a Message with
	// the default priority will be processed first.
	MessagePriorityLow
	// MessagePriorityNormal: default priotity, this is the priority assigned to
	// the Message by default.
	MessagePriorityNormal
	// MessagePriorityHigh: high priority, a Message with this priority will be
	// processed before the ones with the default priority.
	MessagePriorityHigh
	// MessagePriorityVeryHigh: highest priority, use this for very urgent
	// Message as they will be the first ones to be attended.
	MessagePriorityVeryHigh
)

func marshalMessagePriority(p uintptr) (interface{}, error) {
	return MessagePriority(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MessagePriority.
func (m MessagePriority) String() string {
	switch m {
	case MessagePriorityVeryLow:
		return "VeryLow"
	case MessagePriorityLow:
		return "Low"
	case MessagePriorityNormal:
		return "Normal"
	case MessagePriorityHigh:
		return "High"
	case MessagePriorityVeryHigh:
		return "VeryHigh"
	default:
		return fmt.Sprintf("MessagePriority(%d)", m)
	}
}

// MessageFlags various flags that can be set on a Message to alter its
// behavior.
type MessageFlags C.guint

const (
	// MessageNoRedirect: session should not follow redirect (3xx) responses
	// received by this message.
	MessageNoRedirect MessageFlags = 0b10
	// MessageCanRebuild: caller will rebuild the request body if the message is
	// restarted; see soup_message_body_set_accumulate() for more details.
	MessageCanRebuild MessageFlags = 0b100
	// MessageOverwriteChunks: deprecated: equivalent to calling
	// soup_message_body_set_accumulate() on the incoming message body (ie,
	// Message:response_body for a client-side request), passing FALSE.
	MessageOverwriteChunks MessageFlags = 0b1000
	// MessageContentDecoded: set by ContentDecoder to indicate that it has
	// removed the Content-Encoding on a message (and so headers such as
	// Content-Length may no longer accurately describe the body).
	MessageContentDecoded MessageFlags = 0b10000
	// MessageCertificateTrusted: if set after an https response has been
	// received, indicates that the server's SSL certificate is trusted
	// according to the session's CA.
	MessageCertificateTrusted MessageFlags = 0b100000
	// MessageNewConnection requests that the message should be sent on a
	// newly-created connection, not reusing an existing persistent connection.
	// Note that messages with non-idempotent Message:method<!-- -->s behave
	// this way by default, unless UP_MESSAGE_IDEMPOTENT is set.
	MessageNewConnection MessageFlags = 0b1000000
	// MessageIdempotent: message is considered idempotent, regardless its
	// Message:method, and allows reuse of existing idle connections, instead of
	// always requiring a new one, unless UP_MESSAGE_NEW_CONNECTION is set.
	MessageIdempotent MessageFlags = 0b10000000
	// MessageIgnoreConnectionLimits: request that a new connection is created
	// for the message if there aren't idle connections available and it's not
	// possible to create new connections due to any of the connection limits
	// has been reached. If a dedicated connection is eventually created for
	// this message, it will be dropped when the message finishes. Since 2.50.
	MessageIgnoreConnectionLimits MessageFlags = 0b100000000
	// MessageDoNotUseAuthCache should not use the credentials cache for
	// this message, neither to use cached credentials to automatically
	// authenticate this message nor to cache the credentials after the
	// message is successfully authenticated. This applies to both server
	// and proxy authentication. Note that Session::authenticate signal will
	// be emitted, if you want to disable authentication for a message use
	// soup_message_disable_feature() passing UP_TYPE_AUTH_MANAGER instead.
	// Since 2.58.
	MessageDoNotUseAuthCache MessageFlags = 0b1000000000
)

func marshalMessageFlags(p uintptr) (interface{}, error) {
	return MessageFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MessageFlags.
func (m MessageFlags) String() string {
	if m == 0 {
		return "MessageFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(200)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MessageNoRedirect:
			builder.WriteString("NoRedirect|")
		case MessageCanRebuild:
			builder.WriteString("CanRebuild|")
		case MessageOverwriteChunks:
			builder.WriteString("OverwriteChunks|")
		case MessageContentDecoded:
			builder.WriteString("ContentDecoded|")
		case MessageCertificateTrusted:
			builder.WriteString("CertificateTrusted|")
		case MessageNewConnection:
			builder.WriteString("NewConnection|")
		case MessageIdempotent:
			builder.WriteString("Idempotent|")
		case MessageIgnoreConnectionLimits:
			builder.WriteString("IgnoreConnectionLimits|")
		case MessageDoNotUseAuthCache:
			builder.WriteString("DoNotUseAuthCache|")
		default:
			builder.WriteString(fmt.Sprintf("MessageFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MessageFlags) Has(other MessageFlags) bool {
	return (m & other) == other
}

// ChunkAllocator: prototype for a chunk allocation callback. This should
// allocate a new Buffer and return it for the I/O layer to read message body
// data off the network into.
//
// If max_len is non-0, it indicates the maximum number of bytes that could be
// read, based on what is known about the message size. Note that this might
// be a very large number, and you should not simply try to allocate that many
// bytes blindly. If max_len is 0, that means that libsoup does not know how
// many bytes remain to be read, and the allocator should return a buffer of a
// size that it finds convenient.
//
// If the allocator returns NULL, the message will be paused. It is up to the
// application to make sure that it gets unpaused when it becomes possible to
// allocate a new buffer.
//
// Deprecated: Use Request if you want to read into your own buffers.
type ChunkAllocator func(msg *Message, maxLen uint) (buffer *Buffer)

// MessageOverrides contains methods that are overridable.
type MessageOverrides struct {
	Finished func()
	GotBody  func()
	// The function takes the following parameters:
	//
	GotChunk           func(chunk *Buffer)
	GotHeaders         func()
	GotInformational   func()
	Restarted          func()
	Starting           func()
	WroteBody          func()
	WroteChunk         func()
	WroteHeaders       func()
	WroteInformational func()
}

func defaultMessageOverrides(v *Message) MessageOverrides {
	return MessageOverrides{
		Finished:           v.finished,
		GotBody:            v.gotBody,
		GotChunk:           v.gotChunk,
		GotHeaders:         v.gotHeaders,
		GotInformational:   v.gotInformational,
		Restarted:          v.restarted,
		Starting:           v.starting,
		WroteBody:          v.wroteBody,
		WroteChunk:         v.wroteChunk,
		WroteHeaders:       v.wroteHeaders,
		WroteInformational: v.wroteInformational,
	}
}

// Message represents an HTTP message being sent or received.
//
// status_code will normally be a Status value, eg, SOUP_STATUS_OK, though of
// course it might actually be an unknown status code. reason_phrase is the
// actual text returned from the server, which may or may not correspond to the
// "standard" description of status_code. At any rate, it is almost certainly
// not localized, and not very descriptive even if it is in the user's language;
// you should not use reason_phrase in user-visible messages. Rather, you should
// look at status_code, and determine an end-user-appropriate message based on
// that and on what you were trying to do.
//
// As described in the MessageBody documentation, the request_body and
// response_body <literal>data</literal> fields will not necessarily be filled
// in at all times. When the body fields are filled in, they will be terminated
// with a '\0' byte (which is not included in the <literal>length</literal>),
// so you can use them as ordinary C strings (assuming that you know that the
// body doesn't have any other '\0' bytes).
//
// For a client-side Message, request_body's <literal>data</literal> is
// usually filled in right before libsoup writes the request to the network,
// but you should not count on this; use soup_message_body_flatten() if you want
// to ensure that <literal>data</literal> is filled in. If you are not using
// Request to read the response, then response_body's <literal>data</literal>
// will be filled in before Message::finished is emitted. (If you are
// using Request, then the message body is not accumulated by default,
// so response_body's <literal>data</literal> will always be NULL.)
//
// For a server-side Message, request_body's data will be filled in before
// Message::got_body is emitted.
//
// To prevent the data field from being filled in at all (eg, if you are
// handling the data from a Message::got_chunk, and so don't need to see it
// all at the end), call soup_message_body_set_accumulate() on response_body or
// request_body as appropriate, passing FALSE.
type Message struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Message)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Message, *MessageClass, MessageOverrides](
		GTypeMessage,
		initMessageClass,
		wrapMessage,
		defaultMessageOverrides,
	)
}

func initMessageClass(gclass unsafe.Pointer, overrides MessageOverrides, classInitFunc func(*MessageClass)) {
	pclass := (*C.SoupMessageClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeMessage))))

	if overrides.Finished != nil {
		pclass.finished = (*[0]byte)(C._gotk4_soup2_MessageClass_finished)
	}

	if overrides.GotBody != nil {
		pclass.got_body = (*[0]byte)(C._gotk4_soup2_MessageClass_got_body)
	}

	if overrides.GotChunk != nil {
		pclass.got_chunk = (*[0]byte)(C._gotk4_soup2_MessageClass_got_chunk)
	}

	if overrides.GotHeaders != nil {
		pclass.got_headers = (*[0]byte)(C._gotk4_soup2_MessageClass_got_headers)
	}

	if overrides.GotInformational != nil {
		pclass.got_informational = (*[0]byte)(C._gotk4_soup2_MessageClass_got_informational)
	}

	if overrides.Restarted != nil {
		pclass.restarted = (*[0]byte)(C._gotk4_soup2_MessageClass_restarted)
	}

	if overrides.Starting != nil {
		pclass.starting = (*[0]byte)(C._gotk4_soup2_MessageClass_starting)
	}

	if overrides.WroteBody != nil {
		pclass.wrote_body = (*[0]byte)(C._gotk4_soup2_MessageClass_wrote_body)
	}

	if overrides.WroteChunk != nil {
		pclass.wrote_chunk = (*[0]byte)(C._gotk4_soup2_MessageClass_wrote_chunk)
	}

	if overrides.WroteHeaders != nil {
		pclass.wrote_headers = (*[0]byte)(C._gotk4_soup2_MessageClass_wrote_headers)
	}

	if overrides.WroteInformational != nil {
		pclass.wrote_informational = (*[0]byte)(C._gotk4_soup2_MessageClass_wrote_informational)
	}

	if classInitFunc != nil {
		class := (*MessageClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMessage(obj *coreglib.Object) *Message {
	return &Message{
		Object: obj,
	}
}

func marshalMessage(p uintptr) (interface{}, error) {
	return wrapMessage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectContentSniffed: this signal is emitted after Message::got-headers,
// and before the first Message::got-chunk. If content sniffing is disabled,
// or no content sniffing will be performed, due to the sniffer deciding to
// trust the Content-Type sent by the server, this signal is emitted immediately
// after Message::got-headers, and type is NULL.
//
// If the ContentSniffer feature is enabled, and the sniffer decided to perform
// sniffing, the first Message::got-chunk emission may be delayed, so that
// the sniffer has enough data to correctly sniff the content. It notified the
// library user that the content has been sniffed, and allows it to change the
// header contents in the message, if desired.
//
// After this signal is emitted, the data that was spooled so that sniffing
// could be done is delivered on the first emission of Message::got-chunk.
func (msg *Message) ConnectContentSniffed(f func(typ string, params map[string]string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "content-sniffed", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectContentSniffed), f)
}

// ConnectFinished is emitted when all HTTP processing is finished for a
// message. (After Message::got_body for client-side messages, or after
// Message::wrote_body for server-side messages.).
func (msg *Message) ConnectFinished(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "finished", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectFinished), f)
}

// ConnectGotBody is emitted after receiving the complete message body.
// (For a server-side message, this means it has received the request body.
// For a client-side message, this means it has received the response body and
// is nearly done with the message.)
//
// See also soup_message_add_header_handler() and
// soup_message_add_status_code_handler(), which can be used to connect to a
// subset of emissions of this signal.
func (msg *Message) ConnectGotBody(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "got-body", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectGotBody), f)
}

// ConnectGotChunk is emitted after receiving a chunk of a message body. Note
// that "chunk" in this context means any subpiece of the body, not necessarily
// the specific HTTP 1.1 chunks sent by the other side.
//
// If you cancel or requeue msg while processing this signal, then the current
// HTTP I/O will be stopped after this signal emission finished, and msg's
// connection will be closed.
func (msg *Message) ConnectGotChunk(f func(chunk *Buffer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "got-chunk", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectGotChunk), f)
}

// ConnectGotHeaders is emitted after receiving all message headers for a
// message. (For a client-side message, this is after receiving the Status-Line
// and response headers; for a server-side message, it is after receiving the
// Request-Line and request headers.)
//
// See also soup_message_add_header_handler() and
// soup_message_add_status_code_handler(), which can be used to connect to a
// subset of emissions of this signal.
//
// If you cancel or requeue msg while processing this signal, then the current
// HTTP I/O will be stopped after this signal emission finished, and msg's
// connection will be closed. (If you need to requeue a message--eg, after
// handling authentication or redirection--it is usually better to requeue it
// from a Message::got_body handler rather than a Message::got_headers handler,
// so that the existing HTTP connection can be reused.).
func (msg *Message) ConnectGotHeaders(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "got-headers", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectGotHeaders), f)
}

// ConnectGotInformational is emitted after receiving a 1xx (Informational)
// response for a (client-side) message. The response_headers will be filled
// in with the headers associated with the informational response; however,
// those header values will be erased after this signal is done.
//
// If you cancel or requeue msg while processing this signal, then the current
// HTTP I/O will be stopped after this signal emission finished, and msg's
// connection will be closed.
func (msg *Message) ConnectGotInformational(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "got-informational", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectGotInformational), f)
}

// ConnectNetworkEvent is emitted to indicate that some network-related event
// related to msg has occurred. This essentially proxies the Client::event
// signal, but only for events that occur while msg "owns" the connection; if
// msg is sent on an existing persistent connection, then this signal will not
// be emitted. (If you want to force the message to be sent on a new connection,
// set the SOUP_MESSAGE_NEW_CONNECTION flag on it.)
//
// See Client::event for more information on what the different values of event
// correspond to, and what connection will be in each case.
func (msg *Message) ConnectNetworkEvent(f func(event gio.SocketClientEvent, connection gio.IOStreamer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "network-event", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectNetworkEvent), f)
}

// ConnectRestarted is emitted when a request that was already sent once is
// now being sent again (eg, because the first attempt received a redirection
// response, or because we needed to use authentication).
func (msg *Message) ConnectRestarted(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "restarted", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectRestarted), f)
}

// ConnectStarting is emitted just before a message is sent.
func (msg *Message) ConnectStarting(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "starting", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectStarting), f)
}

// ConnectWroteBody is emitted immediately after writing the complete body for a
// message. (For a client-side message, this means that libsoup is done writing
// and is now waiting for the response from the server. For a server-side
// message, this means that libsoup has finished writing the response and is
// nearly done with the message.).
func (msg *Message) ConnectWroteBody(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-body", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectWroteBody), f)
}

// ConnectWroteBodyData is emitted immediately after writing a portion of the
// message body to the network.
//
// Unlike Message::wrote_chunk, this is emitted after every successful write()
// call, not only after finishing a complete "chunk".
func (msg *Message) ConnectWroteBodyData(f func(chunk *Buffer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-body-data", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectWroteBodyData), f)
}

// ConnectWroteChunk is emitted immediately after writing a body chunk for a
// message.
//
// Note that this signal is not parallel to Message::got_chunk; it is emitted
// only when a complete chunk (added with soup_message_body_append() or
// soup_message_body_append_buffer()) has been written. To get more useful
// continuous progress information, use Message::wrote_body_data.
func (msg *Message) ConnectWroteChunk(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-chunk", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectWroteChunk), f)
}

// ConnectWroteHeaders is emitted immediately after writing the headers for
// a message. (For a client-side message, this is after writing the request
// headers; for a server-side message, it is after writing the response
// headers.).
func (msg *Message) ConnectWroteHeaders(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-headers", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectWroteHeaders), f)
}

// ConnectWroteInformational is emitted immediately after writing a 1xx
// (Informational) response for a (server-side) message.
func (msg *Message) ConnectWroteInformational(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(msg, "wrote-informational", false, unsafe.Pointer(C._gotk4_soup2_Message_ConnectWroteInformational), f)
}

// NewMessage creates a new empty Message, which will connect to uri.
//
// The function takes the following parameters:
//
//   - method: HTTP method for the created request.
//   - uriString: destination endpoint (as a string).
//
// The function returns the following values:
//
//   - message (optional): new Message (or NULL if uri could not be parsed).
//
func NewMessage(method, uriString string) *Message {
	var _arg1 *C.char        // out
	var _arg2 *C.char        // out
	var _cret *C.SoupMessage // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.soup_message_new(_arg1, _arg2)
	runtime.KeepAlive(method)
	runtime.KeepAlive(uriString)

	var _message *Message // out

	if _cret != nil {
		_message = wrapMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _message
}

// NewMessageFromURI creates a new empty Message, which will connect to uri.
//
// The function takes the following parameters:
//
//   - method: HTTP method for the created request.
//   - uri: destination endpoint (as a URI).
//
// The function returns the following values:
//
//   - message: new Message.
//
func NewMessageFromURI(method string, uri *URI) *Message {
	var _arg1 *C.char        // out
	var _arg2 *C.SoupURI     // out
	var _cret *C.SoupMessage // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.soup_message_new_from_uri(_arg1, _arg2)
	runtime.KeepAlive(method)
	runtime.KeepAlive(uri)

	var _message *Message // out

	_message = wrapMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _message
}

// The function takes the following parameters:
//
//   - contentType
//   - params
//
func (msg *Message) ContentSniffed(contentType string, params map[unsafe.Pointer]unsafe.Pointer) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.char        // out
	var _arg2 *C.GHashTable  // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range params {
		var kdst *C.gpointer // out
		var vdst *C.gpointer // out
		kdst = (*C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (*C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)

	C.soup_message_content_sniffed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(params)
}

// DisableFeature: this disables the actions of SessionFeature<!-- -->s with
// the given feature_type (or a subclass of that type) on msg, so that msg is
// processed as though the feature(s) hadn't been added to the session. Eg,
// passing UP_TYPE_CONTENT_SNIFFER for feature_type will disable Content-Type
// sniffing on the message.
//
// You must call this before queueing msg on a session; calling it on a message
// that has already been queued is undefined. In particular, you cannot call
// this on a message that is being requeued after a redirect or authentication.
//
// The function takes the following parameters:
//
//   - featureType of a SessionFeature.
//
func (msg *Message) DisableFeature(featureType coreglib.Type) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.GType        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.GType(featureType)

	C.soup_message_disable_feature(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(featureType)
}

func (msg *Message) Finished() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_message_finished(_arg0)
	runtime.KeepAlive(msg)
}

// Address gets the address msg's URI points to. After first setting the URI
// on a message, this will be unresolved, although the message's session will
// resolve it before sending the message.
//
// The function returns the following values:
//
//   - address msg's URI points to.
//
func (msg *Message) Address() *Address {
	var _arg0 *C.SoupMessage // out
	var _cret *C.SoupAddress // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_address(_arg0)
	runtime.KeepAlive(msg)

	var _address *Address // out

	_address = wrapAddress(coreglib.Take(unsafe.Pointer(_cret)))

	return _address
}

// FirstParty gets msg's first-party URI.
//
// The function returns the following values:
//
//   - urI msg's first party URI.
//
func (msg *Message) FirstParty() *URI {
	var _arg0 *C.SoupMessage // out
	var _cret *C.SoupURI     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_first_party(_arg0)
	runtime.KeepAlive(msg)

	var _urI *URI // out

	_urI = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _urI
}

// Flags gets the flags on msg.
//
// The function returns the following values:
//
//   - messageFlags: flags.
//
func (msg *Message) Flags() MessageFlags {
	var _arg0 *C.SoupMessage     // out
	var _cret C.SoupMessageFlags // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_flags(_arg0)
	runtime.KeepAlive(msg)

	var _messageFlags MessageFlags // out

	_messageFlags = MessageFlags(_cret)

	return _messageFlags
}

// HTTPVersion gets the HTTP version of msg. This is the minimum of the version
// from the request and the version from the response.
//
// The function returns the following values:
//
//   - httpVersion: HTTP version.
//
func (msg *Message) HTTPVersion() HTTPVersion {
	var _arg0 *C.SoupMessage    // out
	var _cret C.SoupHTTPVersion // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_http_version(_arg0)
	runtime.KeepAlive(msg)

	var _httpVersion HTTPVersion // out

	_httpVersion = HTTPVersion(_cret)

	return _httpVersion
}

// HTTPSStatus: if msg is using https (or attempted to use https but got
// SOUP_STATUS_SSL_FAILED), this retrieves the Certificate associated with its
// connection, and the CertificateFlags showing what problems, if any, have been
// found with that certificate.
//
// <note><para>This is only meaningful with messages processed by a Session and
// is not useful for messages received by a Server</para></note>.
//
// The function returns the following values:
//
//   - certificate msg's TLS certificate.
//   - errors: verification status of certificate.
//   - ok: TRUE if msg used/attempted https, FALSE if not.
//
func (msg *Message) HTTPSStatus() (gio.TLSCertificater, gio.TLSCertificateFlags, bool) {
	var _arg0 *C.SoupMessage         // out
	var _arg1 *C.GTlsCertificate     // in
	var _arg2 C.GTlsCertificateFlags // in
	var _cret C.gboolean             // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_https_status(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(msg)

	var _certificate gio.TLSCertificater // out
	var _errors gio.TLSCertificateFlags  // out
	var _ok bool                         // out

	{
		objptr := unsafe.Pointer(_arg1)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.TLSCertificater)
			return ok
		})
		rv, ok := casted.(gio.TLSCertificater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
		}
		_certificate = rv
	}
	_errors = gio.TLSCertificateFlags(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _certificate, _errors, _ok
}

// The function returns the following values:
//
func (msg *Message) IsTopLevelNavigation() bool {
	var _arg0 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_is_top_level_navigation(_arg0)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Priority retrieves the MessagePriority. If not set this value defaults to
// UP_MESSAGE_PRIORITY_NORMAL.
//
// The function returns the following values:
//
//   - messagePriority: priority of the message.
//
func (msg *Message) Priority() MessagePriority {
	var _arg0 *C.SoupMessage        // out
	var _cret C.SoupMessagePriority // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_priority(_arg0)
	runtime.KeepAlive(msg)

	var _messagePriority MessagePriority // out

	_messagePriority = MessagePriority(_cret)

	return _messagePriority
}

// SiteForCookies gets msg's site for cookies URI.
//
// The function returns the following values:
//
//   - urI msg's site for cookies URI.
//
func (msg *Message) SiteForCookies() *URI {
	var _arg0 *C.SoupMessage // out
	var _cret *C.SoupURI     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_site_for_cookies(_arg0)
	runtime.KeepAlive(msg)

	var _urI *URI // out

	_urI = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _urI
}

// SoupRequest: if msg is associated with a Request, this returns that request.
// Otherwise it returns NULL.
//
// The function returns the following values:
//
//   - request msg's associated Request.
//
func (msg *Message) SoupRequest() *Request {
	var _arg0 *C.SoupMessage // out
	var _cret *C.SoupRequest // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_soup_request(_arg0)
	runtime.KeepAlive(msg)

	var _request *Request // out

	_request = wrapRequest(coreglib.Take(unsafe.Pointer(_cret)))

	return _request
}

// URI gets msg's URI.
//
// The function returns the following values:
//
//   - urI: URI msg is targeted for.
//
func (msg *Message) URI() *URI {
	var _arg0 *C.SoupMessage // out
	var _cret *C.SoupURI     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_get_uri(_arg0)
	runtime.KeepAlive(msg)

	var _urI *URI // out

	_urI = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _urI
}

func (msg *Message) GotBody() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_message_got_body(_arg0)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (msg *Message) GotChunk(chunk *Buffer) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.SoupBuffer  // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = (*C.SoupBuffer)(gextras.StructNative(unsafe.Pointer(chunk)))

	C.soup_message_got_chunk(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(chunk)
}

func (msg *Message) GotHeaders() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_message_got_headers(_arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) GotInformational() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_message_got_informational(_arg0)
	runtime.KeepAlive(msg)
}

// IsFeatureDisabled: get whether SessionFeature<!-- -->s of the given
// feature_type (or a subclass of that type) are disabled on msg. See
// soup_message_disable_feature().
//
// The function takes the following parameters:
//
//   - featureType of a SessionFeature.
//
// The function returns the following values:
//
//   - ok: TRUE if feature is disabled, or FALSE otherwise.
//
func (msg *Message) IsFeatureDisabled(featureType coreglib.Type) bool {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.GType        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_message_is_feature_disabled(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(featureType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsKeepalive determines whether or not msg's connection can be kept alive for
// further requests after processing msg, based on the HTTP version, Connection
// header, etc.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE.
//
func (msg *Message) IsKeepalive() bool {
	var _arg0 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_message_is_keepalive(_arg0)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (msg *Message) Restarted() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_message_restarted(_arg0)
	runtime.KeepAlive(msg)
}

// SetChunkAllocator sets an alternate chunk-allocation function to use when
// reading msg's body when using the traditional (ie, non-Request<!-- -->-based)
// API. Every time data is available to read, libsoup will call allocator,
// which should return a Buffer. (See ChunkAllocator for additional details.)
// Libsoup will then read data from the network into that buffer, and update the
// buffer's <literal>length</literal> to indicate how much data it read.
//
// Generally, a custom chunk allocator would be used in conjunction with
// soup_message_body_set_accumulate() FALSE and Message::got_chunk, as part
// of a strategy to avoid unnecessary copying of data. However, you cannot
// assume that every call to the allocator will be followed by a call to your
// Message::got_chunk handler; if an I/O error occurs, then the buffer will be
// unreffed without ever having been used. If your buffer-allocation strategy
// requires special cleanup, use soup_buffer_new_with_owner() rather than doing
// the cleanup from the Message::got_chunk handler.
//
// The other thing to remember when using non-accumulating message bodies is
// that the buffer passed to the Message::got_chunk handler will be unreffed
// after the handler returns, just as it would be in the non-custom-allocated
// case. If you want to hand the chunk data off to some other part of your
// program to use later, you'll need to ref the Buffer (or its owner, in the
// soup_buffer_new_with_owner() case) to ensure that the data remains valid.
//
// Deprecated: Request provides a much simpler API that lets you read the
// response directly into your own buffers without needing to mess with
// callbacks, pausing/unpausing, etc.
//
// The function takes the following parameters:
//
//   - allocator: chunk allocator callback.
//
func (msg *Message) SetChunkAllocator(allocator ChunkAllocator) {
	var _arg0 *C.SoupMessage       // out
	var _arg1 C.SoupChunkAllocator // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = (*[0]byte)(C._gotk4_soup2_ChunkAllocator)
	_arg2 = C.gpointer(gbox.Assign(allocator))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_message_set_chunk_allocator(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(allocator)
}

// SetFirstParty sets first_party as the main document URI for msg.
// For details of when and how this is used refer to the documentation for
// CookieJarAcceptPolicy.
//
// The function takes the following parameters:
//
//   - firstParty for the msg's first party.
//
func (msg *Message) SetFirstParty(firstParty *URI) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.SoupURI     // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(firstParty)))

	C.soup_message_set_first_party(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(firstParty)
}

// SetFlags sets the specified flags on msg.
//
// The function takes the following parameters:
//
//   - flags: set of MessageFlags values.
//
func (msg *Message) SetFlags(flags MessageFlags) {
	var _arg0 *C.SoupMessage     // out
	var _arg1 C.SoupMessageFlags // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.SoupMessageFlags(flags)

	C.soup_message_set_flags(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(flags)
}

// SetHTTPVersion sets the HTTP version on msg. The default version is
// SOUP_HTTP_1_1. Setting it to SOUP_HTTP_1_0 will prevent certain functionality
// from being used.
//
// The function takes the following parameters:
//
//   - version: HTTP version.
//
func (msg *Message) SetHTTPVersion(version HTTPVersion) {
	var _arg0 *C.SoupMessage    // out
	var _arg1 C.SoupHTTPVersion // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.SoupHTTPVersion(version)

	C.soup_message_set_http_version(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(version)
}

// SetIsTopLevelNavigation: see the same-site spec
// (https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for more
// information.
//
// The function takes the following parameters:
//
//   - isTopLevelNavigation: if TRUE indicate the current request is a top-level
//     navigation.
//
func (msg *Message) SetIsTopLevelNavigation(isTopLevelNavigation bool) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if isTopLevelNavigation {
		_arg1 = C.TRUE
	}

	C.soup_message_set_is_top_level_navigation(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(isTopLevelNavigation)
}

// SetPriority sets the priority of a message. Note that this won't have any
// effect unless used before the message is added to the session's message
// processing queue.
//
// The message will be placed just before any other previously added message
// with lower priority (messages with the same priority are processed on a FIFO
// basis).
//
// Setting priorities does not currently work with SessionSync (or with
// synchronous messages on a plain Session) because in the synchronous/blocking
// case, priority ends up being determined semi-randomly by thread scheduling.
//
// The function takes the following parameters:
//
//   - priority: MessagePriority.
//
func (msg *Message) SetPriority(priority MessagePriority) {
	var _arg0 *C.SoupMessage        // out
	var _arg1 C.SoupMessagePriority // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.SoupMessagePriority(priority)

	C.soup_message_set_priority(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(priority)
}

// SetRedirect sets msg's status_code to status_code and adds a Location header
// pointing to redirect_uri. Use this from a Server when you want to redirect
// the client to another URI.
//
// redirect_uri can be a relative URI, in which case it is interpreted relative
// to msg's current URI. In particular, if redirect_uri is just a path, it will
// replace the path <emphasis>and query</emphasis> of msg's URI.
//
// The function takes the following parameters:
//
//   - statusCode: 3xx status code.
//   - redirectUri: URI to redirect msg to.
//
func (msg *Message) SetRedirect(statusCode uint, redirectUri string) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.guint        // out
	var _arg2 *C.char        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.guint(statusCode)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(redirectUri)))
	defer C.free(unsafe.Pointer(_arg2))

	C.soup_message_set_redirect(_arg0, _arg1, _arg2)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(statusCode)
	runtime.KeepAlive(redirectUri)
}

// SetRequest: convenience function to set the request body of a Message.
// If content_type is NULL, the request body must be empty as well.
//
// The function takes the following parameters:
//
//   - contentType (optional): MIME Content-Type of the body.
//   - reqUse describing how to handle req_body.
//   - reqBody (optional): a data buffer containing the body of the message
//     request.
//
func (msg *Message) SetRequest(contentType string, reqUse MemoryUse, reqBody string) {
	var _arg0 *C.SoupMessage  // out
	var _arg1 *C.char         // out
	var _arg2 C.SoupMemoryUse // out
	var _arg3 *C.char         // out
	var _arg4 C.gsize

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if contentType != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.SoupMemoryUse(reqUse)
	_arg4 = (C.gsize)(len(reqBody))
	_arg3 = (*C.char)(C.calloc(C.size_t((len(reqBody) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg3)), len(reqBody)), reqBody)
	defer C.free(unsafe.Pointer(_arg3))

	C.soup_message_set_request(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(reqUse)
	runtime.KeepAlive(reqBody)
}

// SetResponse: convenience function to set the response body of a Message.
// If content_type is NULL, the response body must be empty as well.
//
// The function takes the following parameters:
//
//   - contentType (optional): MIME Content-Type of the body.
//   - respUse describing how to handle resp_body.
//   - respBody (optional): a data buffer containing the body of the message
//     response.
//
func (msg *Message) SetResponse(contentType string, respUse MemoryUse, respBody string) {
	var _arg0 *C.SoupMessage  // out
	var _arg1 *C.char         // out
	var _arg2 C.SoupMemoryUse // out
	var _arg3 *C.char         // out
	var _arg4 C.gsize

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if contentType != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.SoupMemoryUse(respUse)
	_arg4 = (C.gsize)(len(respBody))
	_arg3 = (*C.char)(C.calloc(C.size_t((len(respBody) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg3)), len(respBody)), respBody)
	defer C.free(unsafe.Pointer(_arg3))

	C.soup_message_set_response(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(respUse)
	runtime.KeepAlive(respBody)
}

// SetSiteForCookies sets site_for_cookies as the policy URL for same-site
// cookies for msg.
//
// It is either the URL of the top-level document or NULL depending on whether
// the registrable domain of this document's URL matches the registrable domain
// of its parent's/opener's URL. For the top-level document it is set to the
// document's URL.
//
// See the same-site spec
// (https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for more
// information.
//
// The function takes the following parameters:
//
//   - siteForCookies (optional) for the msg's site for cookies.
//
func (msg *Message) SetSiteForCookies(siteForCookies *URI) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.SoupURI     // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if siteForCookies != nil {
		_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(siteForCookies)))
	}

	C.soup_message_set_site_for_cookies(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(siteForCookies)
}

// SetStatus sets msg's status code to status_code. If status_code is a known
// value, it will also set msg's reason_phrase.
//
// The function takes the following parameters:
//
//   - statusCode: HTTP status code.
//
func (msg *Message) SetStatus(statusCode uint) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.guint        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.guint(statusCode)

	C.soup_message_set_status(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(statusCode)
}

// SetStatusFull sets msg's status code and reason phrase.
//
// The function takes the following parameters:
//
//   - statusCode: HTTP status code.
//   - reasonPhrase: description of the status.
//
func (msg *Message) SetStatusFull(statusCode uint, reasonPhrase string) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.guint        // out
	var _arg2 *C.char        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = C.guint(statusCode)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(reasonPhrase)))
	defer C.free(unsafe.Pointer(_arg2))

	C.soup_message_set_status_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(statusCode)
	runtime.KeepAlive(reasonPhrase)
}

// SetURI sets msg's URI to uri. If msg has already been sent and you want to
// re-send it with the new URI, you need to call soup_session_requeue_message().
//
// The function takes the following parameters:
//
//   - uri: new URI.
//
func (msg *Message) SetURI(uri *URI) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.SoupURI     // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))

	C.soup_message_set_uri(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(uri)
}

func (msg *Message) Starting() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_message_starting(_arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) WroteBody() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_message_wrote_body(_arg0)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (msg *Message) WroteBodyData(chunk *Buffer) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.SoupBuffer  // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = (*C.SoupBuffer)(gextras.StructNative(unsafe.Pointer(chunk)))

	C.soup_message_wrote_body_data(_arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(chunk)
}

func (msg *Message) WroteChunk() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_message_wrote_chunk(_arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) WroteHeaders() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_message_wrote_headers(_arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) WroteInformational() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_message_wrote_informational(_arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) finished() {
	gclass := (*C.SoupMessageClass)(coreglib.PeekParentClass(msg))
	fnarg := gclass.finished

	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup2_Message_virtual_finished(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) gotBody() {
	gclass := (*C.SoupMessageClass)(coreglib.PeekParentClass(msg))
	fnarg := gclass.got_body

	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup2_Message_virtual_got_body(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (msg *Message) gotChunk(chunk *Buffer) {
	gclass := (*C.SoupMessageClass)(coreglib.PeekParentClass(msg))
	fnarg := gclass.got_chunk

	var _arg0 *C.SoupMessage // out
	var _arg1 *C.SoupBuffer  // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg1 = (*C.SoupBuffer)(gextras.StructNative(unsafe.Pointer(chunk)))

	C._gotk4_soup2_Message_virtual_got_chunk(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(chunk)
}

func (msg *Message) gotHeaders() {
	gclass := (*C.SoupMessageClass)(coreglib.PeekParentClass(msg))
	fnarg := gclass.got_headers

	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup2_Message_virtual_got_headers(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) gotInformational() {
	gclass := (*C.SoupMessageClass)(coreglib.PeekParentClass(msg))
	fnarg := gclass.got_informational

	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup2_Message_virtual_got_informational(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) restarted() {
	gclass := (*C.SoupMessageClass)(coreglib.PeekParentClass(msg))
	fnarg := gclass.restarted

	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup2_Message_virtual_restarted(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) starting() {
	gclass := (*C.SoupMessageClass)(coreglib.PeekParentClass(msg))
	fnarg := gclass.starting

	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup2_Message_virtual_starting(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) wroteBody() {
	gclass := (*C.SoupMessageClass)(coreglib.PeekParentClass(msg))
	fnarg := gclass.wrote_body

	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup2_Message_virtual_wrote_body(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) wroteChunk() {
	gclass := (*C.SoupMessageClass)(coreglib.PeekParentClass(msg))
	fnarg := gclass.wrote_chunk

	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup2_Message_virtual_wrote_chunk(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) wroteHeaders() {
	gclass := (*C.SoupMessageClass)(coreglib.PeekParentClass(msg))
	fnarg := gclass.wrote_headers

	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup2_Message_virtual_wrote_headers(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(msg)
}

func (msg *Message) wroteInformational() {
	gclass := (*C.SoupMessageClass)(coreglib.PeekParentClass(msg))
	fnarg := gclass.wrote_informational

	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup2_Message_virtual_wrote_informational(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(msg)
}

// MessageClass: instance of this type is always passed by reference.
type MessageClass struct {
	*messageClass
}

// messageClass is the struct that's finalized.
type messageClass struct {
	native *C.SoupMessageClass
}
