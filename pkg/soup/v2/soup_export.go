// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <libsoup/soup.h>
import "C"

//export _gotk4_soup2_AuthClass_authenticate
func _gotk4_soup2_AuthClass_authenticate(arg0 *C.SoupAuth, arg1 *C.char, arg2 *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.Authenticate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.Authenticate, got none")
	}

	var _username string // out
	var _password string // out

	_username = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_password = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.Authenticate(_username, _password)
}

//export _gotk4_soup2_AuthClass_can_authenticate
func _gotk4_soup2_AuthClass_can_authenticate(arg0 *C.SoupAuth) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.CanAuthenticate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.CanAuthenticate, got none")
	}

	ok := overrides.CanAuthenticate()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup2_AuthClass_get_authorization
func _gotk4_soup2_AuthClass_get_authorization(arg0 *C.SoupAuth, arg1 *C.SoupMessage) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.Authorization == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.Authorization, got none")
	}

	var _msg *Message // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	utf8 := overrides.Authorization(_msg)

	var _ string

	cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_soup2_AuthClass_get_protection_space
func _gotk4_soup2_AuthClass_get_protection_space(arg0 *C.SoupAuth, arg1 *C.SoupURI) (cret *C.GSList) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.ProtectionSpace == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.ProtectionSpace, got none")
	}

	var _sourceUri *URI // out

	_sourceUri = (*URI)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	sList := overrides.ProtectionSpace(_sourceUri)

	var _ []string

	for i := len(sList) - 1; i >= 0; i-- {
		src := sList[i]
		var dst *C.gchar // out
		dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
		cret = C.g_slist_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}

	return cret
}

//export _gotk4_soup2_AuthClass_is_authenticated
func _gotk4_soup2_AuthClass_is_authenticated(arg0 *C.SoupAuth) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.IsAuthenticated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.IsAuthenticated, got none")
	}

	ok := overrides.IsAuthenticated()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup2_AuthClass_is_ready
func _gotk4_soup2_AuthClass_is_ready(arg0 *C.SoupAuth, arg1 *C.SoupMessage) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.IsReady == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.IsReady, got none")
	}

	var _msg *Message // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	ok := overrides.IsReady(_msg)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup2_AuthClass_update
func _gotk4_soup2_AuthClass_update(arg0 *C.SoupAuth, arg1 *C.SoupMessage, arg2 *C.GHashTable) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthOverrides](instance0)
	if overrides.Update == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthOverrides.Update, got none")
	}

	var _msg *Message                                 // out
	var _authHeader map[unsafe.Pointer]unsafe.Pointer // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_authHeader = make(map[unsafe.Pointer]unsafe.Pointer, gextras.HashTableSize(unsafe.Pointer(arg2)))
	gextras.MoveHashTable(unsafe.Pointer(arg2), false, func(k, v unsafe.Pointer) {
		ksrc := *(**C.gpointer)(k)
		vsrc := *(**C.gpointer)(v)
		var kdst unsafe.Pointer // out
		var vdst unsafe.Pointer // out
		kdst = (unsafe.Pointer)(unsafe.Pointer(ksrc))
		vdst = (unsafe.Pointer)(unsafe.Pointer(vsrc))
		_authHeader[kdst] = vdst
	})

	ok := overrides.Update(_msg, _authHeader)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup2_AuthDomainClass_accepts
func _gotk4_soup2_AuthDomainClass_accepts(arg0 *C.SoupAuthDomain, arg1 *C.SoupMessage, arg2 *C.char) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthDomainOverrides](instance0)
	if overrides.Accepts == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthDomainOverrides.Accepts, got none")
	}

	var _msg *Message  // out
	var _header string // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_header = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	utf8 := overrides.Accepts(_msg, _header)

	var _ string

	cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_soup2_AuthDomainClass_challenge
func _gotk4_soup2_AuthDomainClass_challenge(arg0 *C.SoupAuthDomain, arg1 *C.SoupMessage) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthDomainOverrides](instance0)
	if overrides.Challenge == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthDomainOverrides.Challenge, got none")
	}

	var _msg *Message // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	utf8 := overrides.Challenge(_msg)

	var _ string

	cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_soup2_AuthDomainClass_check_password
func _gotk4_soup2_AuthDomainClass_check_password(arg0 *C.SoupAuthDomain, arg1 *C.SoupMessage, arg2 *C.char, arg3 *C.char) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthDomainOverrides](instance0)
	if overrides.CheckPassword == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthDomainOverrides.CheckPassword, got none")
	}

	var _msg *Message    // out
	var _username string // out
	var _password string // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_username = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_password = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	ok := overrides.CheckPassword(_msg, _username, _password)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup2_AuthManagerClass_authenticate
func _gotk4_soup2_AuthManagerClass_authenticate(arg0 *C.SoupAuthManager, arg1 *C.SoupMessage, arg2 *C.SoupAuth, arg3 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AuthManagerOverrides](instance0)
	if overrides.Authenticate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AuthManagerOverrides.Authenticate, got none")
	}

	var _msg *Message  // out
	var _auth Auther   // out
	var _retrying bool // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type soup.Auther is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Auther)
			return ok
		})
		rv, ok := casted.(Auther)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching soup.Auther")
		}
		_auth = rv
	}
	if arg3 != 0 {
		_retrying = true
	}

	overrides.Authenticate(_msg, _auth, _retrying)
}

//export _gotk4_soup2_CacheClass_get_cacheability
func _gotk4_soup2_CacheClass_get_cacheability(arg0 *C.SoupCache, arg1 *C.SoupMessage) (cret C.SoupCacheability) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CacheOverrides](instance0)
	if overrides.Cacheability == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CacheOverrides.Cacheability, got none")
	}

	var _msg *Message // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	cacheability := overrides.Cacheability(_msg)

	var _ Cacheability

	cret = C.SoupCacheability(cacheability)

	return cret
}

//export _gotk4_soup2_ContentSnifferClass_get_buffer_size
func _gotk4_soup2_ContentSnifferClass_get_buffer_size(arg0 *C.SoupContentSniffer) (cret C.gsize) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContentSnifferOverrides](instance0)
	if overrides.BufferSize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContentSnifferOverrides.BufferSize, got none")
	}

	gsize := overrides.BufferSize()

	var _ uint

	cret = C.gsize(gsize)

	return cret
}

//export _gotk4_soup2_ContentSnifferClass_sniff
func _gotk4_soup2_ContentSnifferClass_sniff(arg0 *C.SoupContentSniffer, arg1 *C.SoupMessage, arg2 *C.SoupBuffer, arg3 **C.GHashTable) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ContentSnifferOverrides](instance0)
	if overrides.Sniff == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ContentSnifferOverrides.Sniff, got none")
	}

	var _msg *Message   // out
	var _buffer *Buffer // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	params, utf8 := overrides.Sniff(_msg, _buffer)

	var _ map[string]string
	var _ string

	if params != nil {
		*arg3 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
		for ksrc, vsrc := range params {
			var kdst *C.gchar // out
			var vdst *C.gchar // out
			kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
			defer C.free(unsafe.Pointer(kdst))
			vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
			defer C.free(unsafe.Pointer(vdst))
			C.g_hash_table_insert(*arg3, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
		}
	}
	cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_soup2_CookieJarClass_changed
func _gotk4_soup2_CookieJarClass_changed(arg0 *C.SoupCookieJar, arg1 *C.SoupCookie, arg2 *C.SoupCookie) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CookieJarOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CookieJarOverrides.Changed, got none")
	}

	var _oldCookie *Cookie // out
	var _newCookie *Cookie // out

	_oldCookie = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_newCookie = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.Changed(_oldCookie, _newCookie)
}

//export _gotk4_soup2_CookieJarClass_is_persistent
func _gotk4_soup2_CookieJarClass_is_persistent(arg0 *C.SoupCookieJar) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CookieJarOverrides](instance0)
	if overrides.IsPersistent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CookieJarOverrides.IsPersistent, got none")
	}

	ok := overrides.IsPersistent()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup2_CookieJarClass_save
func _gotk4_soup2_CookieJarClass_save(arg0 *C.SoupCookieJar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CookieJarOverrides](instance0)
	if overrides.Save == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CookieJarOverrides.Save, got none")
	}

	overrides.Save()
}

//export _gotk4_soup2_HSTSEnforcerClass_changed
func _gotk4_soup2_HSTSEnforcerClass_changed(arg0 *C.SoupHSTSEnforcer, arg1 *C.SoupHSTSPolicy, arg2 *C.SoupHSTSPolicy) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HSTSEnforcerOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HSTSEnforcerOverrides.Changed, got none")
	}

	var _oldPolicy *HSTSPolicy // out
	var _newPolicy *HSTSPolicy // out

	_oldPolicy = (*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_newPolicy = (*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.Changed(_oldPolicy, _newPolicy)
}

//export _gotk4_soup2_HSTSEnforcerClass_has_valid_policy
func _gotk4_soup2_HSTSEnforcerClass_has_valid_policy(arg0 *C.SoupHSTSEnforcer, arg1 *C.char) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HSTSEnforcerOverrides](instance0)
	if overrides.HasValidPolicy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HSTSEnforcerOverrides.HasValidPolicy, got none")
	}

	var _domain string // out

	_domain = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := overrides.HasValidPolicy(_domain)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup2_HSTSEnforcerClass_hsts_enforced
func _gotk4_soup2_HSTSEnforcerClass_hsts_enforced(arg0 *C.SoupHSTSEnforcer, arg1 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HSTSEnforcerOverrides](instance0)
	if overrides.HstsEnforced == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HSTSEnforcerOverrides.HstsEnforced, got none")
	}

	var _message *Message // out

	_message = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.HstsEnforced(_message)
}

//export _gotk4_soup2_HSTSEnforcerClass_is_persistent
func _gotk4_soup2_HSTSEnforcerClass_is_persistent(arg0 *C.SoupHSTSEnforcer) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[HSTSEnforcerOverrides](instance0)
	if overrides.IsPersistent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected HSTSEnforcerOverrides.IsPersistent, got none")
	}

	ok := overrides.IsPersistent()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_soup2_MessageClass_finished
func _gotk4_soup2_MessageClass_finished(arg0 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MessageOverrides](instance0)
	if overrides.Finished == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MessageOverrides.Finished, got none")
	}

	overrides.Finished()
}

//export _gotk4_soup2_MessageClass_got_body
func _gotk4_soup2_MessageClass_got_body(arg0 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MessageOverrides](instance0)
	if overrides.GotBody == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MessageOverrides.GotBody, got none")
	}

	overrides.GotBody()
}

//export _gotk4_soup2_MessageClass_got_chunk
func _gotk4_soup2_MessageClass_got_chunk(arg0 *C.SoupMessage, arg1 *C.SoupBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MessageOverrides](instance0)
	if overrides.GotChunk == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MessageOverrides.GotChunk, got none")
	}

	var _chunk *Buffer // out

	_chunk = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.GotChunk(_chunk)
}

//export _gotk4_soup2_MessageClass_got_headers
func _gotk4_soup2_MessageClass_got_headers(arg0 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MessageOverrides](instance0)
	if overrides.GotHeaders == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MessageOverrides.GotHeaders, got none")
	}

	overrides.GotHeaders()
}

//export _gotk4_soup2_MessageClass_got_informational
func _gotk4_soup2_MessageClass_got_informational(arg0 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MessageOverrides](instance0)
	if overrides.GotInformational == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MessageOverrides.GotInformational, got none")
	}

	overrides.GotInformational()
}

//export _gotk4_soup2_MessageClass_restarted
func _gotk4_soup2_MessageClass_restarted(arg0 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MessageOverrides](instance0)
	if overrides.Restarted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MessageOverrides.Restarted, got none")
	}

	overrides.Restarted()
}

//export _gotk4_soup2_MessageClass_starting
func _gotk4_soup2_MessageClass_starting(arg0 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MessageOverrides](instance0)
	if overrides.Starting == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MessageOverrides.Starting, got none")
	}

	overrides.Starting()
}

//export _gotk4_soup2_MessageClass_wrote_body
func _gotk4_soup2_MessageClass_wrote_body(arg0 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MessageOverrides](instance0)
	if overrides.WroteBody == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MessageOverrides.WroteBody, got none")
	}

	overrides.WroteBody()
}

//export _gotk4_soup2_MessageClass_wrote_chunk
func _gotk4_soup2_MessageClass_wrote_chunk(arg0 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MessageOverrides](instance0)
	if overrides.WroteChunk == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MessageOverrides.WroteChunk, got none")
	}

	overrides.WroteChunk()
}

//export _gotk4_soup2_MessageClass_wrote_headers
func _gotk4_soup2_MessageClass_wrote_headers(arg0 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MessageOverrides](instance0)
	if overrides.WroteHeaders == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MessageOverrides.WroteHeaders, got none")
	}

	overrides.WroteHeaders()
}

//export _gotk4_soup2_MessageClass_wrote_informational
func _gotk4_soup2_MessageClass_wrote_informational(arg0 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MessageOverrides](instance0)
	if overrides.WroteInformational == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MessageOverrides.WroteInformational, got none")
	}

	overrides.WroteInformational()
}

//export _gotk4_soup2_RequestClass_check_uri
func _gotk4_soup2_RequestClass_check_uri(arg0 *C.SoupRequest, arg1 *C.SoupURI, _cerr **C.GError) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RequestOverrides](instance0)
	if overrides.CheckURI == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RequestOverrides.CheckURI, got none")
	}

	var _uri *URI // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	_goerr := overrides.CheckURI(_uri)

	var _ error

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_soup2_RequestClass_get_content_length
func _gotk4_soup2_RequestClass_get_content_length(arg0 *C.SoupRequest) (cret C.goffset) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RequestOverrides](instance0)
	if overrides.ContentLength == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RequestOverrides.ContentLength, got none")
	}

	gint64 := overrides.ContentLength()

	var _ int64

	cret = C.goffset(gint64)

	return cret
}

//export _gotk4_soup2_RequestClass_get_content_type
func _gotk4_soup2_RequestClass_get_content_type(arg0 *C.SoupRequest) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RequestOverrides](instance0)
	if overrides.ContentType == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RequestOverrides.ContentType, got none")
	}

	utf8 := overrides.ContentType()

	var _ string

	if utf8 != "" {
		cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
		defer C.free(unsafe.Pointer(cret))
	}

	return cret
}

//export _gotk4_soup2_RequestClass_send
func _gotk4_soup2_RequestClass_send(arg0 *C.SoupRequest, arg1 *C.GCancellable, _cerr **C.GError) (cret *C.GInputStream) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RequestOverrides](instance0)
	if overrides.Send == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RequestOverrides.Send, got none")
	}

	var _cancellable context.Context // out

	if arg1 != nil {
		_cancellable = gcancel.NewCancellableContext(unsafe.Pointer(arg1))
	}

	inputStream, _goerr := overrides.Send(_cancellable)

	var _ gio.InputStreamer
	var _ error

	cret = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(inputStream).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(inputStream).Native()))
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_soup2_RequestClass_send_finish
func _gotk4_soup2_RequestClass_send_finish(arg0 *C.SoupRequest, arg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GInputStream) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RequestOverrides](instance0)
	if overrides.SendFinish == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RequestOverrides.SendFinish, got none")
	}

	var _result gio.AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.AsyncResulter)
			return ok
		})
		rv, ok := casted.(gio.AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	inputStream, _goerr := overrides.SendFinish(_result)

	var _ gio.InputStreamer
	var _ error

	cret = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(inputStream).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(inputStream).Native()))
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_soup2_ServerClass_request_aborted
func _gotk4_soup2_ServerClass_request_aborted(arg0 *C.SoupServer, arg1 *C.SoupMessage, arg2 *C.SoupClientContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ServerOverrides](instance0)
	if overrides.RequestAborted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ServerOverrides.RequestAborted, got none")
	}

	var _msg *Message          // out
	var _client *ClientContext // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_client = (*ClientContext)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.RequestAborted(_msg, _client)
}

//export _gotk4_soup2_ServerClass_request_finished
func _gotk4_soup2_ServerClass_request_finished(arg0 *C.SoupServer, arg1 *C.SoupMessage, arg2 *C.SoupClientContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ServerOverrides](instance0)
	if overrides.RequestFinished == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ServerOverrides.RequestFinished, got none")
	}

	var _msg *Message          // out
	var _client *ClientContext // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_client = (*ClientContext)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.RequestFinished(_msg, _client)
}

//export _gotk4_soup2_ServerClass_request_read
func _gotk4_soup2_ServerClass_request_read(arg0 *C.SoupServer, arg1 *C.SoupMessage, arg2 *C.SoupClientContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ServerOverrides](instance0)
	if overrides.RequestRead == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ServerOverrides.RequestRead, got none")
	}

	var _msg *Message          // out
	var _client *ClientContext // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_client = (*ClientContext)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.RequestRead(_msg, _client)
}

//export _gotk4_soup2_ServerClass_request_started
func _gotk4_soup2_ServerClass_request_started(arg0 *C.SoupServer, arg1 *C.SoupMessage, arg2 *C.SoupClientContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ServerOverrides](instance0)
	if overrides.RequestStarted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ServerOverrides.RequestStarted, got none")
	}

	var _msg *Message          // out
	var _client *ClientContext // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_client = (*ClientContext)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.RequestStarted(_msg, _client)
}

//export _gotk4_soup2_SessionClass_auth_required
func _gotk4_soup2_SessionClass_auth_required(arg0 *C.SoupSession, arg1 *C.SoupMessage, arg2 *C.SoupAuth, arg3 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SessionOverrides](instance0)
	if overrides.AuthRequired == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SessionOverrides.AuthRequired, got none")
	}

	var _msg *Message  // out
	var _auth Auther   // out
	var _retrying bool // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type soup.Auther is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Auther)
			return ok
		})
		rv, ok := casted.(Auther)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching soup.Auther")
		}
		_auth = rv
	}
	if arg3 != 0 {
		_retrying = true
	}

	overrides.AuthRequired(_msg, _auth, _retrying)
}

//export _gotk4_soup2_SessionClass_authenticate
func _gotk4_soup2_SessionClass_authenticate(arg0 *C.SoupSession, arg1 *C.SoupMessage, arg2 *C.SoupAuth, arg3 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SessionOverrides](instance0)
	if overrides.Authenticate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SessionOverrides.Authenticate, got none")
	}

	var _msg *Message  // out
	var _auth Auther   // out
	var _retrying bool // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type soup.Auther is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Auther)
			return ok
		})
		rv, ok := casted.(Auther)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching soup.Auther")
		}
		_auth = rv
	}
	if arg3 != 0 {
		_retrying = true
	}

	overrides.Authenticate(_msg, _auth, _retrying)
}

//export _gotk4_soup2_SessionClass_cancel_message
func _gotk4_soup2_SessionClass_cancel_message(arg0 *C.SoupSession, arg1 *C.SoupMessage, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SessionOverrides](instance0)
	if overrides.CancelMessage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SessionOverrides.CancelMessage, got none")
	}

	var _msg *Message    // out
	var _statusCode uint // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_statusCode = uint(arg2)

	overrides.CancelMessage(_msg, _statusCode)
}

//export _gotk4_soup2_SessionClass_flush_queue
func _gotk4_soup2_SessionClass_flush_queue(arg0 *C.SoupSession) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SessionOverrides](instance0)
	if overrides.FlushQueue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SessionOverrides.FlushQueue, got none")
	}

	overrides.FlushQueue()
}

//export _gotk4_soup2_SessionClass_kick
func _gotk4_soup2_SessionClass_kick(arg0 *C.SoupSession) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SessionOverrides](instance0)
	if overrides.Kick == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SessionOverrides.Kick, got none")
	}

	overrides.Kick()
}

//export _gotk4_soup2_SessionClass_request_started
func _gotk4_soup2_SessionClass_request_started(arg0 *C.SoupSession, arg1 *C.SoupMessage, arg2 *C.SoupSocket) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SessionOverrides](instance0)
	if overrides.RequestStarted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SessionOverrides.RequestStarted, got none")
	}

	var _msg *Message   // out
	var _socket *Socket // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))
	_socket = wrapSocket(coreglib.Take(unsafe.Pointer(arg2)))

	overrides.RequestStarted(_msg, _socket)
}

//export _gotk4_soup2_SessionClass_requeue_message
func _gotk4_soup2_SessionClass_requeue_message(arg0 *C.SoupSession, arg1 *C.SoupMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SessionOverrides](instance0)
	if overrides.RequeueMessage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SessionOverrides.RequeueMessage, got none")
	}

	var _msg *Message // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.RequeueMessage(_msg)
}

//export _gotk4_soup2_SessionClass_send_message
func _gotk4_soup2_SessionClass_send_message(arg0 *C.SoupSession, arg1 *C.SoupMessage) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SessionOverrides](instance0)
	if overrides.SendMessage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SessionOverrides.SendMessage, got none")
	}

	var _msg *Message // out

	_msg = wrapMessage(coreglib.Take(unsafe.Pointer(arg1)))

	guint := overrides.SendMessage(_msg)

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_soup2_SocketClass_disconnected
func _gotk4_soup2_SocketClass_disconnected(arg0 *C.SoupSocket) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SocketOverrides](instance0)
	if overrides.Disconnected == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SocketOverrides.Disconnected, got none")
	}

	overrides.Disconnected()
}

//export _gotk4_soup2_SocketClass_new_connection
func _gotk4_soup2_SocketClass_new_connection(arg0 *C.SoupSocket, arg1 *C.SoupSocket) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SocketOverrides](instance0)
	if overrides.NewConnection == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SocketOverrides.NewConnection, got none")
	}

	var _newSock *Socket // out

	_newSock = wrapSocket(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.NewConnection(_newSock)
}

//export _gotk4_soup2_SocketClass_readable
func _gotk4_soup2_SocketClass_readable(arg0 *C.SoupSocket) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SocketOverrides](instance0)
	if overrides.Readable == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SocketOverrides.Readable, got none")
	}

	overrides.Readable()
}

//export _gotk4_soup2_SocketClass_writable
func _gotk4_soup2_SocketClass_writable(arg0 *C.SoupSocket) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SocketOverrides](instance0)
	if overrides.Writable == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SocketOverrides.Writable, got none")
	}

	overrides.Writable()
}

//export _gotk4_soup2_WebsocketConnectionClass_closed
func _gotk4_soup2_WebsocketConnectionClass_closed(arg0 *C.SoupWebsocketConnection) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebsocketConnectionOverrides](instance0)
	if overrides.Closed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebsocketConnectionOverrides.Closed, got none")
	}

	overrides.Closed()
}

//export _gotk4_soup2_WebsocketConnectionClass_closing
func _gotk4_soup2_WebsocketConnectionClass_closing(arg0 *C.SoupWebsocketConnection) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebsocketConnectionOverrides](instance0)
	if overrides.Closing == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebsocketConnectionOverrides.Closing, got none")
	}

	overrides.Closing()
}

//export _gotk4_soup2_WebsocketConnectionClass_error
func _gotk4_soup2_WebsocketConnectionClass_error(arg0 *C.SoupWebsocketConnection, arg1 *C.GError) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebsocketConnectionOverrides](instance0)
	if overrides.Error == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebsocketConnectionOverrides.Error, got none")
	}

	var _err error // out

	_err = gerror.Take(unsafe.Pointer(arg1))

	overrides.Error(_err)
}

//export _gotk4_soup2_WebsocketConnectionClass_message
func _gotk4_soup2_WebsocketConnectionClass_message(arg0 *C.SoupWebsocketConnection, arg1 C.SoupWebsocketDataType, arg2 *C.GBytes) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebsocketConnectionOverrides](instance0)
	if overrides.Message == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebsocketConnectionOverrides.Message, got none")
	}

	var _typ WebsocketDataType // out
	var _message *glib.Bytes   // out

	_typ = WebsocketDataType(arg1)
	_message = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.g_bytes_ref(arg2)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	overrides.Message(_typ, _message)
}

//export _gotk4_soup2_WebsocketConnectionClass_pong
func _gotk4_soup2_WebsocketConnectionClass_pong(arg0 *C.SoupWebsocketConnection, arg1 *C.GBytes) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebsocketConnectionOverrides](instance0)
	if overrides.Pong == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebsocketConnectionOverrides.Pong, got none")
	}

	var _message *glib.Bytes // out

	_message = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.g_bytes_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	overrides.Pong(_message)
}

//export _gotk4_soup2_WebsocketExtensionClass_configure
func _gotk4_soup2_WebsocketExtensionClass_configure(arg0 *C.SoupWebsocketExtension, arg1 C.SoupWebsocketConnectionType, arg2 *C.GHashTable, _cerr **C.GError) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebsocketExtensionOverrides](instance0)
	if overrides.Configure == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebsocketExtensionOverrides.Configure, got none")
	}

	var _connectionType WebsocketConnectionType   // out
	var _params map[unsafe.Pointer]unsafe.Pointer // out

	_connectionType = WebsocketConnectionType(arg1)
	if arg2 != nil {
		_params = make(map[unsafe.Pointer]unsafe.Pointer, gextras.HashTableSize(unsafe.Pointer(arg2)))
		gextras.MoveHashTable(unsafe.Pointer(arg2), false, func(k, v unsafe.Pointer) {
			ksrc := *(**C.gpointer)(k)
			vsrc := *(**C.gpointer)(v)
			var kdst unsafe.Pointer // out
			var vdst unsafe.Pointer // out
			kdst = (unsafe.Pointer)(unsafe.Pointer(ksrc))
			vdst = (unsafe.Pointer)(unsafe.Pointer(vsrc))
			_params[kdst] = vdst
		})
	}

	_goerr := overrides.Configure(_connectionType, _params)

	var _ error

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_soup2_WebsocketExtensionClass_get_request_params
func _gotk4_soup2_WebsocketExtensionClass_get_request_params(arg0 *C.SoupWebsocketExtension) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebsocketExtensionOverrides](instance0)
	if overrides.RequestParams == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebsocketExtensionOverrides.RequestParams, got none")
	}

	utf8 := overrides.RequestParams()

	var _ string

	if utf8 != "" {
		cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
	}

	return cret
}

//export _gotk4_soup2_WebsocketExtensionClass_get_response_params
func _gotk4_soup2_WebsocketExtensionClass_get_response_params(arg0 *C.SoupWebsocketExtension) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebsocketExtensionOverrides](instance0)
	if overrides.ResponseParams == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebsocketExtensionOverrides.ResponseParams, got none")
	}

	utf8 := overrides.ResponseParams()

	var _ string

	if utf8 != "" {
		cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
	}

	return cret
}
