// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern SoupCacheability _gotk4_soup2_CacheClass_get_cacheability(SoupCache*, SoupMessage*);
// SoupCacheability _gotk4_soup2_Cache_virtual_get_cacheability(void* fnptr, SoupCache* arg0, SoupMessage* arg1) {
//   return ((SoupCacheability (*)(SoupCache*, SoupMessage*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeCache = coreglib.Type(C.soup_cache_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCache, F: marshalCache},
	})
}

// CacheOverrides contains methods that are overridable.
type CacheOverrides struct {
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Cacheability func(msg *Message) Cacheability
}

func defaultCacheOverrides(v *Cache) CacheOverrides {
	return CacheOverrides{
		Cacheability: v.cacheability,
	}
}

type Cache struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SessionFeature
}

var (
	_ coreglib.Objector = (*Cache)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Cache, *CacheClass, CacheOverrides](
		GTypeCache,
		initCacheClass,
		wrapCache,
		defaultCacheOverrides,
	)
}

func initCacheClass(gclass unsafe.Pointer, overrides CacheOverrides, classInitFunc func(*CacheClass)) {
	pclass := (*C.SoupCacheClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeCache))))

	if overrides.Cacheability != nil {
		pclass.get_cacheability = (*[0]byte)(C._gotk4_soup2_CacheClass_get_cacheability)
	}

	if classInitFunc != nil {
		class := (*CacheClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCache(obj *coreglib.Object) *Cache {
	return &Cache{
		Object: obj,
		SessionFeature: SessionFeature{
			Object: obj,
		},
	}
}

func marshalCache(p uintptr) (interface{}, error) {
	return wrapCache(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCache creates a new Cache.
//
// The function takes the following parameters:
//
//   - cacheDir (optional): directory to store the cached data, or NULL to
//     use the default one. Note that since the cache isn't safe to access for
//     multiple processes at once, and the default directory isn't namespaced by
//     process, clients are strongly discouraged from passing NULL.
//   - cacheType of the cache.
//
// The function returns the following values:
//
//   - cache: new Cache.
//
func NewCache(cacheDir string, cacheType CacheType) *Cache {
	var _arg1 *C.char         // out
	var _arg2 C.SoupCacheType // out
	var _cret *C.SoupCache    // in

	if cacheDir != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(cacheDir)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.SoupCacheType(cacheType)

	_cret = C.soup_cache_new(_arg1, _arg2)
	runtime.KeepAlive(cacheDir)
	runtime.KeepAlive(cacheType)

	var _cache *Cache // out

	_cache = wrapCache(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cache
}

// Clear will remove all entries in the cache plus all the cache files.
func (cache *Cache) Clear() {
	var _arg0 *C.SoupCache // out

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))

	C.soup_cache_clear(_arg0)
	runtime.KeepAlive(cache)
}

// Dump: synchronously writes the cache index out to disk. Contrast with
// soup_cache_flush(), which writes pending cache <emphasis>entries</emphasis>
// to disk.
//
// You must call this before exiting if you want your cache data to persist
// between sessions.
func (cache *Cache) Dump() {
	var _arg0 *C.SoupCache // out

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))

	C.soup_cache_dump(_arg0)
	runtime.KeepAlive(cache)
}

// Flush: this function will force all pending writes in the cache to be
// committed to disk. For doing so it will iterate the Context associated with
// cache's session as long as needed.
//
// Contrast with soup_cache_dump(), which writes out the cache index file.
func (cache *Cache) Flush() {
	var _arg0 *C.SoupCache // out

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))

	C.soup_cache_flush(_arg0)
	runtime.KeepAlive(cache)
}

// MaxSize gets the maximum size of the cache.
//
// The function returns the following values:
//
//   - guint: maximum size of the cache, in bytes.
//
func (cache *Cache) MaxSize() uint {
	var _arg0 *C.SoupCache // out
	var _cret C.guint      // in

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))

	_cret = C.soup_cache_get_max_size(_arg0)
	runtime.KeepAlive(cache)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Load loads the contents of cache's index into memory.
func (cache *Cache) Load() {
	var _arg0 *C.SoupCache // out

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))

	C.soup_cache_load(_arg0)
	runtime.KeepAlive(cache)
}

// SetMaxSize sets the maximum size of the cache.
//
// The function takes the following parameters:
//
//   - maxSize: maximum size of the cache, in bytes.
//
func (cache *Cache) SetMaxSize(maxSize uint) {
	var _arg0 *C.SoupCache // out
	var _arg1 C.guint      // out

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))
	_arg1 = C.guint(maxSize)

	C.soup_cache_set_max_size(_arg0, _arg1)
	runtime.KeepAlive(cache)
	runtime.KeepAlive(maxSize)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (cache *Cache) cacheability(msg *Message) Cacheability {
	gclass := (*C.SoupCacheClass)(coreglib.PeekParentClass(cache))
	fnarg := gclass.get_cacheability

	var _arg0 *C.SoupCache       // out
	var _arg1 *C.SoupMessage     // out
	var _cret C.SoupCacheability // in

	_arg0 = (*C.SoupCache)(unsafe.Pointer(coreglib.InternObject(cache).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C._gotk4_soup2_Cache_virtual_get_cacheability(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(cache)
	runtime.KeepAlive(msg)

	var _cacheability Cacheability // out

	_cacheability = Cacheability(_cret)

	return _cacheability
}

// CacheClass: instance of this type is always passed by reference.
type CacheClass struct {
	*cacheClass
}

// cacheClass is the struct that's finalized.
type cacheClass struct {
	native *C.SoupCacheClass
}
