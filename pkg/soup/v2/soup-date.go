// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.soup_date_format_get_type()), F: marshalDateFormat},
		{T: externglib.Type(C.soup_date_get_type()), F: marshalDate},
	})
}

// DateFormat: date formats that soup_date_to_string() can use.
//
// SOUP_DATE_HTTP and SOUP_DATE_COOKIE always coerce the time to UTC.
// SOUP_DATE_ISO8601_XMLRPC uses the time as given, ignoring the offset
// completely. SOUP_DATE_RFC2822 and the other ISO 8601 variants use the local
// time, appending the offset information if available.
//
// This enum may be extended with more values in future releases.
type DateFormat C.gint

const (
	// DateHTTP: RFC 1123 format, used by the HTTP "Date" header. Eg "Sun, 06
	// Nov 1994 08:49:37 GMT".
	DateHTTP DateFormat = 1
	// DateCookie: format for the "Expires" timestamp in the Netscape cookie
	// specification. Eg, "Sun, 06-Nov-1994 08:49:37 GMT".
	DateCookie DateFormat = 2
	// DateRfc2822: RFC 2822 format, eg "Sun, 6 Nov 1994 09:49:37 -0100".
	DateRfc2822 DateFormat = 3
	// DateISO8601Compact: ISO 8601 date/time with no optional punctuation. Eg,
	// "19941106T094937-0100".
	DateISO8601Compact DateFormat = 4
	// DateISO8601Full: ISO 8601 date/time with all optional punctuation. Eg,
	// "1994-11-06T09:49:37-01:00".
	DateISO8601Full DateFormat = 5
	// DateISO8601 alias for SOUP_DATE_ISO8601_FULL.
	DateISO8601 DateFormat = 5
	// DateISO8601Xmlrpc: ISO 8601 date/time as used by XML-RPC. Eg,
	// "19941106T09:49:37".
	DateISO8601Xmlrpc DateFormat = 6
)

func marshalDateFormat(p uintptr) (interface{}, error) {
	return DateFormat(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DateFormat.
func (d DateFormat) String() string {
	switch d {
	case DateHTTP:
		return "HTTP"
	case DateCookie:
		return "Cookie"
	case DateRfc2822:
		return "Rfc2822"
	case DateISO8601Compact:
		return "ISO8601Compact"
	case DateISO8601Full:
		return "ISO8601Full"
	case DateISO8601Xmlrpc:
		return "ISO8601Xmlrpc"
	default:
		return fmt.Sprintf("DateFormat(%d)", d)
	}
}

// Date: date and time. The date is assumed to be in the (proleptic) Gregorian
// calendar. The time is in UTC if utc is TRUE. Otherwise, the time is a local
// time, and offset gives the offset from UTC in minutes (such that adding
// offset to the time would give the correct UTC time). If utc is FALSE and
// offset is 0, then the SoupDate represents a "floating" time with no
// associated timezone information.
//
// An instance of this type is always passed by reference.
type Date struct {
	*date
}

// date is the struct that's finalized.
type date struct {
	native *C.SoupDate
}

func marshalDate(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Date{&date{(*C.SoupDate)(b)}}, nil
}

// NewDate constructs a struct Date.
func NewDate(year int, month int, day int, hour int, minute int, second int) *Date {
	var _arg1 C.int       // out
	var _arg2 C.int       // out
	var _arg3 C.int       // out
	var _arg4 C.int       // out
	var _arg5 C.int       // out
	var _arg6 C.int       // out
	var _cret *C.SoupDate // in

	_arg1 = C.int(year)
	_arg2 = C.int(month)
	_arg3 = C.int(day)
	_arg4 = C.int(hour)
	_arg5 = C.int(minute)
	_arg6 = C.int(second)

	_cret = C.soup_date_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)
	runtime.KeepAlive(day)
	runtime.KeepAlive(hour)
	runtime.KeepAlive(minute)
	runtime.KeepAlive(second)

	var _date *Date // out

	_date = (*Date)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_date)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_date_free((*C.SoupDate)(intern.C))
		},
	)

	return _date
}

// NewDateFromNow constructs a struct Date.
func NewDateFromNow(offsetSeconds int) *Date {
	var _arg1 C.int       // out
	var _cret *C.SoupDate // in

	_arg1 = C.int(offsetSeconds)

	_cret = C.soup_date_new_from_now(_arg1)
	runtime.KeepAlive(offsetSeconds)

	var _date *Date // out

	_date = (*Date)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_date)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_date_free((*C.SoupDate)(intern.C))
		},
	)

	return _date
}

// NewDateFromString constructs a struct Date.
func NewDateFromString(dateString string) *Date {
	var _arg1 *C.char     // out
	var _cret *C.SoupDate // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(dateString)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.soup_date_new_from_string(_arg1)
	runtime.KeepAlive(dateString)

	var _date *Date // out

	if _cret != nil {
		_date = (*Date)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_date)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_date_free((*C.SoupDate)(intern.C))
			},
		)
	}

	return _date
}

// NewDateFromTimeT constructs a struct Date.
func NewDateFromTimeT(when int32) *Date {
	var _arg1 C.time_t    // out
	var _cret *C.SoupDate // in

	_arg1 = C.time_t(when)

	_cret = C.soup_date_new_from_time_t(_arg1)
	runtime.KeepAlive(when)

	var _date *Date // out

	_date = (*Date)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_date)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_date_free((*C.SoupDate)(intern.C))
		},
	)

	return _date
}

// Copy copies date.
func (date *Date) Copy() *Date {
	var _arg0 *C.SoupDate // out
	var _cret *C.SoupDate // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	_cret = C.soup_date_copy(_arg0)
	runtime.KeepAlive(date)

	var _ret *Date // out

	_ret = (*Date)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.soup_date_free((*C.SoupDate)(intern.C))
		},
	)

	return _ret
}

// Day gets date's day.
func (date *Date) Day() int {
	var _arg0 *C.SoupDate // out
	var _cret C.int       // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	_cret = C.soup_date_get_day(_arg0)
	runtime.KeepAlive(date)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Hour gets date's hour.
func (date *Date) Hour() int {
	var _arg0 *C.SoupDate // out
	var _cret C.int       // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	_cret = C.soup_date_get_hour(_arg0)
	runtime.KeepAlive(date)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Minute gets date's minute.
func (date *Date) Minute() int {
	var _arg0 *C.SoupDate // out
	var _cret C.int       // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	_cret = C.soup_date_get_minute(_arg0)
	runtime.KeepAlive(date)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Month gets date's month.
func (date *Date) Month() int {
	var _arg0 *C.SoupDate // out
	var _cret C.int       // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	_cret = C.soup_date_get_month(_arg0)
	runtime.KeepAlive(date)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Offset gets date's offset from UTC.
func (date *Date) Offset() int {
	var _arg0 *C.SoupDate // out
	var _cret C.int       // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	_cret = C.soup_date_get_offset(_arg0)
	runtime.KeepAlive(date)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Second gets date's second.
func (date *Date) Second() int {
	var _arg0 *C.SoupDate // out
	var _cret C.int       // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	_cret = C.soup_date_get_second(_arg0)
	runtime.KeepAlive(date)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UTC gets date's UTC flag.
func (date *Date) UTC() int {
	var _arg0 *C.SoupDate // out
	var _cret C.int       // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	_cret = C.soup_date_get_utc(_arg0)
	runtime.KeepAlive(date)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Year gets date's year.
func (date *Date) Year() int {
	var _arg0 *C.SoupDate // out
	var _cret C.int       // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	_cret = C.soup_date_get_year(_arg0)
	runtime.KeepAlive(date)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsPast determines if date is in the past.
func (date *Date) IsPast() bool {
	var _arg0 *C.SoupDate // out
	var _cret C.gboolean  // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	_cret = C.soup_date_is_past(_arg0)
	runtime.KeepAlive(date)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String converts date to a string in the format described by format.
func (date *Date) String(format DateFormat) string {
	var _arg0 *C.SoupDate      // out
	var _arg1 C.SoupDateFormat // out
	var _cret *C.char          // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))
	_arg1 = C.SoupDateFormat(format)

	_cret = C.soup_date_to_string(_arg0, _arg1)
	runtime.KeepAlive(date)
	runtime.KeepAlive(format)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToTimeT converts date to a <type>time_t</type>, assumming it to be in UTC.
//
// If date is not representable as a <type>time_t</type>, it will be clamped
// into range. (In particular, some HTTP cookies have expiration dates after
// "Y2.038k" (2038-01-19T03:14:07Z).).
func (date *Date) ToTimeT() int32 {
	var _arg0 *C.SoupDate // out
	var _cret C.time_t    // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	_cret = C.soup_date_to_time_t(_arg0)
	runtime.KeepAlive(date)

	var _glong int32 // out

	_glong = int32(_cret)

	return _glong
}

// ToTimeval converts date to a Val.
//
// Deprecated: Do not use Val, as it's not Y2038-safe.
func (date *Date) ToTimeval() *glib.TimeVal {
	var _arg0 *C.SoupDate // out
	var _arg1 C.GTimeVal  // in

	_arg0 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(date)))

	C.soup_date_to_timeval(_arg0, &_arg1)
	runtime.KeepAlive(date)

	var _time *glib.TimeVal // out

	_time = (*glib.TimeVal)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _time
}
