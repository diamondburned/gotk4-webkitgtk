// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_soup2_Server_ConnectRequestStarted(gpointer, SoupMessage*, SoupClientContext*, guintptr);
// extern void _gotk4_soup2_Server_ConnectRequestRead(gpointer, SoupMessage*, SoupClientContext*, guintptr);
// extern void _gotk4_soup2_Server_ConnectRequestFinished(gpointer, SoupMessage*, SoupClientContext*, guintptr);
// extern void _gotk4_soup2_Server_ConnectRequestAborted(gpointer, SoupMessage*, SoupClientContext*, guintptr);
// extern void _gotk4_soup2_ServerWebsocketCallback(SoupServer*, SoupWebsocketConnection*, char*, SoupClientContext*, gpointer);
// extern void _gotk4_soup2_ServerClass_request_started(SoupServer*, SoupMessage*, SoupClientContext*);
// extern void _gotk4_soup2_ServerClass_request_read(SoupServer*, SoupMessage*, SoupClientContext*);
// extern void _gotk4_soup2_ServerClass_request_finished(SoupServer*, SoupMessage*, SoupClientContext*);
// extern void _gotk4_soup2_ServerClass_request_aborted(SoupServer*, SoupMessage*, SoupClientContext*);
// extern void _gotk4_soup2_ServerCallback(SoupServer*, SoupMessage*, char*, GHashTable*, SoupClientContext*, gpointer);
// void _gotk4_soup2_Server_virtual_request_aborted(void* fnptr, SoupServer* arg0, SoupMessage* arg1, SoupClientContext* arg2) {
//   ((void (*)(SoupServer*, SoupMessage*, SoupClientContext*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_soup2_Server_virtual_request_finished(void* fnptr, SoupServer* arg0, SoupMessage* arg1, SoupClientContext* arg2) {
//   ((void (*)(SoupServer*, SoupMessage*, SoupClientContext*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_soup2_Server_virtual_request_read(void* fnptr, SoupServer* arg0, SoupMessage* arg1, SoupClientContext* arg2) {
//   ((void (*)(SoupServer*, SoupMessage*, SoupClientContext*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_soup2_Server_virtual_request_started(void* fnptr, SoupServer* arg0, SoupMessage* arg1, SoupClientContext* arg2) {
//   ((void (*)(SoupServer*, SoupMessage*, SoupClientContext*))(fnptr))(arg0, arg1, arg2);
// };
import "C"

// GType values.
var (
	GTypeServer        = coreglib.Type(C.soup_server_get_type())
	GTypeClientContext = coreglib.Type(C.soup_client_context_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeServer, F: marshalServer},
		coreglib.TypeMarshaler{T: GTypeClientContext, F: marshalClientContext},
	})
}

// SERVER_ASYNC_CONTEXT alias for the deprecated Server:async-context property,
// qv.
//
// Deprecated: The new API uses the thread-default Context rather than having an
// explicitly-specified one.
const SERVER_ASYNC_CONTEXT = "async-context"

// SERVER_INTERFACE alias for the Server:interface property, qv.
//
// Deprecated: Servers can listen on multiple interfaces at once now.
// Use soup_server_listen(), etc, to listen on an interface, and
// soup_server_get_uris() to see what addresses are being listened on.
const SERVER_INTERFACE = "interface"

// SERVER_PORT alias for the deprecated Server:port property, qv.
//
// Deprecated: Servers can listen on multiple interfaces at once now. Use
// soup_server_listen(), etc, to listen on a port, and soup_server_get_uris() to
// see what ports are being listened on.
const SERVER_PORT = "port"

// SERVER_RAW_PATHS alias for the Server:raw-paths property. (If TRUE,
// percent-encoding in the Request-URI path will not be automatically decoded.).
const SERVER_RAW_PATHS = "raw-paths"

// SERVER_SERVER_HEADER alias for the Server:server-header property, qv.
const SERVER_SERVER_HEADER = "server-header"

// SERVER_SSL_CERT_FILE alias for the Server:ssl-cert-file property, qv.
//
// Deprecated: use Server:tls-certificate or soup_server_set_ssl_certificate().
const SERVER_SSL_CERT_FILE = "ssl-cert-file"

// SERVER_SSL_KEY_FILE alias for the Server:ssl-key-file property, qv.
//
// Deprecated: use Server:tls-certificate or soup_server_set_ssl_certificate().
const SERVER_SSL_KEY_FILE = "ssl-key-file"

// ServerCallback: callback used to handle requests to a Server.
//
// path and query contain the likewise-named components of the Request-URI,
// subject to certain assumptions. By default, Server decodes all
// percent-encoding in the URI path, such that "/foo%<!-- -->2Fbar" is
// treated the same as "/foo/bar". If your server is serving resources in some
// non-POSIX-filesystem namespace, you may want to distinguish those as two
// distinct paths. In that case, you can set the SOUP_SERVER_RAW_PATHS property
// when creating the Server, and it will leave those characters undecoded.
// (You may want to call soup_uri_normalize() to decode any percent-encoded
// characters that you aren't handling specially.)
//
// query contains the query component of the Request-URI parsed according to the
// rules for HTML form handling. Although this is the only commonly-used query
// string format in HTTP, there is nothing that actually requires that HTTP URIs
// use that format; if your server needs to use some other format, you can just
// ignore query, and call soup_message_get_uri() and parse the URI's query field
// yourself.
//
// See soup_server_add_handler() and soup_server_add_early_handler() for details
// of what handlers can/should do.
type ServerCallback func(server *Server, msg *Message, path string, query map[string]string, client *ClientContext)

// ServerWebsocketCallback: callback used to handle WebSocket requests to a
// Server. The callback will be invoked after sending the handshake response
// back to the client (and is only invoked if the handshake was successful).
//
// path contains the path of the Request-URI, subject to the same rules as
// ServerCallback (qv).
type ServerWebsocketCallback func(server *Server, connection *WebsocketConnection, path string, client *ClientContext)

// ServerOverrides contains methods that are overridable.
type ServerOverrides struct {
	// The function takes the following parameters:
	//
	//   - msg
	//   - client
	//
	RequestAborted func(msg *Message, client *ClientContext)
	// The function takes the following parameters:
	//
	//   - msg
	//   - client
	//
	RequestFinished func(msg *Message, client *ClientContext)
	// The function takes the following parameters:
	//
	//   - msg
	//   - client
	//
	RequestRead func(msg *Message, client *ClientContext)
	// The function takes the following parameters:
	//
	//   - msg
	//   - client
	//
	RequestStarted func(msg *Message, client *ClientContext)
}

func defaultServerOverrides(v *Server) ServerOverrides {
	return ServerOverrides{
		RequestAborted:  v.requestAborted,
		RequestFinished: v.requestFinished,
		RequestRead:     v.requestRead,
		RequestStarted:  v.requestStarted,
	}
}

type Server struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Server)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Server, *ServerClass, ServerOverrides](
		GTypeServer,
		initServerClass,
		wrapServer,
		defaultServerOverrides,
	)
}

func initServerClass(gclass unsafe.Pointer, overrides ServerOverrides, classInitFunc func(*ServerClass)) {
	pclass := (*C.SoupServerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeServer))))

	if overrides.RequestAborted != nil {
		pclass.request_aborted = (*[0]byte)(C._gotk4_soup2_ServerClass_request_aborted)
	}

	if overrides.RequestFinished != nil {
		pclass.request_finished = (*[0]byte)(C._gotk4_soup2_ServerClass_request_finished)
	}

	if overrides.RequestRead != nil {
		pclass.request_read = (*[0]byte)(C._gotk4_soup2_ServerClass_request_read)
	}

	if overrides.RequestStarted != nil {
		pclass.request_started = (*[0]byte)(C._gotk4_soup2_ServerClass_request_started)
	}

	if classInitFunc != nil {
		class := (*ServerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapServer(obj *coreglib.Object) *Server {
	return &Server{
		Object: obj,
	}
}

func marshalServer(p uintptr) (interface{}, error) {
	return wrapServer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectRequestAborted is emitted when processing has failed for a message;
// this could mean either that it could not be read (if Server::request_read has
// not been emitted for it yet), or that the response could not be written back
// (if Server::request_read has been emitted but Server::request_finished has
// not been).
//
// message is in an undefined state when this signal is emitted; the signal
// exists primarily to allow the server to free any state that it may have
// allocated in Server::request_started.
func (server *Server) ConnectRequestAborted(f func(message *Message, client *ClientContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-aborted", false, unsafe.Pointer(C._gotk4_soup2_Server_ConnectRequestAborted), f)
}

// ConnectRequestFinished is emitted when the server has finished writing a
// response to a request.
func (server *Server) ConnectRequestFinished(f func(message *Message, client *ClientContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-finished", false, unsafe.Pointer(C._gotk4_soup2_Server_ConnectRequestFinished), f)
}

// ConnectRequestRead is emitted when the server has successfully read a
// request. message will have all of its request-side information filled in,
// and if the message was authenticated, client will have information about
// that. This signal is emitted before any (non-early) handlers are called for
// the message, and if it sets the message's #status_code, then normal handler
// processing will be skipped.
func (server *Server) ConnectRequestRead(f func(message *Message, client *ClientContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-read", false, unsafe.Pointer(C._gotk4_soup2_Server_ConnectRequestRead), f)
}

// ConnectRequestStarted is emitted when the server has started reading a new
// request. message will be completely blank; not even the Request-Line will
// have been read yet. About the only thing you can usefully do with it is
// connect to its signals.
//
// If the request is read successfully, this will eventually be followed by
// a Server::request_read signal. If a response is then sent, the request
// processing will end with a Server::request_finished signal. If a network
// error occurs, the processing will instead end with Server::request_aborted.
func (server *Server) ConnectRequestStarted(f func(message *Message, client *ClientContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-started", false, unsafe.Pointer(C._gotk4_soup2_Server_ConnectRequestStarted), f)
}

// AcceptIostream: add a new client stream to the server.
//
// The function takes the following parameters:
//
//   - stream: OStream.
//   - localAddr (optional): local Address associated with the stream.
//   - remoteAddr (optional): remote Address associated with the stream.
//
func (server *Server) AcceptIostream(stream gio.IOStreamer, localAddr, remoteAddr gio.SocketAddresser) error {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.GIOStream      // out
	var _arg2 *C.GSocketAddress // out
	var _arg3 *C.GSocketAddress // out
	var _cerr *C.GError         // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if localAddr != nil {
		_arg2 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(localAddr).Native()))
	}
	if remoteAddr != nil {
		_arg3 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(remoteAddr).Native()))
	}

	C.soup_server_accept_iostream(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(localAddr)
	runtime.KeepAlive(remoteAddr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddAuthDomain adds an authentication domain to server. Each auth domain will
// have the chance to require authentication for each request that comes in;
// normally auth domains will require authentication for requests on certain
// paths that they have been set up to watch, or that meet other criteria
// set by the caller. If an auth domain determines that a request requires
// authentication (and the request doesn't contain authentication), server will
// automatically reject the request with an appropriate status (401 Unauthorized
// or 407 Proxy Authentication Required). If the request used the "100-continue"
// Expectation, server will reject it before the request body is sent.
//
// The function takes the following parameters:
//
//   - authDomain: AuthDomain.
//
func (server *Server) AddAuthDomain(authDomain AuthDomainer) {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.SoupAuthDomain // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(authDomain).Native()))

	C.soup_server_add_auth_domain(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(authDomain)
}

// AddEarlyHandler adds an "early" handler to server for requests under path.
// Note that "normal" and "early" handlers are matched up together, so if you
// add a normal handler for "/foo" and an early handler for "/foo/bar", then a
// request to "/foo/bar" (or any path below it) will run only the early handler.
// (But if you add both handlers at the same path, then both will get run.)
//
// For requests under path (that have not already been assigned a status code by
// a AuthDomain or a signal handler), callback will be invoked after receiving
// the request headers, but before receiving the request body; the message's
// Message:method and Message:request-headers fields will be filled in.
//
// Early handlers are generally used for processing requests with request bodies
// in a streaming fashion. If you determine that the request will contain a
// message body, normally you would call soup_message_body_set_accumulate() on
// the message's Message:request-body to turn off request-body accumulation,
// and connect to the message's Message::got-chunk signal to process each chunk
// as it comes in.
//
// To complete the message processing after the full message body has been read,
// you can either also connect to Message::got-body, or else you can register
// a non-early handler for path as well. As long as you have not set the
// Message:status-code by the time Message::got-body is emitted, the non-early
// handler will be run as well.
//
// The function takes the following parameters:
//
//   - path (optional): toplevel path for the handler.
//   - callback to invoke for requests under path.
//
func (server *Server) AddEarlyHandler(path string, callback ServerCallback) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.char              // out
	var _arg2 C.SoupServerCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*[0]byte)(C._gotk4_soup2_ServerCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_early_handler(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(callback)
}

// AddHandler adds a handler to server for requests under path. If path is
// NULL or "/", then this will be the default handler for all requests that
// don't have a more specific handler. (Note though that if you want to handle
// requests to the special "*" URI, you must explicitly register a handler for
// "*"; the default handler will not be used for that case.)
//
// For requests under path (that have not already been assigned a status code
// by a AuthDomain, an early ServerHandler, or a signal handler), callback will
// be invoked after receiving the request body; the message's Message:method,
// Message:request-headers, and Message:request-body fields will be filled in.
//
// After determining what to do with the request, the callback must at a minimum
// call soup_message_set_status() (or soup_message_set_status_full()) on the
// message to set the response status code. Additionally, it may set response
// headers and/or fill in the response body.
//
// If the callback cannot fully fill in the response before returning (eg,
// if it needs to wait for information from a database, or another network
// server), it should call soup_server_pause_message() to tell server
// to not send the response right away. When the response is ready, call
// soup_server_unpause_message() to cause it to be sent.
//
// To send the response body a bit at a time using "chunked" encoding,
// first call soup_message_headers_set_encoding() to set SOUP_ENCODING_CHUNKED
// on the Message:response-headers. Then call soup_message_body_append() (or
// soup_message_body_append_buffer()) to append each chunk as it becomes ready,
// and soup_server_unpause_message() to make sure it's running. (The server will
// automatically pause the message if it is using chunked encoding but no more
// chunks are available.) When you are done, call soup_message_body_complete()
// to indicate that no more chunks are coming.
//
// The function takes the following parameters:
//
//   - path (optional): toplevel path for the handler.
//   - callback to invoke for requests under path.
//
func (server *Server) AddHandler(path string, callback ServerCallback) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.char              // out
	var _arg2 C.SoupServerCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*[0]byte)(C._gotk4_soup2_ServerCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_handler(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(callback)
}

// AddWebsocketExtension: add support for a WebSocket extension of the
// given extension_type. When a WebSocket client requests an extension of
// extension_type, a new WebsocketExtension of type extension_type will be
// created to handle the request.
//
// You can also add support for a WebSocket extension to the server at
// construct time by using the SOUP_SERVER_ADD_WEBSOCKET_EXTENSION property.
// Note that WebsocketExtensionDeflate is supported by default, use
// soup_server_remove_websocket_extension() if you want to disable it.
//
// The function takes the following parameters:
//
//   - extensionType: #GType.
//
func (server *Server) AddWebsocketExtension(extensionType coreglib.Type) {
	var _arg0 *C.SoupServer // out
	var _arg1 C.GType       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.GType(extensionType)

	C.soup_server_add_websocket_extension(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(extensionType)
}

// AddWebsocketHandler adds a WebSocket handler to server for requests under
// path. (If path is NULL or "/", then this will be the default handler for all
// requests that don't have a more specific handler.)
//
// When a path has a WebSocket handler registered, server will check incoming
// requests for WebSocket handshakes after all other handlers have run (unless
// some earlier handler has already set a status code on the message), and
// update the request's status, response headers, and response body accordingly.
//
// If origin is non-NULL, then only requests containing a matching "Origin"
// header will be accepted. If protocols is non-NULL, then only requests
// containing a compatible "Sec-WebSocket-Protocols" header will be accepted.
// More complicated requirements can be handled by adding a normal handler to
// path, and having it perform whatever checks are needed (possibly calling
// soup_server_check_websocket_handshake() one or more times), and setting a
// failure status code if the handshake should be rejected.
//
// The function takes the following parameters:
//
//   - path (optional): toplevel path for the handler.
//   - origin (optional) of the connection.
//   - protocols (optional): protocols supported by this handler.
//   - callback to invoke for successful WebSocket requests under path.
//
func (server *Server) AddWebsocketHandler(path, origin string, protocols []string, callback ServerWebsocketCallback) {
	var _arg0 *C.SoupServer                 // out
	var _arg1 *C.char                       // out
	var _arg2 *C.char                       // out
	var _arg3 **C.char                      // out
	var _arg4 C.SoupServerWebsocketCallback // out
	var _arg5 C.gpointer
	var _arg6 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if origin != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(origin)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	{
		_arg3 = (**C.char)(C.calloc(C.size_t((len(protocols) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(protocols)+1)
			var zero *C.char
			out[len(protocols)] = zero
			for i := range protocols {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(protocols[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg4 = (*[0]byte)(C._gotk4_soup2_ServerWebsocketCallback)
	_arg5 = C.gpointer(gbox.Assign(callback))
	_arg6 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_websocket_handler(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(origin)
	runtime.KeepAlive(protocols)
	runtime.KeepAlive(callback)
}

// Disconnect closes and frees server's listening sockets. If you are using the
// old Server APIs, this also includes the effect of soup_server_quit().
//
// Note that if there are currently requests in progress on server, that they
// will continue to be processed if server's Context is still running.
//
// You can call soup_server_listen(), etc, after calling this function if you
// want to start listening again.
func (server *Server) Disconnect() {
	var _arg0 *C.SoupServer // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	C.soup_server_disconnect(_arg0)
	runtime.KeepAlive(server)
}

// AsyncContext gets server's async_context, if you are using the old API.
// (With the new API, the server runs in the thread's thread-default Context,
// regardless of what this method returns.)
//
// This does not add a ref to the context, so you will need to ref it yourself
// if you want it to outlive its server.
//
// Deprecated: If you are using soup_server_listen(), etc, then the server
// listens on the thread-default Context, and this property is ignored.
//
// The function returns the following values:
//
//   - mainContext (optional) server's Context, which may be NULL.
//
func (server *Server) AsyncContext() *glib.MainContext {
	var _arg0 *C.SoupServer   // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_async_context(_arg0)
	runtime.KeepAlive(server)

	var _mainContext *glib.MainContext // out

	if _cret != nil {
		_mainContext = (*glib.MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_main_context_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_mainContext)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_main_context_unref((*C.GMainContext)(intern.C))
			},
		)
	}

	return _mainContext
}

// Listener gets server's listening socket, if you are using the old API.
//
// You should treat this socket as read-only; writing to it or modifiying it may
// cause server to malfunction.
//
// Deprecated: If you are using soup_server_listen(), etc, then use
// soup_server_get_listeners() to get a list of all listening sockets, but note
// that that function returns #GSockets, not Sockets.
//
// The function returns the following values:
//
//   - socket: listening socket.
//
func (server *Server) Listener() *Socket {
	var _arg0 *C.SoupServer // out
	var _cret *C.SoupSocket // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_listener(_arg0)
	runtime.KeepAlive(server)

	var _socket *Socket // out

	_socket = wrapSocket(coreglib.Take(unsafe.Pointer(_cret)))

	return _socket
}

// Listeners gets server's list of listening sockets.
//
// You should treat these sockets as read-only; writing to or modifiying any of
// these sockets may cause server to malfunction.
//
// (Beware that in contrast to the old soup_server_get_listener(), this function
// returns #GSockets, not Sockets.).
//
// The function returns the following values:
//
//   - sList: a list of listening sockets.
//
func (server *Server) Listeners() []*gio.Socket {
	var _arg0 *C.SoupServer // out
	var _cret *C.GSList     // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_listeners(_arg0)
	runtime.KeepAlive(server)

	var _sList []*gio.Socket // out

	_sList = make([]*gio.Socket, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSocket)(v)
		var dst *gio.Socket // out
		{
			obj := coreglib.Take(unsafe.Pointer(src))
			dst = &gio.Socket{
				Object: obj,
				DatagramBased: gio.DatagramBased{
					Object: obj,
				},
				Initable: gio.Initable{
					Object: obj,
				},
			}
		}
		_sList = append(_sList, dst)
	})

	return _sList
}

// Port gets the TCP port that server is listening on, if you are using the old
// API.
//
// Deprecated: If you are using soup_server_listen(), etc, then use
// soup_server_get_uris() to get a list of all listening addresses.
//
// The function returns the following values:
//
//   - guint: port server is listening on.
//
func (server *Server) Port() uint {
	var _arg0 *C.SoupServer // out
	var _cret C.guint       // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_port(_arg0)
	runtime.KeepAlive(server)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// URIs gets a list of URIs corresponding to the interfaces server is listening
// on. These will contain IP addresses, not hostnames, and will also indicate
// whether the given listener is http or https.
//
// Note that if you used soup_server_listen_all(), the returned URIs will use
// the addresses <literal>0.0.0.0</literal> and <literal>::</literal>, rather
// than actually returning separate URIs for each interface on the system.
//
// The function returns the following values:
//
//   - sList: list of URIs, which you must free when you are done with it.
//
func (server *Server) URIs() []*URI {
	var _arg0 *C.SoupServer // out
	var _cret *C.GSList     // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_uris(_arg0)
	runtime.KeepAlive(server)

	var _sList []*URI // out

	_sList = make([]*URI, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupURI)(v)
		var dst *URI // out
		dst = (*URI)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_uri_free((*C.SoupURI)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// IsHTTPS checks whether server is capable of https.
//
// In order for a server to run https, you must call
// soup_server_set_ssl_cert_file(), or set the Server:tls-certificate property,
// to provide it with a certificate to use.
//
// If you are using the deprecated single-listener APIs, then a return value
// of TRUE indicates that the Server serves https exclusively. If you are using
// soup_server_listen(), etc, then a TRUE return value merely indicates that
// the server is <emphasis>able</emphasis> to do https, regardless of whether
// it actually currently is or not. Use soup_server_get_uris() to see if it
// currently has any https listeners.
//
// The function returns the following values:
//
//   - ok: TRUE if server is configured to serve https.
//
func (server *Server) IsHTTPS() bool {
	var _arg0 *C.SoupServer // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_is_https(_arg0)
	runtime.KeepAlive(server)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Listen: this attempts to set up server to listen for connections on address.
//
// If options includes SOUP_SERVER_LISTEN_HTTPS, and server has been configured
// for TLS, then server will listen for https connections on this port.
// Otherwise it will listen for plain http.
//
// You may call this method (along with the other "listen" methods) any number
// of times on a server, if you want to listen on multiple ports, or set up both
// http and https service.
//
// After calling this method, server will begin accepting and processing
// connections as soon as the appropriate Context is run.
//
// Note that Server never makes use of dual IPv4/IPv6 sockets; if address is an
// IPv6 address, it will only accept IPv6 connections. You must configure IPv4
// listening separately.
//
// The function takes the following parameters:
//
//   - address of the interface to listen on.
//   - options: listening options for this server.
//
func (server *Server) Listen(address gio.SocketAddresser, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 *C.GSocketAddress         // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(address)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenAll: this attempts to set up server to listen for connections
// on all interfaces on the system. (That is, it listens on the addresses
// <literal>0.0.0.0</literal> and/or <literal>::</literal>, depending on whether
// options includes SOUP_SERVER_LISTEN_IPV4_ONLY, SOUP_SERVER_LISTEN_IPV6_ONLY,
// or neither.) If port is specified, server will listen on that port. If it is
// 0, server will find an unused port to listen on. (In that case, you can use
// soup_server_get_uris() to find out what port it ended up choosing.)
//
// See soup_server_listen() for more details.
//
// The function takes the following parameters:
//
//   - port to listen on, or 0.
//   - options: listening options for this server.
//
func (server *Server) ListenAll(port uint, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 C.guint                   // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.guint(port)
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_all(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(port)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenFd: this attempts to set up server to listen for connections on fd.
//
// See soup_server_listen() for more details.
//
// Note that server will close fd when you free it or call
// soup_server_disconnect().
//
// The function takes the following parameters:
//
//   - fd: file descriptor of a listening socket.
//   - options: listening options for this server.
//
func (server *Server) ListenFd(fd int, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 C.int                     // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.int(fd)
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_fd(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(fd)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenLocal: this attempts to set up server to listen for connections
// on "localhost" (that is, <literal>127.0.0.1</literal> and/or
// <literal>::1</literal>, depending on whether options includes
// SOUP_SERVER_LISTEN_IPV4_ONLY, SOUP_SERVER_LISTEN_IPV6_ONLY, or neither).
// If port is specified, server will listen on that port. If it is 0,
// server will find an unused port to listen on. (In that case, you can use
// soup_server_get_uris() to find out what port it ended up choosing.)
//
// See soup_server_listen() for more details.
//
// The function takes the following parameters:
//
//   - port to listen on, or 0.
//   - options: listening options for this server.
//
func (server *Server) ListenLocal(port uint, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 C.guint                   // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.guint(port)
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_local(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(port)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenSocket: this attempts to set up server to listen for connections on
// socket.
//
// See soup_server_listen() for more details.
//
// The function takes the following parameters:
//
//   - socket: listening #GSocket.
//   - options: listening options for this server.
//
func (server *Server) ListenSocket(socket *gio.Socket, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 *C.GSocket                // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_socket(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PauseMessage pauses I/O on msg. This can be used when you need to return
// from the server handler without having the full response ready yet. Use
// soup_server_unpause_message() to resume I/O.
//
// This must only be called on Messages which were created by the Server and are
// currently doing I/O, such as those passed into a ServerCallback or emitted in
// a Server::request-read signal.
//
// The function takes the following parameters:
//
//   - msg associated with server.
//
func (server *Server) PauseMessage(msg *Message) {
	var _arg0 *C.SoupServer  // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_server_pause_message(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// Quit stops processing for server, if you are using the old API. Call
// this to clean up after soup_server_run_async(), or to terminate a call to
// soup_server_run().
//
// Note that messages currently in progress will continue to be handled,
// if the main loop associated with the server is resumed or kept running.
//
// server is still in a working state after this call; you can start and stop a
// server as many times as you want.
//
// Deprecated: When using soup_server_listen(), etc, the server will always
// listen for connections, and will process them whenever the thread-default
// Context is running.
func (server *Server) Quit() {
	var _arg0 *C.SoupServer // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	C.soup_server_quit(_arg0)
	runtime.KeepAlive(server)
}

// RemoveAuthDomain removes auth_domain from server.
//
// The function takes the following parameters:
//
//   - authDomain: AuthDomain.
//
func (server *Server) RemoveAuthDomain(authDomain AuthDomainer) {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.SoupAuthDomain // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(authDomain).Native()))

	C.soup_server_remove_auth_domain(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(authDomain)
}

// RemoveHandler removes all handlers (early and normal) registered at path.
//
// The function takes the following parameters:
//
//   - path: toplevel path for the handler.
//
func (server *Server) RemoveHandler(path string) {
	var _arg0 *C.SoupServer // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_server_remove_handler(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
}

// RemoveWebsocketExtension removes support for WebSocket extension of type
// extension_type (or any subclass of extension_type) from server. You can also
// remove extensions enabled by default from the server at construct time by
// using the SOUP_SERVER_REMOVE_WEBSOCKET_EXTENSION property.
//
// The function takes the following parameters:
//
//   - extensionType: #GType.
//
func (server *Server) RemoveWebsocketExtension(extensionType coreglib.Type) {
	var _arg0 *C.SoupServer // out
	var _arg1 C.GType       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.GType(extensionType)

	C.soup_server_remove_websocket_extension(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(extensionType)
}

// Run starts server, if you are using the old API, causing it to listen
// for and process incoming connections. Unlike soup_server_run_async(),
// this creates a Loop and runs it, and it will not return until someone calls
// soup_server_quit() to stop the server.
//
// Deprecated: When using soup_server_listen(), etc, the server will always
// listen for connections, and will process them whenever the thread-default
// Context is running.
func (server *Server) Run() {
	var _arg0 *C.SoupServer // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	C.soup_server_run(_arg0)
	runtime.KeepAlive(server)
}

// RunAsync starts server, if you are using the old API, causing it to listen
// for and process incoming connections.
//
// The server runs in server's Context. It will not actually perform any
// processing unless the appropriate main loop is running. In the simple case
// where you did not set the server's SOUP_SERVER_ASYNC_CONTEXT property,
// this means the server will run whenever the glib main loop is running.
//
// Deprecated: When using soup_server_listen(), etc, the server will always
// listen for connections, and will process them whenever the thread-default
// Context is running.
func (server *Server) RunAsync() {
	var _arg0 *C.SoupServer // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	C.soup_server_run_async(_arg0)
	runtime.KeepAlive(server)
}

// SetSSLCertFile sets server up to do https, using the SSL/TLS certificate
// specified by ssl_cert_file and ssl_key_file (which may point to the same
// file).
//
// Alternatively, you can set the Server:tls-certificate property at
// construction time, if you already have a Certificate.
//
// The function takes the following parameters:
//
//   - sslCertFile: path to a file containing a PEM-encoded SSL/TLS certificate.
//   - sslKeyFile: path to a file containing a PEM-encoded private key.
//
func (server *Server) SetSSLCertFile(sslCertFile, sslKeyFile string) error {
	var _arg0 *C.SoupServer // out
	var _arg1 *C.char       // out
	var _arg2 *C.char       // out
	var _cerr *C.GError     // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(sslCertFile)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(sslKeyFile)))
	defer C.free(unsafe.Pointer(_arg2))

	C.soup_server_set_ssl_cert_file(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(sslCertFile)
	runtime.KeepAlive(sslKeyFile)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// UnpauseMessage resumes I/O on msg. Use this to resume after calling
// soup_server_pause_message(), or after adding a new chunk to a chunked
// response.
//
// I/O won't actually resume until you return to the main loop.
//
// This must only be called on Messages which were created by the Server and are
// currently doing I/O, such as those passed into a ServerCallback or emitted in
// a Server::request-read signal.
//
// The function takes the following parameters:
//
//   - msg associated with server.
//
func (server *Server) UnpauseMessage(msg *Message) {
	var _arg0 *C.SoupServer  // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_server_unpause_message(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
//   - msg
//   - client
//
func (server *Server) requestAborted(msg *Message, client *ClientContext) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_aborted

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupMessage       // out
	var _arg2 *C.SoupClientContext // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	C._gotk4_soup2_Server_virtual_request_aborted(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(client)
}

// The function takes the following parameters:
//
//   - msg
//   - client
//
func (server *Server) requestFinished(msg *Message, client *ClientContext) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_finished

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupMessage       // out
	var _arg2 *C.SoupClientContext // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	C._gotk4_soup2_Server_virtual_request_finished(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(client)
}

// The function takes the following parameters:
//
//   - msg
//   - client
//
func (server *Server) requestRead(msg *Message, client *ClientContext) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_read

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupMessage       // out
	var _arg2 *C.SoupClientContext // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	C._gotk4_soup2_Server_virtual_request_read(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(client)
}

// The function takes the following parameters:
//
//   - msg
//   - client
//
func (server *Server) requestStarted(msg *Message, client *ClientContext) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_started

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupMessage       // out
	var _arg2 *C.SoupClientContext // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	C._gotk4_soup2_Server_virtual_request_started(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(client)
}

// ClientContext provides additional information about the
// client making a particular request. In particular, you can use
// soup_client_context_get_auth_domain() and soup_client_context_get_auth_user()
// to determine if HTTP authentication was used successfully.
//
// soup_client_context_get_remote_address() and/or
// soup_client_context_get_host() can be used to get information for logging or
// debugging purposes. soup_client_context_get_gsocket() may also be of use in
// some situations (eg, tracking when multiple requests are made on the same
// connection).
//
// An instance of this type is always passed by reference.
type ClientContext struct {
	*clientContext
}

// clientContext is the struct that's finalized.
type clientContext struct {
	native *C.SoupClientContext
}

func marshalClientContext(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &ClientContext{&clientContext{(*C.SoupClientContext)(b)}}, nil
}

// Address retrieves the Address associated with the remote end of a connection.
//
// Deprecated: Use soup_client_context_get_remote_address(), which returns a
// Address.
//
// The function returns the following values:
//
//   - address (optional) with the remote end of a connection, it may be NULL if
//     you used soup_server_accept_iostream().
//
func (client *ClientContext) Address() *Address {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.SoupAddress       // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_address(_arg0)
	runtime.KeepAlive(client)

	var _address *Address // out

	if _cret != nil {
		_address = wrapAddress(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _address
}

// AuthDomain checks whether the request associated with client has been
// authenticated, and if so returns the AuthDomain that authenticated it.
//
// The function returns the following values:
//
//   - authDomain (optional) or NULL if the request was not authenticated.
//
func (client *ClientContext) AuthDomain() AuthDomainer {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.SoupAuthDomain    // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_auth_domain(_arg0)
	runtime.KeepAlive(client)

	var _authDomain AuthDomainer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(AuthDomainer)
				return ok
			})
			rv, ok := casted.(AuthDomainer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching soup.AuthDomainer")
			}
			_authDomain = rv
		}
	}

	return _authDomain
}

// AuthUser checks whether the request associated with client has been
// authenticated, and if so returns the username that the client authenticated
// as.
//
// The function returns the following values:
//
//   - utf8 (optional) authenticated-as user, or NULL if the request was not
//     authenticated.
//
func (client *ClientContext) AuthUser() string {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.char              // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_auth_user(_arg0)
	runtime.KeepAlive(client)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Gsocket retrieves the #GSocket that client is associated with.
//
// If you are using this method to observe when multiple requests are made on
// the same persistent HTTP connection (eg, as the ntlm-test test program does),
// you will need to pay attention to socket destruction as well (eg, by using
// weak references), so that you do not get fooled when the allocator reuses the
// memory address of a previously-destroyed socket to represent a new socket.
//
// The function returns the following values:
//
//   - socket (optional) that client is associated with, NULL if you used
//     soup_server_accept_iostream().
//
func (client *ClientContext) Gsocket() *gio.Socket {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.GSocket           // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_gsocket(_arg0)
	runtime.KeepAlive(client)

	var _socket *gio.Socket // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_socket = &gio.Socket{
				Object: obj,
				DatagramBased: gio.DatagramBased{
					Object: obj,
				},
				Initable: gio.Initable{
					Object: obj,
				},
			}
		}
	}

	return _socket
}

// Host retrieves the IP address associated with the remote end of a connection.
//
// The function returns the following values:
//
//   - utf8 (optional): IP address associated with the remote end of a
//     connection, it may be NULL if you used soup_server_accept_iostream().
//
func (client *ClientContext) Host() string {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.char              // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_host(_arg0)
	runtime.KeepAlive(client)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// LocalAddress retrieves the Address associated with the local end of a
// connection.
//
// The function returns the following values:
//
//   - socketAddress (optional) with the local end of a connection, it may be
//     NULL if you used soup_server_accept_iostream().
//
func (client *ClientContext) LocalAddress() gio.SocketAddresser {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.GSocketAddress    // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_local_address(_arg0)
	runtime.KeepAlive(client)

	var _socketAddress gio.SocketAddresser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.SocketAddresser)
				return ok
			})
			rv, ok := casted.(gio.SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}

	return _socketAddress
}

// RemoteAddress retrieves the Address associated with the remote end of a
// connection.
//
// The function returns the following values:
//
//   - socketAddress (optional) with the remote end of a connection, it may be
//     NULL if you used soup_server_accept_iostream().
//
func (client *ClientContext) RemoteAddress() gio.SocketAddresser {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.GSocketAddress    // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_remote_address(_arg0)
	runtime.KeepAlive(client)

	var _socketAddress gio.SocketAddresser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.SocketAddresser)
				return ok
			})
			rv, ok := casted.(gio.SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}

	return _socketAddress
}

// Socket retrieves the Socket that client is associated with.
//
// If you are using this method to observe when multiple requests are made on
// the same persistent HTTP connection (eg, as the ntlm-test test program does),
// you will need to pay attention to socket destruction as well (either by
// using weak references, or by connecting to the Socket::disconnected signal),
// so that you do not get fooled when the allocator reuses the memory address of
// a previously-destroyed socket to represent a new socket.
//
// Deprecated: use soup_client_context_get_gsocket(), which returns a #GSocket.
//
// The function returns the following values:
//
//   - socket that client is associated with.
//
func (client *ClientContext) Socket() *Socket {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.SoupSocket        // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_socket(_arg0)
	runtime.KeepAlive(client)

	var _socket *Socket // out

	_socket = wrapSocket(coreglib.Take(unsafe.Pointer(_cret)))

	return _socket
}

// StealConnection: "Steals" the HTTP connection associated with client from
// its Server. This happens immediately, regardless of the current state of
// the connection; if the response to the current Message has not yet finished
// being sent, then it will be discarded; you can steal the connection from a
// Message:wrote-informational or Message:wrote-body signal handler if you need
// to wait for part or all of the response to be sent.
//
// Note that when calling this function from C, client will most likely be freed
// as a side effect.
//
// The function returns the following values:
//
//   - ioStream formerly associated with client (or NULL if client was no longer
//     associated with a connection). No guarantees are made about what kind of
//     OStream is returned.
//
func (client *ClientContext) StealConnection() gio.IOStreamer {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.GIOStream         // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_steal_connection(_arg0)
	runtime.KeepAlive(client)

	var _ioStream gio.IOStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.IOStreamer)
			return ok
		})
		rv, ok := casted.(gio.IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}

	return _ioStream
}

// ServerClass: instance of this type is always passed by reference.
type ServerClass struct {
	*serverClass
}

// serverClass is the struct that's finalized.
type serverClass struct {
	native *C.SoupServerClass
}
