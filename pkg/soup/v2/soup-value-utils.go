// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
import "C"

// ValueHashInsertValue inserts value into hash. (Unlike with
// g_hash_table_insert(), both the key and the value are copied).
//
// Deprecated: Use #GVariant API instead.
//
// The function takes the following parameters:
//
//   - hash: value hash.
//   - key: key.
//   - value: value.
//
func ValueHashInsertValue(hash map[string]coreglib.Value, key string, value *coreglib.Value) {
	var _arg1 *C.GHashTable // out
	var _arg2 *C.char       // out
	var _arg3 *C.GValue     // out

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hash {
		var kdst *C.gchar  // out
		var vdst *C.GValue // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.GValue)(unsafe.Pointer((&vsrc).Native()))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.soup_value_hash_insert_value(_arg1, _arg2, _arg3)
	runtime.KeepAlive(hash)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// NewValueHash creates a Table whose keys are strings and whose values are
// #GValue.
//
// Deprecated: Use #GVariant API instead.
//
// The function returns the following values:
//
//   - hashTable: new empty Table.
//
func NewValueHash() map[string]coreglib.Value {
	var _cret *C.GHashTable // in

	_cret = C.soup_value_hash_new()

	var _hashTable map[string]coreglib.Value // out

	_hashTable = make(map[string]coreglib.Value, gextras.HashTableSize(unsafe.Pointer(_cret)))
	gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
		ksrc := *(**C.gchar)(k)
		vsrc := *(**C.GValue)(v)
		var kdst string         // out
		var vdst coreglib.Value // out
		kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
		defer C.free(unsafe.Pointer(ksrc))
		vdst = *coreglib.ValueFromNative(unsafe.Pointer(vsrc))
		runtime.SetFinalizer(vdst, func(v *coreglib.Value) {
			C.g_value_unset((*C.GValue)(unsafe.Pointer(v.Native())))
		})
		_hashTable[kdst] = vdst
	})

	return _hashTable
}
