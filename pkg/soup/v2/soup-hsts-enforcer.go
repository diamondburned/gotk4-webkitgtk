// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void _gotk4_soup2_HSTSEnforcer_ConnectHstsEnforced(gpointer, SoupMessage*, guintptr);
// extern void _gotk4_soup2_HSTSEnforcer_ConnectChanged(gpointer, SoupHSTSPolicy*, SoupHSTSPolicy*, guintptr);
// extern void _gotk4_soup2_HSTSEnforcerClass_hsts_enforced(SoupHSTSEnforcer*, SoupMessage*);
// extern void _gotk4_soup2_HSTSEnforcerClass_changed(SoupHSTSEnforcer*, SoupHSTSPolicy*, SoupHSTSPolicy*);
// extern gboolean _gotk4_soup2_HSTSEnforcerClass_is_persistent(SoupHSTSEnforcer*);
// extern gboolean _gotk4_soup2_HSTSEnforcerClass_has_valid_policy(SoupHSTSEnforcer*, char*);
// gboolean _gotk4_soup2_HSTSEnforcer_virtual_has_valid_policy(void* fnptr, SoupHSTSEnforcer* arg0, char* arg1) {
//   return ((gboolean (*)(SoupHSTSEnforcer*, char*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_soup2_HSTSEnforcer_virtual_is_persistent(void* fnptr, SoupHSTSEnforcer* arg0) {
//   return ((gboolean (*)(SoupHSTSEnforcer*))(fnptr))(arg0);
// };
// void _gotk4_soup2_HSTSEnforcer_virtual_changed(void* fnptr, SoupHSTSEnforcer* arg0, SoupHSTSPolicy* arg1, SoupHSTSPolicy* arg2) {
//   ((void (*)(SoupHSTSEnforcer*, SoupHSTSPolicy*, SoupHSTSPolicy*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_soup2_HSTSEnforcer_virtual_hsts_enforced(void* fnptr, SoupHSTSEnforcer* arg0, SoupMessage* arg1) {
//   ((void (*)(SoupHSTSEnforcer*, SoupMessage*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeHSTSEnforcer = coreglib.Type(C.soup_hsts_enforcer_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeHSTSEnforcer, F: marshalHSTSEnforcer},
	})
}

// HSTSEnforcerOverrides contains methods that are overridable.
type HSTSEnforcerOverrides struct {
	// The function takes the following parameters:
	//
	//   - oldPolicy
	//   - newPolicy
	//
	Changed func(oldPolicy, newPolicy *HSTSPolicy)
	// HasValidPolicy gets whether hsts_enforcer has a currently valid policy
	// for domain.
	//
	// The function takes the following parameters:
	//
	//   - domain: domain.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if access to domain should happen over HTTPS, false
	//     otherwise.
	//
	HasValidPolicy func(domain string) bool
	// The function takes the following parameters:
	//
	HstsEnforced func(message *Message)
	// IsPersistent gets whether hsts_enforcer stores policies persistenly.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if hsts_enforcer storage is persistent or FALSE otherwise.
	//
	IsPersistent func() bool
}

func defaultHSTSEnforcerOverrides(v *HSTSEnforcer) HSTSEnforcerOverrides {
	return HSTSEnforcerOverrides{
		Changed:        v.changed,
		HasValidPolicy: v.hasValidPolicy,
		HstsEnforced:   v.hstsEnforced,
		IsPersistent:   v.isPersistent,
	}
}

type HSTSEnforcer struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SessionFeature
}

var (
	_ coreglib.Objector = (*HSTSEnforcer)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*HSTSEnforcer, *HSTSEnforcerClass, HSTSEnforcerOverrides](
		GTypeHSTSEnforcer,
		initHSTSEnforcerClass,
		wrapHSTSEnforcer,
		defaultHSTSEnforcerOverrides,
	)
}

func initHSTSEnforcerClass(gclass unsafe.Pointer, overrides HSTSEnforcerOverrides, classInitFunc func(*HSTSEnforcerClass)) {
	pclass := (*C.SoupHSTSEnforcerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeHSTSEnforcer))))

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_soup2_HSTSEnforcerClass_changed)
	}

	if overrides.HasValidPolicy != nil {
		pclass.has_valid_policy = (*[0]byte)(C._gotk4_soup2_HSTSEnforcerClass_has_valid_policy)
	}

	if overrides.HstsEnforced != nil {
		pclass.hsts_enforced = (*[0]byte)(C._gotk4_soup2_HSTSEnforcerClass_hsts_enforced)
	}

	if overrides.IsPersistent != nil {
		pclass.is_persistent = (*[0]byte)(C._gotk4_soup2_HSTSEnforcerClass_is_persistent)
	}

	if classInitFunc != nil {
		class := (*HSTSEnforcerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapHSTSEnforcer(obj *coreglib.Object) *HSTSEnforcer {
	return &HSTSEnforcer{
		Object: obj,
		SessionFeature: SessionFeature{
			Object: obj,
		},
	}
}

func marshalHSTSEnforcer(p uintptr) (interface{}, error) {
	return wrapHSTSEnforcer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when hsts_enforcer changes. If a policy has been
// added, new_policy will contain the newly-added policy and old_policy will be
// NULL. If a policy has been deleted, old_policy will contain the to-be-deleted
// policy and new_policy will be NULL. If a policy has been changed, old_policy
// will contain its old value, and new_policy its new value.
//
// Note that you shouldn't modify the policies from a callback to this signal.
func (hstsEnforcer *HSTSEnforcer) ConnectChanged(f func(oldPolicy, newPolicy *HSTSPolicy)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(hstsEnforcer, "changed", false, unsafe.Pointer(C._gotk4_soup2_HSTSEnforcer_ConnectChanged), f)
}

// ConnectHstsEnforced is emitted when hsts_enforcer has upgraded the protocol
// for message to HTTPS as a result of matching its domain with a HSTS policy.
func (hstsEnforcer *HSTSEnforcer) ConnectHstsEnforced(f func(message *Message)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(hstsEnforcer, "hsts-enforced", false, unsafe.Pointer(C._gotk4_soup2_HSTSEnforcer_ConnectHstsEnforced), f)
}

// NewHSTSEnforcer creates a new HSTSEnforcer. The base HSTSEnforcer class does
// not support persistent storage of HSTS policies, see HSTSEnforcerDB for that.
//
// The function returns the following values:
//
//   - hstsEnforcer: new HSTSEnforcer.
//
func NewHSTSEnforcer() *HSTSEnforcer {
	var _cret *C.SoupHSTSEnforcer // in

	_cret = C.soup_hsts_enforcer_new()

	var _hstsEnforcer *HSTSEnforcer // out

	_hstsEnforcer = wrapHSTSEnforcer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _hstsEnforcer
}

// Domains gets a list of domains for which there are policies in enforcer.
//
// The function takes the following parameters:
//
//   - sessionPolicies: whether to include session policies.
//
// The function returns the following values:
//
//   - list: newly allocated list of domains. Use g_list_free_full() and
//     g_free() to free the list.
//
func (hstsEnforcer *HSTSEnforcer) Domains(sessionPolicies bool) []string {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 C.gboolean          // out
	var _cret *C.GList            // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	if sessionPolicies {
		_arg1 = C.TRUE
	}

	_cret = C.soup_hsts_enforcer_get_domains(_arg0, _arg1)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(sessionPolicies)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_list = append(_list, dst)
	})

	return _list
}

// Policies gets a list with the policies in enforcer.
//
// The function takes the following parameters:
//
//   - sessionPolicies: whether to include session policies.
//
// The function returns the following values:
//
//   - list: newly allocated list of policies. Use g_list_free_full() and
//     soup_hsts_policy_free() to free the list.
//
func (hstsEnforcer *HSTSEnforcer) Policies(sessionPolicies bool) []*HSTSPolicy {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 C.gboolean          // out
	var _cret *C.GList            // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	if sessionPolicies {
		_arg1 = C.TRUE
	}

	_cret = C.soup_hsts_enforcer_get_policies(_arg0, _arg1)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(sessionPolicies)

	var _list []*HSTSPolicy // out

	_list = make([]*HSTSPolicy, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupHSTSPolicy)(v)
		var dst *HSTSPolicy // out
		dst = (*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_hsts_policy_free((*C.SoupHSTSPolicy)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// HasValidPolicy gets whether hsts_enforcer has a currently valid policy for
// domain.
//
// The function takes the following parameters:
//
//   - domain: domain.
//
// The function returns the following values:
//
//   - ok: TRUE if access to domain should happen over HTTPS, false otherwise.
//
func (hstsEnforcer *HSTSEnforcer) HasValidPolicy(domain string) bool {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.soup_hsts_enforcer_has_valid_policy(_arg0, _arg1)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(domain)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsPersistent gets whether hsts_enforcer stores policies persistenly.
//
// The function returns the following values:
//
//   - ok: TRUE if hsts_enforcer storage is persistent or FALSE otherwise.
//
func (hstsEnforcer *HSTSEnforcer) IsPersistent() bool {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _cret C.gboolean          // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))

	_cret = C.soup_hsts_enforcer_is_persistent(_arg0)
	runtime.KeepAlive(hstsEnforcer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPolicy sets policy to hsts_enforcer. If policy is expired, any existing
// HSTS policy for its host will be removed instead. If a policy existed
// for this host, it will be replaced. Otherwise, the new policy will be
// inserted. If the policy is a session policy, that is, one created with
// soup_hsts_policy_new_session_policy(), the policy will not expire and will be
// enforced during the lifetime of hsts_enforcer's Session.
//
// The function takes the following parameters:
//
//   - policy of the HSTS host.
//
func (hstsEnforcer *HSTSEnforcer) SetPolicy(policy *HSTSPolicy) {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.SoupHSTSPolicy   // out

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	_arg1 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy)))

	C.soup_hsts_enforcer_set_policy(_arg0, _arg1)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(policy)
}

// SetSessionPolicy sets a session policy for domain. A session policy is a
// policy that is permanent to the lifetime of hsts_enforcer's Session and
// doesn't expire.
//
// The function takes the following parameters:
//
//   - domain: policy domain or hostname.
//   - includeSubdomains: TRUE if the policy applies on sub domains.
//
func (hstsEnforcer *HSTSEnforcer) SetSessionPolicy(domain string, includeSubdomains bool) {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.char             // out
	var _arg2 C.gboolean          // out

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))
	if includeSubdomains {
		_arg2 = C.TRUE
	}

	C.soup_hsts_enforcer_set_session_policy(_arg0, _arg1, _arg2)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(includeSubdomains)
}

// The function takes the following parameters:
//
//   - oldPolicy
//   - newPolicy
//
func (enforcer *HSTSEnforcer) changed(oldPolicy, newPolicy *HSTSPolicy) {
	gclass := (*C.SoupHSTSEnforcerClass)(coreglib.PeekParentClass(enforcer))
	fnarg := gclass.changed

	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.SoupHSTSPolicy   // out
	var _arg2 *C.SoupHSTSPolicy   // out

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(enforcer).Native()))
	_arg1 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(oldPolicy)))
	_arg2 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(newPolicy)))

	C._gotk4_soup2_HSTSEnforcer_virtual_changed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(enforcer)
	runtime.KeepAlive(oldPolicy)
	runtime.KeepAlive(newPolicy)
}

// hasValidPolicy gets whether hsts_enforcer has a currently valid policy for
// domain.
//
// The function takes the following parameters:
//
//   - domain: domain.
//
// The function returns the following values:
//
//   - ok: TRUE if access to domain should happen over HTTPS, false otherwise.
//
func (hstsEnforcer *HSTSEnforcer) hasValidPolicy(domain string) bool {
	gclass := (*C.SoupHSTSEnforcerClass)(coreglib.PeekParentClass(hstsEnforcer))
	fnarg := gclass.has_valid_policy

	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_soup2_HSTSEnforcer_virtual_has_valid_policy(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(hstsEnforcer)
	runtime.KeepAlive(domain)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (enforcer *HSTSEnforcer) hstsEnforced(message *Message) {
	gclass := (*C.SoupHSTSEnforcerClass)(coreglib.PeekParentClass(enforcer))
	fnarg := gclass.hsts_enforced

	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.SoupMessage      // out

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(enforcer).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	C._gotk4_soup2_HSTSEnforcer_virtual_hsts_enforced(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(enforcer)
	runtime.KeepAlive(message)
}

// isPersistent gets whether hsts_enforcer stores policies persistenly.
//
// The function returns the following values:
//
//   - ok: TRUE if hsts_enforcer storage is persistent or FALSE otherwise.
//
func (hstsEnforcer *HSTSEnforcer) isPersistent() bool {
	gclass := (*C.SoupHSTSEnforcerClass)(coreglib.PeekParentClass(hstsEnforcer))
	fnarg := gclass.is_persistent

	var _arg0 *C.SoupHSTSEnforcer // out
	var _cret C.gboolean          // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(coreglib.InternObject(hstsEnforcer).Native()))

	_cret = C._gotk4_soup2_HSTSEnforcer_virtual_is_persistent(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(hstsEnforcer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HSTSEnforcerClass: instance of this type is always passed by reference.
type HSTSEnforcerClass struct {
	*hstsEnforcerClass
}

// hstsEnforcerClass is the struct that's finalized.
type hstsEnforcerClass struct {
	native *C.SoupHSTSEnforcerClass
}
