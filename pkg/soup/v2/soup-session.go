// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void _gotk4_soup2_Session_ConnectTunneling(gpointer, GObject, guintptr);
// extern void _gotk4_soup2_Session_ConnectRequestUnqueued(gpointer, SoupMessage*, guintptr);
// extern void _gotk4_soup2_Session_ConnectRequestStarted(gpointer, SoupMessage*, SoupSocket*, guintptr);
// extern void _gotk4_soup2_Session_ConnectRequestQueued(gpointer, SoupMessage*, guintptr);
// extern void _gotk4_soup2_Session_ConnectConnectionCreated(gpointer, GObject, guintptr);
// extern void _gotk4_soup2_Session_ConnectAuthenticate(gpointer, SoupMessage*, SoupAuth*, gboolean, guintptr);
// extern void _gotk4_soup2_SessionClass_requeue_message(SoupSession*, SoupMessage*);
// extern void _gotk4_soup2_SessionClass_request_started(SoupSession*, SoupMessage*, SoupSocket*);
// extern void _gotk4_soup2_SessionClass_kick(SoupSession*);
// extern void _gotk4_soup2_SessionClass_flush_queue(SoupSession*);
// extern void _gotk4_soup2_SessionClass_cancel_message(SoupSession*, SoupMessage*, guint);
// extern void _gotk4_soup2_SessionClass_authenticate(SoupSession*, SoupMessage*, SoupAuth*, gboolean);
// extern void _gotk4_soup2_SessionClass_auth_required(SoupSession*, SoupMessage*, SoupAuth*, gboolean);
// extern void _gotk4_soup2_SessionCallback(SoupSession*, SoupMessage*, gpointer);
// extern void _gotk4_soup2_AddressCallback(SoupAddress*, guint, gpointer);
// extern guint _gotk4_soup2_SessionClass_send_message(SoupSession*, SoupMessage*);
// guint _gotk4_soup2_Session_virtual_send_message(void* fnptr, SoupSession* arg0, SoupMessage* arg1) {
//   return ((guint (*)(SoupSession*, SoupMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_soup2_Session_virtual_auth_required(void* fnptr, SoupSession* arg0, SoupMessage* arg1, SoupAuth* arg2, gboolean arg3) {
//   ((void (*)(SoupSession*, SoupMessage*, SoupAuth*, gboolean))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_soup2_Session_virtual_authenticate(void* fnptr, SoupSession* arg0, SoupMessage* arg1, SoupAuth* arg2, gboolean arg3) {
//   ((void (*)(SoupSession*, SoupMessage*, SoupAuth*, gboolean))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_soup2_Session_virtual_cancel_message(void* fnptr, SoupSession* arg0, SoupMessage* arg1, guint arg2) {
//   ((void (*)(SoupSession*, SoupMessage*, guint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_soup2_Session_virtual_flush_queue(void* fnptr, SoupSession* arg0) {
//   ((void (*)(SoupSession*))(fnptr))(arg0);
// };
// void _gotk4_soup2_Session_virtual_kick(void* fnptr, SoupSession* arg0) {
//   ((void (*)(SoupSession*))(fnptr))(arg0);
// };
// void _gotk4_soup2_Session_virtual_queue_message(void* fnptr, SoupSession* arg0, SoupMessage* arg1, SoupSessionCallback arg2, gpointer arg3) {
//   ((void (*)(SoupSession*, SoupMessage*, SoupSessionCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_soup2_Session_virtual_request_started(void* fnptr, SoupSession* arg0, SoupMessage* arg1, SoupSocket* arg2) {
//   ((void (*)(SoupSession*, SoupMessage*, SoupSocket*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_soup2_Session_virtual_requeue_message(void* fnptr, SoupSession* arg0, SoupMessage* arg1) {
//   ((void (*)(SoupSession*, SoupMessage*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeSession = coreglib.Type(C.soup_session_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSession, F: marshalSession},
	})
}

// SESSION_ASYNC_CONTEXT alias for the Session:async-context property, qv.
const SESSION_ASYNC_CONTEXT = "async-context"

// SESSION_MAX_CONNS alias for the Session:max-conns property, qv.
const SESSION_MAX_CONNS = "max-conns"

// SESSION_MAX_CONNS_PER_HOST alias for the Session:max-conns-per-host property,
// qv.
const SESSION_MAX_CONNS_PER_HOST = "max-conns-per-host"

// SESSION_PROXY_RESOLVER alias for the Session:proxy-resolver property, qv.
const SESSION_PROXY_RESOLVER = "proxy-resolver"

// SESSION_PROXY_URI alias for the Session:proxy-uri property, qv.
const SESSION_PROXY_URI = "proxy-uri"

// SESSION_SSL_CA_FILE alias for the Session:ssl-ca-file property, qv.
const SESSION_SSL_CA_FILE = "ssl-ca-file"

// SESSION_TIMEOUT alias for the Session:timeout property, qv.
const SESSION_TIMEOUT = "timeout"

// SESSION_USER_AGENT alias for the Session:user-agent property, qv.
const SESSION_USER_AGENT = "user-agent"

// SESSION_USE_NTLM alias for the Session:use-ntlm property, qv.
const SESSION_USE_NTLM = "use-ntlm"

// SessionCallback: prototype for the callback passed to
// soup_session_queue_message(), qv.
type SessionCallback func(session *Session, msg *Message)

// SessionOverrides contains methods that are overridable.
type SessionOverrides struct {
	// The function takes the following parameters:
	//
	//   - msg
	//   - auth
	//   - retrying
	//
	AuthRequired func(msg *Message, auth Auther, retrying bool)
	// The function takes the following parameters:
	//
	//   - msg
	//   - auth
	//   - retrying
	//
	Authenticate func(msg *Message, auth Auther, retrying bool)
	// CancelMessage causes session to immediately finish processing
	// msg (regardless of its current state) with a final status_code
	// of status_code. You may call this at any time after handing msg
	// off to session; if session has started sending the request but
	// has not yet received the complete response, then it will close
	// the request's connection. Note that with requests that have side
	// effects (eg, <literal>POST</literal>, <literal>PUT</literal>,
	// <literal>DELETE</literal>) it is possible that you might cancel the
	// request after the server acts on it, but before it returns a response,
	// leaving the remote resource in an unknown state.
	//
	// If the message is cancelled while its response body is being read, then
	// the response body in msg will be left partially-filled-in. The response
	// headers, on the other hand, will always be either empty or complete.
	//
	// Beware that with the deprecated SessionAsync, messages queued with
	// soup_session_queue_message() will have their callbacks invoked before
	// soup_session_cancel_message() returns. The plain Session does not have
	// this behavior; cancelling an asynchronous message will merely queue its
	// callback to be run after returning to the main loop.
	//
	// The function takes the following parameters:
	//
	//   - msg: message to cancel.
	//   - statusCode status code to set on msg (generally
	//     SOUP_STATUS_CANCELLED).
	//
	CancelMessage func(msg *Message, statusCode uint)
	FlushQueue    func()
	Kick          func()
	// The function takes the following parameters:
	//
	//   - msg
	//   - socket
	//
	RequestStarted func(msg *Message, socket *Socket)
	// RequeueMessage: this causes msg to be placed back on the queue to be
	// attempted again.
	//
	// The function takes the following parameters:
	//
	//   - msg: message to requeue.
	//
	RequeueMessage func(msg *Message)
	// SendMessage: synchronously send msg. This call will not return until the
	// transfer is finished successfully or there is an unrecoverable error.
	//
	// Unlike with soup_session_queue_message(), msg is not freed upon return.
	//
	// (Note that if you call this method on a SessionAsync, it will still use
	// asynchronous I/O internally, running the glib main loop to process the
	// message, which may also cause other events to be processed.)
	//
	// Contrast this method with soup_session_send(), which also synchronously
	// sends a message, but returns before reading the response body, and allows
	// you to read the response via a Stream.
	//
	// The function takes the following parameters:
	//
	//   - msg: message to send.
	//
	// The function returns the following values:
	//
	//   - guint: HTTP status code of the response.
	//
	SendMessage func(msg *Message) uint
}

func defaultSessionOverrides(v *Session) SessionOverrides {
	return SessionOverrides{
		AuthRequired:   v.authRequired,
		Authenticate:   v.authenticate,
		CancelMessage:  v.cancelMessage,
		FlushQueue:     v.flushQueue,
		Kick:           v.kick,
		RequestStarted: v.requestStarted,
		RequeueMessage: v.requeueMessage,
		SendMessage:    v.sendMessage,
	}
}

type Session struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Session)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Session, *SessionClass, SessionOverrides](
		GTypeSession,
		initSessionClass,
		wrapSession,
		defaultSessionOverrides,
	)
}

func initSessionClass(gclass unsafe.Pointer, overrides SessionOverrides, classInitFunc func(*SessionClass)) {
	pclass := (*C.SoupSessionClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSession))))

	if overrides.AuthRequired != nil {
		pclass.auth_required = (*[0]byte)(C._gotk4_soup2_SessionClass_auth_required)
	}

	if overrides.Authenticate != nil {
		pclass.authenticate = (*[0]byte)(C._gotk4_soup2_SessionClass_authenticate)
	}

	if overrides.CancelMessage != nil {
		pclass.cancel_message = (*[0]byte)(C._gotk4_soup2_SessionClass_cancel_message)
	}

	if overrides.FlushQueue != nil {
		pclass.flush_queue = (*[0]byte)(C._gotk4_soup2_SessionClass_flush_queue)
	}

	if overrides.Kick != nil {
		pclass.kick = (*[0]byte)(C._gotk4_soup2_SessionClass_kick)
	}

	if overrides.RequestStarted != nil {
		pclass.request_started = (*[0]byte)(C._gotk4_soup2_SessionClass_request_started)
	}

	if overrides.RequeueMessage != nil {
		pclass.requeue_message = (*[0]byte)(C._gotk4_soup2_SessionClass_requeue_message)
	}

	if overrides.SendMessage != nil {
		pclass.send_message = (*[0]byte)(C._gotk4_soup2_SessionClass_send_message)
	}

	if classInitFunc != nil {
		class := (*SessionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSession(obj *coreglib.Object) *Session {
	return &Session{
		Object: obj,
	}
}

func marshalSession(p uintptr) (interface{}, error) {
	return wrapSession(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAuthenticate is emitted when the session requires authentication.
// If credentials are available call soup_auth_authenticate() on auth.
// If these credentials fail, the signal will be emitted again, with retrying
// set to TRUE, which will continue until you return without calling
// soup_auth_authenticate() on auth.
//
// Note that this may be emitted before msg's body has been fully read.
//
// If you call soup_session_pause_message() on msg before returning, then you
// can authenticate auth asynchronously (as long as you g_object_ref() it to
// make sure it doesn't get destroyed), and then unpause msg when you are ready
// for it to continue.
func (session *Session) ConnectAuthenticate(f func(msg *Message, auth Auther, retrying bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "authenticate", false, unsafe.Pointer(C._gotk4_soup2_Session_ConnectAuthenticate), f)
}

// ConnectConnectionCreated is emitted when a new connection is created.
// This is an internal signal intended only to be used for debugging purposes,
// and may go away in the future.
func (session *Session) ConnectConnectionCreated(f func(connection *coreglib.Object)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "connection-created", false, unsafe.Pointer(C._gotk4_soup2_Session_ConnectConnectionCreated), f)
}

// ConnectRequestQueued is emitted when a request is queued on session.
// (Note that "queued" doesn't just mean soup_session_queue_message();
// soup_session_send_message() implicitly queues the message as well.)
//
// When sending a request, first Session::request_queued is emitted, indicating
// that the session has become aware of the request.
//
// Once a connection is available to send the request on, the session
// emits Session::request_started. Then, various Message signals are
// emitted as the message is processed. If the message is requeued,
// it will emit Message::restarted, which will then be followed by another
// Session::request_started and another set of Message signals when the message
// is re-sent.
//
// Eventually, the message will emit Message::finished. Normally, this signals
// the completion of message processing. However, it is possible that the
// application will requeue the message from the "finished" handler (or
// equivalently, from the soup_session_queue_message() callback). In that case,
// the process will loop back to Session::request_started.
//
// Eventually, a message will reach "finished" and not be requeued. At that
// point, the session will emit Session::request_unqueued to indicate that it is
// done with the message.
//
// To sum up: Session::request_queued and Session::request_unqueued are
// guaranteed to be emitted exactly once, but Session::request_started and
// Message::finished (and all of the other Message signals) may be invoked
// multiple times for a given message.
func (session *Session) ConnectRequestQueued(f func(msg *Message)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "request-queued", false, unsafe.Pointer(C._gotk4_soup2_Session_ConnectRequestQueued), f)
}

// ConnectRequestStarted is emitted just before a request is sent. See
// Session::request_queued for a detailed description of the message lifecycle
// within a session.
func (session *Session) ConnectRequestStarted(f func(msg *Message, socket *Socket)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "request-started", false, unsafe.Pointer(C._gotk4_soup2_Session_ConnectRequestStarted), f)
}

// ConnectRequestUnqueued is emitted when a request is removed from session's
// queue, indicating that session is done with it. See Session::request_queued
// for a detailed description of the message lifecycle within a session.
func (session *Session) ConnectRequestUnqueued(f func(msg *Message)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "request-unqueued", false, unsafe.Pointer(C._gotk4_soup2_Session_ConnectRequestUnqueued), f)
}

// ConnectTunneling is emitted when an SSL tunnel is being created on a proxy
// connection. This is an internal signal intended only to be used for debugging
// purposes, and may go away in the future.
func (session *Session) ConnectTunneling(f func(connection *coreglib.Object)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "tunneling", false, unsafe.Pointer(C._gotk4_soup2_Session_ConnectTunneling), f)
}

// NewSession creates a Session with the default options.
//
// The function returns the following values:
//
//   - session: new session.
//
func NewSession() *Session {
	var _cret *C.SoupSession // in

	_cret = C.soup_session_new()

	var _session *Session // out

	_session = wrapSession(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _session
}

// Abort cancels all pending requests in session and closes all idle persistent
// connections.
//
// The message cancellation has the same semantics as with
// soup_session_cancel_message(); asynchronous requests on a SessionAsync will
// have their callback called before soup_session_abort() returns. Requests on a
// plain Session will not.
func (session *Session) Abort() {
	var _arg0 *C.SoupSession // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	C.soup_session_abort(_arg0)
	runtime.KeepAlive(session)
}

// AddFeature adds feature's functionality to session. You can
// also add a feature to the session at construct time by using the
// SOUP_SESSION_ADD_FEATURE property.
//
// See the main Session documentation for information on what features are
// present in sessions by default.
//
// The function takes the following parameters:
//
//   - feature: object that implements SessionFeature.
//
func (session *Session) AddFeature(feature SessionFeaturer) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupSessionFeature // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupSessionFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	C.soup_session_add_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(feature)
}

// AddFeatureByType: if feature_type is the type of a class that implements
// SessionFeature, this creates a new feature of that type and adds it to
// session as with soup_session_add_feature(). You can use this when you don't
// need to customize the new feature in any way.
//
// If feature_type is not a SessionFeature type, this gives each existing
// feature on session the chance to accept feature_type as a "subfeature".
// This can be used to add new Auth or Request types, for instance.
//
// You can also add a feature to the session at construct time by using the
// SOUP_SESSION_ADD_FEATURE_BY_TYPE property.
//
// See the main Session documentation for information on what features are
// present in sessions by default.
//
// The function takes the following parameters:
//
//   - featureType: #GType.
//
func (session *Session) AddFeatureByType(featureType coreglib.Type) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	C.soup_session_add_feature_by_type(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)
}

// CancelMessage causes session to immediately finish processing msg (regardless
// of its current state) with a final status_code of status_code. You may
// call this at any time after handing msg off to session; if session has
// started sending the request but has not yet received the complete response,
// then it will close the request's connection. Note that with requests that
// have side effects (eg, <literal>POST</literal>, <literal>PUT</literal>,
// <literal>DELETE</literal>) it is possible that you might cancel the request
// after the server acts on it, but before it returns a response, leaving the
// remote resource in an unknown state.
//
// If the message is cancelled while its response body is being read, then the
// response body in msg will be left partially-filled-in. The response headers,
// on the other hand, will always be either empty or complete.
//
// Beware that with the deprecated SessionAsync, messages queued with
// soup_session_queue_message() will have their callbacks invoked before
// soup_session_cancel_message() returns. The plain Session does not have this
// behavior; cancelling an asynchronous message will merely queue its callback
// to be run after returning to the main loop.
//
// The function takes the following parameters:
//
//   - msg: message to cancel.
//   - statusCode status code to set on msg (generally SOUP_STATUS_CANCELLED).
//
func (session *Session) CancelMessage(msg *Message, statusCode uint) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _arg2 C.guint        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = C.guint(statusCode)

	C.soup_session_cancel_message(_arg0, _arg1, _arg2)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(statusCode)
}

// ConnectFinish gets the OStream created for the connection to communicate with
// the server.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - ioStream: new OStream, or NULL on error.
//
func (session *Session) ConnectFinish(result gio.AsyncResulter) (gio.IOStreamer, error) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GIOStream    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_connect_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _ioStream gio.IOStreamer // out
	var _goerr error             // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.IOStreamer)
			return ok
		})
		rv, ok := casted.(gio.IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioStream, _goerr
}

// AsyncContext gets session's Session:async-context. This does not add a ref to
// the context, so you will need to ref it yourself if you want it to outlive
// its session.
//
// For a modern Session, this will always just return the thread-default
// Context, and so is not especially useful.
//
// The function returns the following values:
//
//   - mainContext (optional) session's Context, which may be NULL.
//
func (session *Session) AsyncContext() *glib.MainContext {
	var _arg0 *C.SoupSession  // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_async_context(_arg0)
	runtime.KeepAlive(session)

	var _mainContext *glib.MainContext // out

	if _cret != nil {
		_mainContext = (*glib.MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_main_context_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_mainContext)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_main_context_unref((*C.GMainContext)(intern.C))
			},
		)
	}

	return _mainContext
}

// Feature gets the first feature in session of type feature_type.
// For features where there may be more than one feature of a given type,
// use soup_session_get_features().
//
// The function takes the following parameters:
//
//   - featureType of the feature to get.
//
// The function returns the following values:
//
//   - sessionFeature (optional) or NULL. The feature is owned by session.
//
func (session *Session) Feature(featureType coreglib.Type) *SessionFeature {
	var _arg0 *C.SoupSession        // out
	var _arg1 C.GType               // out
	var _cret *C.SoupSessionFeature // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_session_get_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)

	var _sessionFeature *SessionFeature // out

	if _cret != nil {
		_sessionFeature = wrapSessionFeature(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _sessionFeature
}

// FeatureForMessage gets the first feature in session of type feature_type,
// provided that it is not disabled for msg. As with soup_session_get_feature(),
// this should only be used for features where feature_type is only expected to
// match a single feature. In particular, if there are two matching features,
// and the first is disabled on msg, and the second is not, then this will
// return NULL, not the second feature.
//
// The function takes the following parameters:
//
//   - featureType of the feature to get.
//   - msg: Message.
//
// The function returns the following values:
//
//   - sessionFeature (optional) or NULL. The feature is owned by session.
//
func (session *Session) FeatureForMessage(featureType coreglib.Type, msg *Message) *SessionFeature {
	var _arg0 *C.SoupSession        // out
	var _arg1 C.GType               // out
	var _arg2 *C.SoupMessage        // out
	var _cret *C.SoupSessionFeature // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)
	_arg2 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_get_feature_for_message(_arg0, _arg1, _arg2)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)
	runtime.KeepAlive(msg)

	var _sessionFeature *SessionFeature // out

	if _cret != nil {
		_sessionFeature = wrapSessionFeature(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _sessionFeature
}

// Features generates a list of session's features of type feature_type.
// (If you want to see all features, you can pass SOUP_TYPE_SESSION_FEATURE for
// feature_type.).
//
// The function takes the following parameters:
//
//   - featureType of the class of features to get.
//
// The function returns the following values:
//
//   - sList: a list of features. You must free the list, but not its contents.
//
func (session *Session) Features(featureType coreglib.Type) []*SessionFeature {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out
	var _cret *C.GSList      // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_session_get_features(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)

	var _sList []*SessionFeature // out

	_sList = make([]*SessionFeature, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupSessionFeature)(v)
		var dst *SessionFeature // out
		dst = wrapSessionFeature(coreglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// HasFeature tests if session has at a feature of type feature_type (which
// can be the type of either a SessionFeature, or else a subtype of some class
// managed by another feature, such as Auth or Request).
//
// The function takes the following parameters:
//
//   - featureType of the class of features to check for.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE.
//
func (session *Session) HasFeature(featureType coreglib.Type) bool {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_session_has_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PauseMessage pauses HTTP I/O on msg. Call soup_session_unpause_message() to
// resume I/O.
//
// This may only be called for asynchronous messages (those sent on a
// SessionAsync or using soup_session_queue_message()).
//
// The function takes the following parameters:
//
//   - msg currently running on session.
//
func (session *Session) PauseMessage(msg *Message) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_session_pause_message(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
}

// PrefetchDns tells session that an URI from the given hostname may be
// requested shortly, and so the session can try to prepare by resolving
// the domain name in advance, in order to work more quickly once the URI is
// actually requested.
//
// If cancellable is non-NULL, it can be used to cancel the resolution. callback
// will still be invoked in this case, with a status of SOUP_STATUS_CANCELLED.
//
// The function takes the following parameters:
//
//   - ctx (optional) object, or NULL.
//   - hostname to be resolved.
//   - callback (optional) to call with the result, or NULL.
//
func (session *Session) PrefetchDns(ctx context.Context, hostname string, callback AddressCallback) {
	var _arg0 *C.SoupSession        // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg3 C.SoupAddressCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_soup2_AddressCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.soup_session_prefetch_dns(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(session)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(callback)
}

// PrepareForURI tells session that uri may be requested shortly, and so the
// session can try to prepare (resolving the domain name, obtaining proxy
// address, etc.) in order to work more quickly once the URI is actually
// requested.
//
// Deprecated: use soup_session_prefetch_dns() instead.
//
// The function takes the following parameters:
//
//   - uri which may be required.
//
func (session *Session) PrepareForURI(uri *URI) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupURI     // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))

	C.soup_session_prepare_for_uri(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(uri)
}

// QueueMessage queues the message msg for asynchronously sending the request
// and receiving a response in the current thread-default Context. If msg has
// been processed before, any resources related to the time it was last sent are
// freed.
//
// Upon message completion, the callback specified in callback will be invoked.
// If after returning from this callback the message has not been requeued,
// msg will be unreffed.
//
// (The behavior above applies to a plain Session; if you are using SessionAsync
// or SessionSync, then the Context that is used depends on the settings of
// Session:async-context and Session:use-thread-context, and for SessionSync,
// the message will actually be sent and processed in another thread, with only
// the final callback occurring in the indicated Context.)
//
// Contrast this method with soup_session_send_async(), which also
// asynchronously sends a message, but returns before reading the response body,
// and allows you to read the response via a Stream.
//
// The function takes the following parameters:
//
//   - msg: message to queue.
//   - callback (optional) which will be called after the message completes or
//     when an unrecoverable error occurs.
//
func (session *Session) QueueMessage(msg *Message, callback SessionCallback) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupMessage        // out
	var _arg2 C.SoupSessionCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(msg).Native()))
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_soup2_SessionCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.soup_session_queue_message(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(callback)
}

// RedirectMessage updates msg's URI according to its status code and
// "Location" header, and requeues it on session. Use this when you have set
// SOUP_MESSAGE_NO_REDIRECT on a message, but have decided to allow a particular
// redirection to occur, or if you want to allow a redirection that Session will
// not perform automatically (eg, redirecting a non-safe method such as DELETE).
//
// If msg's status code indicates that it should be retried as a GET request,
// then msg will be modified accordingly.
//
// If msg has already been redirected too many times, this will cause it to fail
// with SOUP_STATUS_TOO_MANY_REDIRECTS.
//
// The function takes the following parameters:
//
//   - msg that has received a 3xx response.
//
// The function returns the following values:
//
//   - ok: TRUE if a redirection was applied, FALSE if not (eg, because there
//     was no Location header, or it could not be parsed).
//
func (session *Session) RedirectMessage(msg *Message) bool {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_redirect_message(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveFeature removes feature's functionality from session.
//
// The function takes the following parameters:
//
//   - feature that has previously been added to session.
//
func (session *Session) RemoveFeature(feature SessionFeaturer) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupSessionFeature // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupSessionFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	C.soup_session_remove_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(feature)
}

// RemoveFeatureByType removes all features of type feature_type (or
// any subclass of feature_type) from session. You can also remove
// standard features from the session at construct time by using the
// SOUP_SESSION_REMOVE_FEATURE_BY_TYPE property.
//
// The function takes the following parameters:
//
//   - featureType: #GType.
//
func (session *Session) RemoveFeatureByType(featureType coreglib.Type) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	C.soup_session_remove_feature_by_type(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)
}

// Request creates a Request for retrieving uri_string.
//
// The function takes the following parameters:
//
//   - uriString: URI, in string form.
//
// The function returns the following values:
//
//   - request: new Request, or NULL on error.
//
func (session *Session) Request(uriString string) (*Request, error) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.char        // out
	var _cret *C.SoupRequest // in
	var _cerr *C.GError      // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.soup_session_request(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(uriString)

	var _request *Request // out
	var _goerr error      // out

	_request = wrapRequest(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _request, _goerr
}

// RequestHTTP creates a Request for retrieving uri_string, which must
// be an "http" or "https" URI (or another protocol listed in session's
// Session:http-aliases or Session:https-aliases).
//
// The function takes the following parameters:
//
//   - method: HTTP method.
//   - uriString: URI, in string form.
//
// The function returns the following values:
//
//   - requestHTTP: new RequestHTTP, or NULL on error.
//
func (session *Session) RequestHTTP(method, uriString string) (*RequestHTTP, error) {
	var _arg0 *C.SoupSession     // out
	var _arg1 *C.char            // out
	var _arg2 *C.char            // out
	var _cret *C.SoupRequestHTTP // in
	var _cerr *C.GError          // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.soup_session_request_http(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(method)
	runtime.KeepAlive(uriString)

	var _requestHTTP *RequestHTTP // out
	var _goerr error              // out

	_requestHTTP = wrapRequestHTTP(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _requestHTTP, _goerr
}

// RequestHTTPURI creates a Request for retrieving uri, which must be an "http"
// or "https" URI (or another protocol listed in session's Session:http-aliases
// or Session:https-aliases).
//
// The function takes the following parameters:
//
//   - method: HTTP method.
//   - uri representing the URI to retrieve.
//
// The function returns the following values:
//
//   - requestHTTP: new RequestHTTP, or NULL on error.
//
func (session *Session) RequestHTTPURI(method string, uri *URI) (*RequestHTTP, error) {
	var _arg0 *C.SoupSession     // out
	var _arg1 *C.char            // out
	var _arg2 *C.SoupURI         // out
	var _cret *C.SoupRequestHTTP // in
	var _cerr *C.GError          // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.soup_session_request_http_uri(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(method)
	runtime.KeepAlive(uri)

	var _requestHTTP *RequestHTTP // out
	var _goerr error              // out

	_requestHTTP = wrapRequestHTTP(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _requestHTTP, _goerr
}

// RequestURI creates a Request for retrieving uri.
//
// The function takes the following parameters:
//
//   - uri representing the URI to retrieve.
//
// The function returns the following values:
//
//   - request: new Request, or NULL on error.
//
func (session *Session) RequestURI(uri *URI) (*Request, error) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupURI     // out
	var _cret *C.SoupRequest // in
	var _cerr *C.GError      // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.soup_session_request_uri(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(uri)

	var _request *Request // out
	var _goerr error      // out

	_request = wrapRequest(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _request, _goerr
}

// RequeueMessage: this causes msg to be placed back on the queue to be
// attempted again.
//
// The function takes the following parameters:
//
//   - msg: message to requeue.
//
func (session *Session) RequeueMessage(msg *Message) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_session_requeue_message(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
}

// Send: synchronously sends msg and waits for the beginning of a response.
// On success, a Stream will be returned which you can use to read the response
// body. ("Success" here means only that an HTTP response was received and
// understood; it does not necessarily mean that a 2xx class status code was
// received.)
//
// If non-NULL, cancellable can be used to cancel the request;
// soup_session_send() will return a G_IO_ERROR_CANCELLED error. Note that
// with requests that have side effects (eg, <literal>POST</literal>,
// <literal>PUT</literal>, <literal>DELETE</literal>) it is possible that you
// might cancel the request after the server acts on it, but before it returns a
// response, leaving the remote resource in an unknown state.
//
// If msg is requeued due to a redirect or authentication, the initial
// (3xx/401/407) response body will be suppressed, and soup_session_send() will
// only return once a final response has been received.
//
// Contrast this method with soup_session_send_message(), which also
// synchronously sends a Message, but doesn't return until the response has been
// completely read.
//
// (Note that this method cannot be called on the deprecated SessionAsync
// subclass.).
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - msg: Message.
//
// The function returns the following values:
//
//   - inputStream for reading the response body, or NULL on error.
//
func (session *Session) Send(ctx context.Context, msg *Message) (gio.InputStreamer, error) {
	var _arg0 *C.SoupSession  // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.SoupMessage  // out
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_send(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(msg)

	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.InputStreamer)
			return ok
		})
		rv, ok := casted.(gio.InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}

// SendFinish gets the response to a soup_session_send_async() call and (if
// successful), returns a Stream that can be used to read the response body.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - inputStream for reading the response body, or NULL on error.
//
func (session *Session) SendFinish(result gio.AsyncResulter) (gio.InputStreamer, error) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_send_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.InputStreamer)
			return ok
		})
		rv, ok := casted.(gio.InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}

// SendMessage: synchronously send msg. This call will not return until the
// transfer is finished successfully or there is an unrecoverable error.
//
// Unlike with soup_session_queue_message(), msg is not freed upon return.
//
// (Note that if you call this method on a SessionAsync, it will still use
// asynchronous I/O internally, running the glib main loop to process the
// message, which may also cause other events to be processed.)
//
// Contrast this method with soup_session_send(), which also synchronously sends
// a message, but returns before reading the response body, and allows you to
// read the response via a Stream.
//
// The function takes the following parameters:
//
//   - msg: message to send.
//
// The function returns the following values:
//
//   - guint: HTTP status code of the response.
//
func (session *Session) SendMessage(msg *Message) uint {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _cret C.guint        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_send_message(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// StealConnection: "Steals" the HTTP connection associated with msg from
// session. This happens immediately, regardless of the current state of
// the connection, and msg's callback will not be called. You can steal the
// connection from a Message signal handler if you need to wait for part or all
// of the response to be received first.
//
// Calling this function may cause msg to be freed if you are not holding any
// other reference to it.
//
// The function takes the following parameters:
//
//   - msg: message whose connection is to be stolen.
//
// The function returns the following values:
//
//   - ioStream formerly associated with msg (or NULL if msg was no longer
//     associated with a connection). No guarantees are made about what kind of
//     OStream is returned.
//
func (session *Session) StealConnection(msg *Message) gio.IOStreamer {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _cret *C.GIOStream   // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_steal_connection(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)

	var _ioStream gio.IOStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.IOStreamer)
			return ok
		})
		rv, ok := casted.(gio.IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}

	return _ioStream
}

// UnpauseMessage resumes HTTP I/O on msg. Use this to resume after calling
// soup_session_pause_message().
//
// If msg is being sent via blocking I/O, this will resume reading or writing
// immediately. If msg is using non-blocking I/O, then reading or writing won't
// resume until you return to the main loop.
//
// This may only be called for asynchronous messages (those sent on a
// SessionAsync or using soup_session_queue_message()).
//
// The function takes the following parameters:
//
//   - msg currently running on session.
//
func (session *Session) UnpauseMessage(msg *Message) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_session_unpause_message(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
}

// WebsocketConnectFinish gets the WebsocketConnection response to a
// soup_session_websocket_connect_async() call and (if successful), returns a
// WebsocketConnection that can be used to communicate with the server.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - websocketConnection: new WebsocketConnection, or NULL on error.
//
func (session *Session) WebsocketConnectFinish(result gio.AsyncResulter) (*WebsocketConnection, error) {
	var _arg0 *C.SoupSession             // out
	var _arg1 *C.GAsyncResult            // out
	var _cret *C.SoupWebsocketConnection // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_websocket_connect_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _websocketConnection *WebsocketConnection // out
	var _goerr error                              // out

	_websocketConnection = wrapWebsocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _websocketConnection, _goerr
}

// WouldRedirect checks if msg contains a response that would cause session
// to redirect it to a new URL (ignoring msg's SOUP_MESSAGE_NO_REDIRECT flag,
// and the number of times it has already been redirected).
//
// The function takes the following parameters:
//
//   - msg that has response headers.
//
// The function returns the following values:
//
//   - ok: whether msg would be redirected.
//
func (session *Session) WouldRedirect(msg *Message) bool {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_would_redirect(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - msg
//   - auth
//   - retrying
//
func (session *Session) authRequired(msg *Message, auth Auther, retrying bool) {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.auth_required

	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _arg2 *C.SoupAuth    // out
	var _arg3 C.gboolean     // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = (*C.SoupAuth)(unsafe.Pointer(coreglib.InternObject(auth).Native()))
	if retrying {
		_arg3 = C.TRUE
	}

	C._gotk4_soup2_Session_virtual_auth_required(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(auth)
	runtime.KeepAlive(retrying)
}

// The function takes the following parameters:
//
//   - msg
//   - auth
//   - retrying
//
func (session *Session) authenticate(msg *Message, auth Auther, retrying bool) {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.authenticate

	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _arg2 *C.SoupAuth    // out
	var _arg3 C.gboolean     // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = (*C.SoupAuth)(unsafe.Pointer(coreglib.InternObject(auth).Native()))
	if retrying {
		_arg3 = C.TRUE
	}

	C._gotk4_soup2_Session_virtual_authenticate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(auth)
	runtime.KeepAlive(retrying)
}

// cancelMessage causes session to immediately finish processing msg (regardless
// of its current state) with a final status_code of status_code. You may
// call this at any time after handing msg off to session; if session has
// started sending the request but has not yet received the complete response,
// then it will close the request's connection. Note that with requests that
// have side effects (eg, <literal>POST</literal>, <literal>PUT</literal>,
// <literal>DELETE</literal>) it is possible that you might cancel the request
// after the server acts on it, but before it returns a response, leaving the
// remote resource in an unknown state.
//
// If the message is cancelled while its response body is being read, then the
// response body in msg will be left partially-filled-in. The response headers,
// on the other hand, will always be either empty or complete.
//
// Beware that with the deprecated SessionAsync, messages queued with
// soup_session_queue_message() will have their callbacks invoked before
// soup_session_cancel_message() returns. The plain Session does not have this
// behavior; cancelling an asynchronous message will merely queue its callback
// to be run after returning to the main loop.
//
// The function takes the following parameters:
//
//   - msg: message to cancel.
//   - statusCode status code to set on msg (generally SOUP_STATUS_CANCELLED).
//
func (session *Session) cancelMessage(msg *Message, statusCode uint) {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.cancel_message

	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _arg2 C.guint        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = C.guint(statusCode)

	C._gotk4_soup2_Session_virtual_cancel_message(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(statusCode)
}

func (session *Session) flushQueue() {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.flush_queue

	var _arg0 *C.SoupSession // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	C._gotk4_soup2_Session_virtual_flush_queue(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(session)
}

func (session *Session) kick() {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.kick

	var _arg0 *C.SoupSession // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	C._gotk4_soup2_Session_virtual_kick(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(session)
}

// queueMessage queues the message msg for asynchronously sending the request
// and receiving a response in the current thread-default Context. If msg has
// been processed before, any resources related to the time it was last sent are
// freed.
//
// Upon message completion, the callback specified in callback will be invoked.
// If after returning from this callback the message has not been requeued,
// msg will be unreffed.
//
// (The behavior above applies to a plain Session; if you are using SessionAsync
// or SessionSync, then the Context that is used depends on the settings of
// Session:async-context and Session:use-thread-context, and for SessionSync,
// the message will actually be sent and processed in another thread, with only
// the final callback occurring in the indicated Context.)
//
// Contrast this method with soup_session_send_async(), which also
// asynchronously sends a message, but returns before reading the response body,
// and allows you to read the response via a Stream.
//
// The function takes the following parameters:
//
//   - msg: message to queue.
//   - callback (optional) which will be called after the message completes or
//     when an unrecoverable error occurs.
//
func (session *Session) queueMessage(msg *Message, callback SessionCallback) {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.queue_message

	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupMessage        // out
	var _arg2 C.SoupSessionCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(msg).Native()))
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_soup2_SessionCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_soup2_Session_virtual_queue_message(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(callback)
}

// The function takes the following parameters:
//
//   - msg
//   - socket
//
func (session *Session) requestStarted(msg *Message, socket *Socket) {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.request_started

	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _arg2 *C.SoupSocket  // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = (*C.SoupSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	C._gotk4_soup2_Session_virtual_request_started(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(socket)
}

// requeueMessage: this causes msg to be placed back on the queue to be
// attempted again.
//
// The function takes the following parameters:
//
//   - msg: message to requeue.
//
func (session *Session) requeueMessage(msg *Message) {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.requeue_message

	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup2_Session_virtual_requeue_message(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
}

// sendMessage: synchronously send msg. This call will not return until the
// transfer is finished successfully or there is an unrecoverable error.
//
// Unlike with soup_session_queue_message(), msg is not freed upon return.
//
// (Note that if you call this method on a SessionAsync, it will still use
// asynchronous I/O internally, running the glib main loop to process the
// message, which may also cause other events to be processed.)
//
// Contrast this method with soup_session_send(), which also synchronously sends
// a message, but returns before reading the response body, and allows you to
// read the response via a Stream.
//
// The function takes the following parameters:
//
//   - msg: message to send.
//
// The function returns the following values:
//
//   - guint: HTTP status code of the response.
//
func (session *Session) sendMessage(msg *Message) uint {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.send_message

	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _cret C.guint        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C._gotk4_soup2_Session_virtual_send_message(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SessionClass: instance of this type is always passed by reference.
type SessionClass struct {
	*sessionClass
}

// sessionClass is the struct that's finalized.
type sessionClass struct {
	native *C.SoupSessionClass
}
