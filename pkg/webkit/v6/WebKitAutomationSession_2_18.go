// Code generated by girgen. DO NOT EDIT.

package webkit

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit/webkit.h>
// extern WebKitWebView* _gotk4_webkit6_AutomationSession_ConnectCreateWebView(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeAutomationSession = coreglib.Type(C.webkit_automation_session_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAutomationSession, F: marshalAutomationSession},
	})
}

// AutomationSessionOverrides contains methods that are overridable.
type AutomationSessionOverrides struct {
}

func defaultAutomationSessionOverrides(v *AutomationSession) AutomationSessionOverrides {
	return AutomationSessionOverrides{}
}

// AutomationSession: automation Session.
//
// WebKitAutomationSession represents an automation session of a
// WebKitWebContext. When a new session is requested, a WebKitAutomationSession
// is created and the signal WebKitWebContext::automation-started is emitted
// with the WebKitAutomationSession as argument. Then, the automation client can
// request the session to create a new KitWebView to interact with it. When this
// happens the signal KitAutomationSession::create-web-view is emitted.
type AutomationSession struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AutomationSession)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AutomationSession, *AutomationSessionClass, AutomationSessionOverrides](
		GTypeAutomationSession,
		initAutomationSessionClass,
		wrapAutomationSession,
		defaultAutomationSessionOverrides,
	)
}

func initAutomationSessionClass(gclass unsafe.Pointer, overrides AutomationSessionOverrides, classInitFunc func(*AutomationSessionClass)) {
	if classInitFunc != nil {
		class := (*AutomationSessionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAutomationSession(obj *coreglib.Object) *AutomationSession {
	return &AutomationSession{
		Object: obj,
	}
}

func marshalAutomationSession(p uintptr) (interface{}, error) {
	return wrapAutomationSession(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCreateWebView: this signal is emitted when the automation
// client requests a new browsing context to interact with it.
// The callback handler should return a KitWebView created with
// KitWebView:is-controlled-by-automation construct property enabled and
// KitWebView:automation-presentation-type construct property set if needed.
//
// If the signal is emitted with "tab" detail, the returned KitWebView should
// be a new web view added to a new tab of the current browsing context window.
// If the signal is emitted with "window" detail, the returned KitWebView
// should be a new web view added to a new window. When creating a new web view
// and there's an active browsing context, the new window or tab shouldn't be
// focused.
func (session *AutomationSession) ConnectCreateWebView(f func() (webView *WebView)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "create-web-view", false, unsafe.Pointer(C._gotk4_webkit6_AutomationSession_ConnectCreateWebView), f)
}

// ApplicationInfo: get the the previously set KitAutomationSession.
//
// Get the KitAutomationSession previously set with
// webkit_automation_session_set_application_info().
//
// The function returns the following values:
//
//   - applicationInfo of session, or NULL if no one has been set.
//
func (session *AutomationSession) ApplicationInfo() *ApplicationInfo {
	var _arg0 *C.WebKitAutomationSession // out
	var _cret *C.WebKitApplicationInfo   // in

	_arg0 = (*C.WebKitAutomationSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.webkit_automation_session_get_application_info(_arg0)
	runtime.KeepAlive(session)

	var _applicationInfo *ApplicationInfo // out

	_applicationInfo = (*ApplicationInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.webkit_application_info_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_applicationInfo)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_application_info_unref((*C.WebKitApplicationInfo)(intern.C))
		},
	)

	return _applicationInfo
}

// ID: get the unique identifier of a KitAutomationSession.
//
// The function returns the following values:
//
//   - utf8: unique identifier of session.
//
func (session *AutomationSession) ID() string {
	var _arg0 *C.WebKitAutomationSession // out
	var _cret *C.char                    // in

	_arg0 = (*C.WebKitAutomationSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.webkit_automation_session_get_id(_arg0)
	runtime.KeepAlive(session)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SetApplicationInfo: set the application information to session.
//
// This information will be used by the driver service to match the requested
// capabilities with the actual application information. If this information
// is not provided to the session when a new automation session is requested,
// the creation might fail if the client requested a specific browser name or
// version. This will not have any effect when called after the automation
// session has been fully created, so this must be called in the callback of
// KitWebContext::automation-started signal.
//
// The function takes the following parameters:
//
//   - info: KitApplicationInfo.
//
func (session *AutomationSession) SetApplicationInfo(info *ApplicationInfo) {
	var _arg0 *C.WebKitAutomationSession // out
	var _arg1 *C.WebKitApplicationInfo   // out

	_arg0 = (*C.WebKitAutomationSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.WebKitApplicationInfo)(gextras.StructNative(unsafe.Pointer(info)))

	C.webkit_automation_session_set_application_info(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(info)
}
