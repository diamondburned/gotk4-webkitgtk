// Code generated by girgen. DO NOT EDIT.

package webkit

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit/webkit.h>
import "C"

// GType values.
var (
	GTypeUserContentFilterStore = coreglib.Type(C.webkit_user_content_filter_store_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeUserContentFilterStore, F: marshalUserContentFilterStore},
	})
}

// UserContentFilterStoreOverrides contains methods that are overridable.
type UserContentFilterStoreOverrides struct {
}

func defaultUserContentFilterStoreOverrides(v *UserContentFilterStore) UserContentFilterStoreOverrides {
	return UserContentFilterStoreOverrides{}
}

// UserContentFilterStore handles storage of user content filters on disk.
//
// The WebKitUserContentFilterStore provides the means to import and save JSON
// rule sets (https://webkit.org/blog/3476/content-blockers-first-look/),
// which can be loaded later in an efficient manner. Once filters are stored,
// the KitUserContentFilter objects which represent them can be added to a
// KitUserContentManager with webkit_user_content_manager_add_filter().
//
// JSON rule sets are imported using webkit_user_content_filter_store_save()
// and stored on disk in an implementation defined format.
// The contents of a filter store must be managed using the
// KitUserContentFilterStore: a list of all the stored filters can be
// obtained with webkit_user_content_filter_store_fetch_identifiers(),
// webkit_user_content_filter_store_load() can be used to retrieve
// a previously saved filter, and removed from the store with
// webkit_user_content_filter_store_remove().
type UserContentFilterStore struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*UserContentFilterStore)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*UserContentFilterStore, *UserContentFilterStoreClass, UserContentFilterStoreOverrides](
		GTypeUserContentFilterStore,
		initUserContentFilterStoreClass,
		wrapUserContentFilterStore,
		defaultUserContentFilterStoreOverrides,
	)
}

func initUserContentFilterStoreClass(gclass unsafe.Pointer, overrides UserContentFilterStoreOverrides, classInitFunc func(*UserContentFilterStoreClass)) {
	if classInitFunc != nil {
		class := (*UserContentFilterStoreClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapUserContentFilterStore(obj *coreglib.Object) *UserContentFilterStore {
	return &UserContentFilterStore{
		Object: obj,
	}
}

func marshalUserContentFilterStore(p uintptr) (interface{}, error) {
	return wrapUserContentFilterStore(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewUserContentFilterStore: create a new KitUserContentFilterStore to
// manipulate filters stored at storage_path.
//
// The path must point to a local filesystem, and will be created if needed.
//
// The function takes the following parameters:
//
//   - storagePath: path where data for filters will be stored on disk.
//
// The function returns the following values:
//
//   - userContentFilterStore: newly created KitUserContentFilterStore.
//
func NewUserContentFilterStore(storagePath string) *UserContentFilterStore {
	var _arg1 *C.gchar                        // out
	var _cret *C.WebKitUserContentFilterStore // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(storagePath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.webkit_user_content_filter_store_new(_arg1)
	runtime.KeepAlive(storagePath)

	var _userContentFilterStore *UserContentFilterStore // out

	_userContentFilterStore = wrapUserContentFilterStore(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _userContentFilterStore
}

// FetchIdentifiersFinish finishes an asynchronous fetch of the list of stored
// filters.
//
// Finishes an asynchronous fetch of the list of identifiers
// for the stored filters previously started with
// webkit_user_content_filter_store_fetch_identifiers().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated list of filter identifiers.
//
func (store *UserContentFilterStore) FetchIdentifiersFinish(result gio.AsyncResulter) []string {
	var _arg0 *C.WebKitUserContentFilterStore // out
	var _arg1 *C.GAsyncResult                 // out
	var _cret **C.gchar                       // in

	_arg0 = (*C.WebKitUserContentFilterStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.webkit_user_content_filter_store_fetch_identifiers_finish(_arg0, _arg1)
	runtime.KeepAlive(store)
	runtime.KeepAlive(result)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Path gets the storage path for user content filters.
//
// The function returns the following values:
//
//   - utf8: path, as a string.
//
func (store *UserContentFilterStore) Path() string {
	var _arg0 *C.WebKitUserContentFilterStore // out
	var _cret *C.gchar                        // in

	_arg0 = (*C.WebKitUserContentFilterStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))

	_cret = C.webkit_user_content_filter_store_get_path(_arg0)
	runtime.KeepAlive(store)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// LoadFinish finishes an asynchronous filter load previously started with
// webkit_user_content_filter_store_load().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - userContentFilter or NULL if the load failed.
//
func (store *UserContentFilterStore) LoadFinish(result gio.AsyncResulter) (*UserContentFilter, error) {
	var _arg0 *C.WebKitUserContentFilterStore // out
	var _arg1 *C.GAsyncResult                 // out
	var _cret *C.WebKitUserContentFilter      // in
	var _cerr *C.GError                       // in

	_arg0 = (*C.WebKitUserContentFilterStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.webkit_user_content_filter_store_load_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(store)
	runtime.KeepAlive(result)

	var _userContentFilter *UserContentFilter // out
	var _goerr error                          // out

	_userContentFilter = (*UserContentFilter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_userContentFilter)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_user_content_filter_unref((*C.WebKitUserContentFilter)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _userContentFilter, _goerr
}

// RemoveFinish finishes an asynchronous filter removal previously started with
// webkit_user_content_filter_store_remove().
//
// The function takes the following parameters:
//
//   - result: Result.
//
func (store *UserContentFilterStore) RemoveFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitUserContentFilterStore // out
	var _arg1 *C.GAsyncResult                 // out
	var _cerr *C.GError                       // in

	_arg0 = (*C.WebKitUserContentFilterStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.webkit_user_content_filter_store_remove_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(store)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SaveFinish finishes an asynchronous filter save previously started with
// webkit_user_content_filter_store_save().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - userContentFilter or NULL if saving failed.
//
func (store *UserContentFilterStore) SaveFinish(result gio.AsyncResulter) (*UserContentFilter, error) {
	var _arg0 *C.WebKitUserContentFilterStore // out
	var _arg1 *C.GAsyncResult                 // out
	var _cret *C.WebKitUserContentFilter      // in
	var _cerr *C.GError                       // in

	_arg0 = (*C.WebKitUserContentFilterStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.webkit_user_content_filter_store_save_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(store)
	runtime.KeepAlive(result)

	var _userContentFilter *UserContentFilter // out
	var _goerr error                          // out

	_userContentFilter = (*UserContentFilter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_userContentFilter)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_user_content_filter_unref((*C.WebKitUserContentFilter)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _userContentFilter, _goerr
}

// SaveFromFileFinish finishes and asynchronous filter save previously started
// with webkit_user_content_filter_store_save_from_file().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - userContentFilter or NULL if saving failed.
//
func (store *UserContentFilterStore) SaveFromFileFinish(result gio.AsyncResulter) (*UserContentFilter, error) {
	var _arg0 *C.WebKitUserContentFilterStore // out
	var _arg1 *C.GAsyncResult                 // out
	var _cret *C.WebKitUserContentFilter      // in
	var _cerr *C.GError                       // in

	_arg0 = (*C.WebKitUserContentFilterStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.webkit_user_content_filter_store_save_from_file_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(store)
	runtime.KeepAlive(result)

	var _userContentFilter *UserContentFilter // out
	var _goerr error                          // out

	_userContentFilter = (*UserContentFilter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_userContentFilter)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_user_content_filter_unref((*C.WebKitUserContentFilter)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _userContentFilter, _goerr
}
