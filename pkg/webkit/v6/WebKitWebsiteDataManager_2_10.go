// Code generated by girgen. DO NOT EDIT.

package webkit

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit/webkit.h>
import "C"

// GType values.
var (
	GTypeWebsiteDataManager = coreglib.Type(C.webkit_website_data_manager_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeWebsiteDataManager, F: marshalWebsiteDataManager},
	})
}

// WebsiteDataManagerOverrides contains methods that are overridable.
type WebsiteDataManagerOverrides struct {
}

func defaultWebsiteDataManagerOverrides(v *WebsiteDataManager) WebsiteDataManagerOverrides {
	return WebsiteDataManagerOverrides{}
}

// WebsiteDataManager manages data stored locally by web sites.
//
// You can use WebKitWebsiteDataManager to configure the local directories where
// website data will be stored. Use KitWebsiteDataManager:base-data-directory
// and KitWebsiteDataManager:base-cache-directory set a common base directory
// for all website data and caches.
//
// A WebKitWebsiteDataManager can be ephemeral, in which case all the
// directory configuration is not needed because website data will never
// persist. You can create an ephemeral WebKitWebsiteDataManager with
// webkit_website_data_manager_new_ephemeral().
//
// WebKitWebsiteDataManager can also be used to fetch website data, remove data
// stored by particular websites, or clear data for all websites modified since
// a given period of time.
type WebsiteDataManager struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*WebsiteDataManager)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*WebsiteDataManager, *WebsiteDataManagerClass, WebsiteDataManagerOverrides](
		GTypeWebsiteDataManager,
		initWebsiteDataManagerClass,
		wrapWebsiteDataManager,
		defaultWebsiteDataManagerOverrides,
	)
}

func initWebsiteDataManagerClass(gclass unsafe.Pointer, overrides WebsiteDataManagerOverrides, classInitFunc func(*WebsiteDataManagerClass)) {
	if classInitFunc != nil {
		class := (*WebsiteDataManagerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWebsiteDataManager(obj *coreglib.Object) *WebsiteDataManager {
	return &WebsiteDataManager{
		Object: obj,
	}
}

func marshalWebsiteDataManager(p uintptr) (interface{}, error) {
	return wrapWebsiteDataManager(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ClearFinish: finish an asynchronous operation started with
// webkit_website_data_manager_clear().
//
// The function takes the following parameters:
//
//   - result: Result.
//
func (manager *WebsiteDataManager) ClearFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 *C.GAsyncResult             // out
	var _cerr *C.GError                   // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.webkit_website_data_manager_clear_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// FetchFinish: finish an asynchronous operation started with
// webkit_website_data_manager_fetch().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - list of KitWebsiteData. You must free the #GList with g_list_free() and
//     unref the KitWebsiteData<!-- -->s with webkit_website_data_unref() when
//     you're done with them.
//
func (manager *WebsiteDataManager) FetchFinish(result gio.AsyncResulter) ([]*WebsiteData, error) {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 *C.GAsyncResult             // out
	var _cret *C.GList                    // in
	var _cerr *C.GError                   // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.webkit_website_data_manager_fetch_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(result)

	var _list []*WebsiteData // out
	var _goerr error         // out

	_list = make([]*WebsiteData, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.WebKitWebsiteData)(v)
		var dst *WebsiteData // out
		dst = (*WebsiteData)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.webkit_website_data_unref((*C.WebKitWebsiteData)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// BaseCacheDirectory: get the KitWebsiteDataManager:base-cache-directory
// property.
//
// The function returns the following values:
//
//   - utf8 (optional): base directory for caches, or NULL if
//     KitWebsiteDataManager:base-cache-directory was not provided or manager is
//     ephemeral.
//
func (manager *WebsiteDataManager) BaseCacheDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.webkit_website_data_manager_get_base_cache_directory(_arg0)
	runtime.KeepAlive(manager)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// BaseDataDirectory: get the KitWebsiteDataManager:base-data-directory
// property.
//
// The function returns the following values:
//
//   - utf8 (optional): base directory for website data, or NULL if
//     KitWebsiteDataManager:base-data-directory was not provided or manager is
//     ephemeral.
//
func (manager *WebsiteDataManager) BaseDataDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.webkit_website_data_manager_get_base_data_directory(_arg0)
	runtime.KeepAlive(manager)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// FaviconDatabase: get the KitFaviconDatabase of manager.
//
// The function returns the following values:
//
//   - faviconDatabase (optional) or NULL if website icons are disabled.
//
func (manager *WebsiteDataManager) FaviconDatabase() *FaviconDatabase {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.WebKitFaviconDatabase    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.webkit_website_data_manager_get_favicon_database(_arg0)
	runtime.KeepAlive(manager)

	var _faviconDatabase *FaviconDatabase // out

	if _cret != nil {
		_faviconDatabase = wrapFaviconDatabase(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _faviconDatabase
}

// FaviconsEnabled: get whether website icons are enabled.
//
// The function returns the following values:
//
//   - ok: TRUE if website icons are enabled, or FALSE otherwise.
//
func (manager *WebsiteDataManager) FaviconsEnabled() bool {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.webkit_website_data_manager_get_favicons_enabled(_arg0)
	runtime.KeepAlive(manager)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ItpSummaryFinish: finish an asynchronous operation started with
// webkit_website_data_manager_get_itp_summary().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - list of KitITPThirdParty. You must free the #GList with g_list_free() and
//     unref the KitITPThirdParty<!-- -->s with webkit_itp_third_party_unref()
//     when you're done with them.
//
func (manager *WebsiteDataManager) ItpSummaryFinish(result gio.AsyncResulter) ([]*ITPThirdParty, error) {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 *C.GAsyncResult             // out
	var _cret *C.GList                    // in
	var _cerr *C.GError                   // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.webkit_website_data_manager_get_itp_summary_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(result)

	var _list []*ITPThirdParty // out
	var _goerr error           // out

	_list = make([]*ITPThirdParty, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.WebKitITPThirdParty)(v)
		var dst *ITPThirdParty // out
		dst = (*ITPThirdParty)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.webkit_itp_third_party_unref((*C.WebKitITPThirdParty)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// IsEphemeral: get whether a KitWebsiteDataManager is ephemeral.
//
// See KitWebsiteDataManager:is-ephemeral for more details.
//
// The function returns the following values:
//
//   - ok: TRUE if manager is ephemeral or FALSE otherwise.
//
func (manager *WebsiteDataManager) IsEphemeral() bool {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.webkit_website_data_manager_is_ephemeral(_arg0)
	runtime.KeepAlive(manager)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveFinish: finish an asynchronous operation started with
// webkit_website_data_manager_remove().
//
// The function takes the following parameters:
//
//   - result: Result.
//
func (manager *WebsiteDataManager) RemoveFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 *C.GAsyncResult             // out
	var _cerr *C.GError                   // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.webkit_website_data_manager_remove_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetFaviconsEnabled: set whether website icons are enabled. Website
// icons are disabled by default. When website icons are disabled,
// the KitFaviconDatabase of manager is closed and its reference removed,
// so webkit_website_data_manager_get_favicon_database() will return NULL.
// If website icons are enabled again, a new KitFaviconDatabase will be created.
//
// The function takes the following parameters:
//
//   - enabled: value to set.
//
func (manager *WebsiteDataManager) SetFaviconsEnabled(enabled bool) {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 C.gboolean                  // out

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_website_data_manager_set_favicons_enabled(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(enabled)
}
