// Code generated by girgen. DO NOT EDIT.

package webkit

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4-webkitgtk/pkg/soup/v3"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit/webkit.h>
// extern void _gotk4_webkit6_CookieManager_ConnectChanged(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeCookieAcceptPolicy      = coreglib.Type(C.webkit_cookie_accept_policy_get_type())
	GTypeCookiePersistentStorage = coreglib.Type(C.webkit_cookie_persistent_storage_get_type())
	GTypeCookieManager           = coreglib.Type(C.webkit_cookie_manager_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCookieAcceptPolicy, F: marshalCookieAcceptPolicy},
		coreglib.TypeMarshaler{T: GTypeCookiePersistentStorage, F: marshalCookiePersistentStorage},
		coreglib.TypeMarshaler{T: GTypeCookieManager, F: marshalCookieManager},
	})
}

// CookieAcceptPolicy: enum values used to denote the cookie acceptance
// policies.
type CookieAcceptPolicy C.gint

const (
	// CookiePolicyAcceptAlways: accept all cookies unconditionally.
	CookiePolicyAcceptAlways CookieAcceptPolicy = iota
	// CookiePolicyAcceptNever: reject all cookies unconditionally.
	CookiePolicyAcceptNever
	// CookiePolicyAcceptNoThirdParty: accept only cookies set by the main
	// document loaded.
	CookiePolicyAcceptNoThirdParty
)

func marshalCookieAcceptPolicy(p uintptr) (interface{}, error) {
	return CookieAcceptPolicy(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CookieAcceptPolicy.
func (c CookieAcceptPolicy) String() string {
	switch c {
	case CookiePolicyAcceptAlways:
		return "Always"
	case CookiePolicyAcceptNever:
		return "Never"
	case CookiePolicyAcceptNoThirdParty:
		return "NoThirdParty"
	default:
		return fmt.Sprintf("CookieAcceptPolicy(%d)", c)
	}
}

// CookiePersistentStorage: enum values used to denote the cookie persistent
// storage types.
type CookiePersistentStorage C.gint

const (
	// CookiePersistentStorageText cookies are stored in a text file in the
	// Mozilla "cookies.txt" format.
	CookiePersistentStorageText CookiePersistentStorage = iota
	// CookiePersistentStorageSqlite cookies are stored in a SQLite file in the
	// current Mozilla format.
	CookiePersistentStorageSqlite
)

func marshalCookiePersistentStorage(p uintptr) (interface{}, error) {
	return CookiePersistentStorage(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CookiePersistentStorage.
func (c CookiePersistentStorage) String() string {
	switch c {
	case CookiePersistentStorageText:
		return "Text"
	case CookiePersistentStorageSqlite:
		return "Sqlite"
	default:
		return fmt.Sprintf("CookiePersistentStorage(%d)", c)
	}
}

// CookieManagerOverrides contains methods that are overridable.
type CookieManagerOverrides struct {
}

func defaultCookieManagerOverrides(v *CookieManager) CookieManagerOverrides {
	return CookieManagerOverrides{}
}

// CookieManager defines how to handle cookies in a KitWebContext.
//
// The WebKitCookieManager defines how to set up and handle
// cookies. You can get it from a KitWebsiteDataManager with
// webkit_website_data_manager_get_cookie_manager(), and use it to set where to
// store cookies with webkit_cookie_manager_set_persistent_storage(), or to set
// the acceptance policy, with webkit_cookie_manager_get_accept_policy().
type CookieManager struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*CookieManager)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CookieManager, *CookieManagerClass, CookieManagerOverrides](
		GTypeCookieManager,
		initCookieManagerClass,
		wrapCookieManager,
		defaultCookieManagerOverrides,
	)
}

func initCookieManagerClass(gclass unsafe.Pointer, overrides CookieManagerOverrides, classInitFunc func(*CookieManagerClass)) {
	if classInitFunc != nil {
		class := (*CookieManagerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCookieManager(obj *coreglib.Object) *CookieManager {
	return &CookieManager{
		Object: obj,
	}
}

func marshalCookieManager(p uintptr) (interface{}, error) {
	return wrapCookieManager(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged: this signal is emitted when cookies are added, removed or
// modified.
func (cookieManager *CookieManager) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(cookieManager, "changed", false, unsafe.Pointer(C._gotk4_webkit6_CookieManager_ConnectChanged), f)
}

// AddCookieFinish: finish an asynchronous operation started with
// webkit_cookie_manager_add_cookie().
//
// The function takes the following parameters:
//
//   - result: Result.
//
func (cookieManager *CookieManager) AddCookieFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitCookieManager // out
	var _arg1 *C.GAsyncResult        // out
	var _cerr *C.GError              // in

	_arg0 = (*C.WebKitCookieManager)(unsafe.Pointer(coreglib.InternObject(cookieManager).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.webkit_cookie_manager_add_cookie_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(cookieManager)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// DeleteCookieFinish: finish an asynchronous operation started with
// webkit_cookie_manager_delete_cookie().
//
// The function takes the following parameters:
//
//   - result: Result.
//
func (cookieManager *CookieManager) DeleteCookieFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitCookieManager // out
	var _arg1 *C.GAsyncResult        // out
	var _cerr *C.GError              // in

	_arg0 = (*C.WebKitCookieManager)(unsafe.Pointer(coreglib.InternObject(cookieManager).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.webkit_cookie_manager_delete_cookie_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(cookieManager)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AcceptPolicyFinish: finish an asynchronous operation started with
// webkit_cookie_manager_get_accept_policy().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - cookieAcceptPolicy: cookie acceptance policy of cookie_manager as a
//     KitCookieAcceptPolicy.
//
func (cookieManager *CookieManager) AcceptPolicyFinish(result gio.AsyncResulter) (CookieAcceptPolicy, error) {
	var _arg0 *C.WebKitCookieManager     // out
	var _arg1 *C.GAsyncResult            // out
	var _cret C.WebKitCookieAcceptPolicy // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.WebKitCookieManager)(unsafe.Pointer(coreglib.InternObject(cookieManager).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.webkit_cookie_manager_get_accept_policy_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(cookieManager)
	runtime.KeepAlive(result)

	var _cookieAcceptPolicy CookieAcceptPolicy // out
	var _goerr error                           // out

	_cookieAcceptPolicy = CookieAcceptPolicy(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _cookieAcceptPolicy, _goerr
}

// AllCookiesFinish: finish an asynchronous operation started with
// webkit_cookie_manager_get_all_cookies().
//
// The return value is a List of Cookie instances which should be released with
// g_list_free_full() and soup_cookie_free().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - list of Cookie instances.
//
func (cookieManager *CookieManager) AllCookiesFinish(result gio.AsyncResulter) ([]*soup.Cookie, error) {
	var _arg0 *C.WebKitCookieManager // out
	var _arg1 *C.GAsyncResult        // out
	var _cret *C.GList               // in
	var _cerr *C.GError              // in

	_arg0 = (*C.WebKitCookieManager)(unsafe.Pointer(coreglib.InternObject(cookieManager).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.webkit_cookie_manager_get_all_cookies_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(cookieManager)
	runtime.KeepAlive(result)

	var _list []*soup.Cookie // out
	var _goerr error         // out

	_list = make([]*soup.Cookie, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupCookie)(v)
		var dst *soup.Cookie // out
		dst = (*soup.Cookie)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_cookie_free((*C.SoupCookie)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// CookiesFinish: finish an asynchronous operation started with
// webkit_cookie_manager_get_cookies().
//
// The return value is a List of Cookie instances which should be released with
// g_list_free_full() and soup_cookie_free().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - list of Cookie instances.
//
func (cookieManager *CookieManager) CookiesFinish(result gio.AsyncResulter) ([]*soup.Cookie, error) {
	var _arg0 *C.WebKitCookieManager // out
	var _arg1 *C.GAsyncResult        // out
	var _cret *C.GList               // in
	var _cerr *C.GError              // in

	_arg0 = (*C.WebKitCookieManager)(unsafe.Pointer(coreglib.InternObject(cookieManager).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.webkit_cookie_manager_get_cookies_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(cookieManager)
	runtime.KeepAlive(result)

	var _list []*soup.Cookie // out
	var _goerr error         // out

	_list = make([]*soup.Cookie, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupCookie)(v)
		var dst *soup.Cookie // out
		dst = (*soup.Cookie)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_cookie_free((*C.SoupCookie)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// ReplaceCookiesFinish: finish an asynchronous operation started with
// webkit_cookie_manager_replace_cookies().
//
// The function takes the following parameters:
//
//   - result: Result.
//
func (cookieManager *CookieManager) ReplaceCookiesFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitCookieManager // out
	var _arg1 *C.GAsyncResult        // out
	var _cerr *C.GError              // in

	_arg0 = (*C.WebKitCookieManager)(unsafe.Pointer(coreglib.InternObject(cookieManager).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.webkit_cookie_manager_replace_cookies_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(cookieManager)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAcceptPolicy: set the cookie acceptance policy of cookie_manager as
// policy.
//
// Note that ITP has its own way to handle third-party cookies, so when it's
// enabled, and policy is set to WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY,
// WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS will be used instead. Once disabled,
// the policy will be set back to WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY.
// See also webkit_website_data_manager_set_itp_enabled().
//
// The function takes the following parameters:
//
//   - policy: KitCookieAcceptPolicy.
//
func (cookieManager *CookieManager) SetAcceptPolicy(policy CookieAcceptPolicy) {
	var _arg0 *C.WebKitCookieManager     // out
	var _arg1 C.WebKitCookieAcceptPolicy // out

	_arg0 = (*C.WebKitCookieManager)(unsafe.Pointer(coreglib.InternObject(cookieManager).Native()))
	_arg1 = C.WebKitCookieAcceptPolicy(policy)

	C.webkit_cookie_manager_set_accept_policy(_arg0, _arg1)
	runtime.KeepAlive(cookieManager)
	runtime.KeepAlive(policy)
}

// SetPersistentStorage: set non-session cookies.
//
// Set the filename where non-session cookies are stored persistently using
// storage as the format to read/write the cookies. Cookies are initially read
// from filename to create an initial set of cookies. Then, non-session cookies
// will be written to filename when the WebKitCookieManager::changed signal is
// emitted. By default, cookie_manager doesn't store the cookies persistently,
// so you need to call this method to keep cookies saved across sessions.
//
// This method should never be called on a KitCookieManager associated to an
// ephemeral KitWebsiteDataManager.
//
// The function takes the following parameters:
//
//   - filename to read to/write from.
//   - storage: KitCookiePersistentStorage.
//
func (cookieManager *CookieManager) SetPersistentStorage(filename string, storage CookiePersistentStorage) {
	var _arg0 *C.WebKitCookieManager          // out
	var _arg1 *C.gchar                        // out
	var _arg2 C.WebKitCookiePersistentStorage // out

	_arg0 = (*C.WebKitCookieManager)(unsafe.Pointer(coreglib.InternObject(cookieManager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.WebKitCookiePersistentStorage(storage)

	C.webkit_cookie_manager_set_persistent_storage(_arg0, _arg1, _arg2)
	runtime.KeepAlive(cookieManager)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(storage)
}

// CookieManagerClass: instance of this type is always passed by reference.
type CookieManagerClass struct {
	*cookieManagerClass
}

// cookieManagerClass is the struct that's finalized.
type cookieManagerClass struct {
	native *C.WebKitCookieManagerClass
}
