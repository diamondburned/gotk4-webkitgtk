// Code generated by girgen. DO NOT EDIT.

package webkit

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit/webkit.h>
// extern void _gotk4_webkit6_NetworkSession_ConnectDownloadStarted(gpointer, WebKitDownload*, guintptr);
import "C"

// GType values.
var (
	GTypeNetworkSession = coreglib.Type(C.webkit_network_session_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeNetworkSession, F: marshalNetworkSession},
	})
}

// NetworkSessionOverrides contains methods that are overridable.
type NetworkSessionOverrides struct {
}

func defaultNetworkSessionOverrides(v *NetworkSession) NetworkSessionOverrides {
	return NetworkSessionOverrides{}
}

// NetworkSession manages network configuration.
type NetworkSession struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*NetworkSession)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*NetworkSession, *NetworkSessionClass, NetworkSessionOverrides](
		GTypeNetworkSession,
		initNetworkSessionClass,
		wrapNetworkSession,
		defaultNetworkSessionOverrides,
	)
}

func initNetworkSessionClass(gclass unsafe.Pointer, overrides NetworkSessionOverrides, classInitFunc func(*NetworkSessionClass)) {
	if classInitFunc != nil {
		class := (*NetworkSessionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNetworkSession(obj *coreglib.Object) *NetworkSession {
	return &NetworkSession{
		Object: obj,
	}
}

func marshalNetworkSession(p uintptr) (interface{}, error) {
	return wrapNetworkSession(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDownloadStarted: this signal is emitted when a new download request is
// made.
func (session *NetworkSession) ConnectDownloadStarted(f func(download *Download)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "download-started", false, unsafe.Pointer(C._gotk4_webkit6_NetworkSession_ConnectDownloadStarted), f)
}

// NewNetworkSession creates a new KitNetworkSession with a
// persistent KitWebsiteDataManager. The parameters data_directory
// and cache_directory will be used as construct properties of the
// KitWebsiteDataManager of the network session. Note that if NULL is
// passed, the default directory will be passed to KitWebsiteDataManager
// so that webkit_website_data_manager_get_base_data_directory() and
// webkit_website_data_manager_get_base_cache_directory() always return a value
// for non ephemeral sessions.
//
// It must be passed as construct parameter of a KitWebView.
//
// The function takes the following parameters:
//
//   - dataDirectory (optional): base directory for data, or NULL.
//   - cacheDirectory (optional): base directory for caches, or NULL.
//
// The function returns the following values:
//
//   - networkSession: newly created KitNetworkSession.
//
func NewNetworkSession(dataDirectory, cacheDirectory string) *NetworkSession {
	var _arg1 *C.char                 // out
	var _arg2 *C.char                 // out
	var _cret *C.WebKitNetworkSession // in

	if dataDirectory != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(dataDirectory)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if cacheDirectory != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(cacheDirectory)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.webkit_network_session_new(_arg1, _arg2)
	runtime.KeepAlive(dataDirectory)
	runtime.KeepAlive(cacheDirectory)

	var _networkSession *NetworkSession // out

	_networkSession = wrapNetworkSession(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _networkSession
}

// NewNetworkSessionEphemeral creates a new KitNetworkSession with an ephemeral
// KitWebsiteDataManager.
//
// The function returns the following values:
//
//   - networkSession: new ephemeral KitNetworkSession.
//
func NewNetworkSessionEphemeral() *NetworkSession {
	var _cret *C.WebKitNetworkSession // in

	_cret = C.webkit_network_session_new_ephemeral()

	var _networkSession *NetworkSession // out

	_networkSession = wrapNetworkSession(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _networkSession
}

// AllowTLSCertificateForHost: ignore further TLS errors on the host for the
// certificate present in info.
//
// The function takes the following parameters:
//
//   - certificate: Certificate.
//   - host for which a certificate is to be allowed.
//
func (session *NetworkSession) AllowTLSCertificateForHost(certificate gio.TLSCertificater, host string) {
	var _arg0 *C.WebKitNetworkSession // out
	var _arg1 *C.GTlsCertificate      // out
	var _arg2 *C.char                 // out

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(host)))
	defer C.free(unsafe.Pointer(_arg2))

	C.webkit_network_session_allow_tls_certificate_for_host(_arg0, _arg1, _arg2)
	runtime.KeepAlive(session)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(host)
}

// DownloadURI requests downloading of the specified URI string.
//
// The download operation will not be associated to any KitWebView, if you
// are interested in starting a download from a particular KitWebView use
// webkit_web_view_download_uri() instead.
//
// The function takes the following parameters:
//
//   - uri: URI to download.
//
// The function returns the following values:
//
//   - download: new KitDownload representing the download operation.
//
func (session *NetworkSession) DownloadURI(uri string) *Download {
	var _arg0 *C.WebKitNetworkSession // out
	var _arg1 *C.char                 // out
	var _cret *C.WebKitDownload       // in

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.webkit_network_session_download_uri(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(uri)

	var _download *Download // out

	_download = wrapDownload(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _download
}

// CookieManager: get the KitCookieManager of session.
//
// The function returns the following values:
//
//   - cookieManager: KitCookieManager.
//
func (session *NetworkSession) CookieManager() *CookieManager {
	var _arg0 *C.WebKitNetworkSession // out
	var _cret *C.WebKitCookieManager  // in

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.webkit_network_session_get_cookie_manager(_arg0)
	runtime.KeepAlive(session)

	var _cookieManager *CookieManager // out

	_cookieManager = wrapCookieManager(coreglib.Take(unsafe.Pointer(_cret)))

	return _cookieManager
}

// ItpEnabled: get whether Intelligent Tracking Prevention (ITP) is enabled or
// not.
//
// The function returns the following values:
//
//   - ok: TRUE if ITP is enabled, or FALSE otherwise.
//
func (session *NetworkSession) ItpEnabled() bool {
	var _arg0 *C.WebKitNetworkSession // out
	var _cret C.gboolean              // in

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.webkit_network_session_get_itp_enabled(_arg0)
	runtime.KeepAlive(session)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ItpSummaryFinish: finish an asynchronous operation started with
// webkit_network_session_get_itp_summary().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - list of KitITPThirdParty. You must free the #GList with g_list_free() and
//     unref the KitITPThirdParty<!-- -->s with webkit_itp_third_party_unref()
//     when you're done with them.
//
func (session *NetworkSession) ItpSummaryFinish(result gio.AsyncResulter) ([]*ITPThirdParty, error) {
	var _arg0 *C.WebKitNetworkSession // out
	var _arg1 *C.GAsyncResult         // out
	var _cret *C.GList                // in
	var _cerr *C.GError               // in

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.webkit_network_session_get_itp_summary_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _list []*ITPThirdParty // out
	var _goerr error           // out

	_list = make([]*ITPThirdParty, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.WebKitITPThirdParty)(v)
		var dst *ITPThirdParty // out
		dst = (*ITPThirdParty)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.webkit_itp_third_party_unref((*C.WebKitITPThirdParty)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// PersistentCredentialStorageEnabled: get whether persistent credential storage
// is enabled or not.
//
// See also webkit_network_session_set_persistent_credential_storage_enabled().
//
// The function returns the following values:
//
//   - ok: TRUE if persistent credential storage is enabled, or FALSE otherwise.
//
func (session *NetworkSession) PersistentCredentialStorageEnabled() bool {
	var _arg0 *C.WebKitNetworkSession // out
	var _cret C.gboolean              // in

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.webkit_network_session_get_persistent_credential_storage_enabled(_arg0)
	runtime.KeepAlive(session)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TLSErrorsPolicy: get the TLS errors policy of session.
//
// The function returns the following values:
//
//   - tlsErrorsPolicy: KitTLSErrorsPolicy.
//
func (session *NetworkSession) TLSErrorsPolicy() TLSErrorsPolicy {
	var _arg0 *C.WebKitNetworkSession // out
	var _cret C.WebKitTLSErrorsPolicy // in

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.webkit_network_session_get_tls_errors_policy(_arg0)
	runtime.KeepAlive(session)

	var _tlsErrorsPolicy TLSErrorsPolicy // out

	_tlsErrorsPolicy = TLSErrorsPolicy(_cret)

	return _tlsErrorsPolicy
}

// WebsiteDataManager: get the KitWebsiteDataManager of session.
//
// The function returns the following values:
//
//   - websiteDataManager: KitWebsiteDataManager.
//
func (session *NetworkSession) WebsiteDataManager() *WebsiteDataManager {
	var _arg0 *C.WebKitNetworkSession     // out
	var _cret *C.WebKitWebsiteDataManager // in

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.webkit_network_session_get_website_data_manager(_arg0)
	runtime.KeepAlive(session)

	var _websiteDataManager *WebsiteDataManager // out

	_websiteDataManager = wrapWebsiteDataManager(coreglib.Take(unsafe.Pointer(_cret)))

	return _websiteDataManager
}

// IsEphemeral: get whether session is ephemeral. A KitNetworkSession
// is ephemeral when its KitWebsiteDataManager is ephemeral. See
// KitWebsiteDataManager:is-ephemeral for more details.
//
// The function returns the following values:
//
//   - ok: TRUE if session is pehmeral, or FALSE otherwise.
//
func (session *NetworkSession) IsEphemeral() bool {
	var _arg0 *C.WebKitNetworkSession // out
	var _cret C.gboolean              // in

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.webkit_network_session_is_ephemeral(_arg0)
	runtime.KeepAlive(session)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PrefetchDns: resolve the domain name of the given hostname in advance,
// so that if a URI of hostname is requested the load will be performed more
// quickly.
//
// The function takes the following parameters:
//
//   - hostname to be resolved.
//
func (session *NetworkSession) PrefetchDns(hostname string) {
	var _arg0 *C.WebKitNetworkSession // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_network_session_prefetch_dns(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(hostname)
}

// SetItpEnabled: enable or disable Intelligent Tracking Prevention (ITP).
//
// When ITP is enabled resource load statistics are collected and
// used to decide whether to allow or block third-party cookies and
// prevent user tracking. Note that while ITP is enabled the accept
// policy WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY is ignored
// and WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS is used instead. See also
// webkit_cookie_session_set_accept_policy().
//
// The function takes the following parameters:
//
//   - enabled: value to set.
//
func (session *NetworkSession) SetItpEnabled(enabled bool) {
	var _arg0 *C.WebKitNetworkSession // out
	var _arg1 C.gboolean              // out

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_network_session_set_itp_enabled(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(enabled)
}

// SetPersistentCredentialStorageEnabled: enable or disable persistent
// credential storage.
//
// When enabled, which is the default for non-ephemeral sessions, the network
// process will try to read and write HTTP authentiacation credentials from
// persistent storage.
//
// The function takes the following parameters:
//
//   - enabled: value to set.
//
func (session *NetworkSession) SetPersistentCredentialStorageEnabled(enabled bool) {
	var _arg0 *C.WebKitNetworkSession // out
	var _arg1 C.gboolean              // out

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_network_session_set_persistent_credential_storage_enabled(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(enabled)
}

// SetProxySettings: set the network proxy settings to be used by connections
// started in session session.
//
// By default WEBKIT_NETWORK_PROXY_MODE_DEFAULT is used, which means that
// the system settings will be used (g_proxy_resolver_get_default()).
// If you want to override the system default settings, you can either use
// WEBKIT_NETWORK_PROXY_MODE_NO_PROXY to make sure no proxies are used at all,
// or WEBKIT_NETWORK_PROXY_MODE_CUSTOM to provide your own proxy settings.
// When proxy_mode is WEBKIT_NETWORK_PROXY_MODE_CUSTOM proxy_settings must be a
// valid KitNetworkProxySettings; otherwise, proxy_settings must be NULL.
//
// The function takes the following parameters:
//
//   - proxyMode: KitNetworkProxyMode.
//   - proxySettings (optional) or NULL.
//
func (session *NetworkSession) SetProxySettings(proxyMode NetworkProxyMode, proxySettings *NetworkProxySettings) {
	var _arg0 *C.WebKitNetworkSession       // out
	var _arg1 C.WebKitNetworkProxyMode      // out
	var _arg2 *C.WebKitNetworkProxySettings // out

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.WebKitNetworkProxyMode(proxyMode)
	if proxySettings != nil {
		_arg2 = (*C.WebKitNetworkProxySettings)(gextras.StructNative(unsafe.Pointer(proxySettings)))
	}

	C.webkit_network_session_set_proxy_settings(_arg0, _arg1, _arg2)
	runtime.KeepAlive(session)
	runtime.KeepAlive(proxyMode)
	runtime.KeepAlive(proxySettings)
}

// SetTLSErrorsPolicy: set the TLS errors policy of session as policy.
//
// The function takes the following parameters:
//
//   - policy: KitTLSErrorsPolicy.
//
func (session *NetworkSession) SetTLSErrorsPolicy(policy TLSErrorsPolicy) {
	var _arg0 *C.WebKitNetworkSession // out
	var _arg1 C.WebKitTLSErrorsPolicy // out

	_arg0 = (*C.WebKitNetworkSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.WebKitTLSErrorsPolicy(policy)

	C.webkit_network_session_set_tls_errors_policy(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(policy)
}

// NetworkSessionGetDefault: get the default network session. The default
// network session is created using webkit_network_session_new() and passing
// NULL as data and cache directories.
//
// The function returns the following values:
//
//   - networkSession: KitNetworkSession.
//
func NetworkSessionGetDefault() *NetworkSession {
	var _cret *C.WebKitNetworkSession // in

	_cret = C.webkit_network_session_get_default()

	var _networkSession *NetworkSession // out

	_networkSession = wrapNetworkSession(coreglib.Take(unsafe.Pointer(_cret)))

	return _networkSession
}

// NetworkSessionSetMemoryPressureSettings sets settings as the
// KitMemoryPressureSettings.
//
// Sets settings as the KitMemoryPressureSettings to be used by the network
// process created by any instance of KitNetworkSession after this function is
// called.
//
// Be sure to call this function before creating any KitNetworkSession.
//
// The periodic check for used memory is disabled by default on network
// processes. This will be enabled only if custom settings have been set using
// this function. After that, in order to remove the custom settings and disable
// the periodic check, this function must be called passing NULL as the value of
// settings.
//
// The function takes the following parameters:
//
//   - settings: webKitMemoryPressureSettings.
//
func NetworkSessionSetMemoryPressureSettings(settings *MemoryPressureSettings) {
	var _arg1 *C.WebKitMemoryPressureSettings // out

	_arg1 = (*C.WebKitMemoryPressureSettings)(gextras.StructNative(unsafe.Pointer(settings)))

	C.webkit_network_session_set_memory_pressure_settings(_arg1)
	runtime.KeepAlive(settings)
}
