// Code generated by girgen. DO NOT EDIT.

package webkit

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit/webkit.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_webkit6_WebContext_ConnectInitializeWebProcessExtensions(gpointer, guintptr);
// extern void _gotk4_webkit6_WebContext_ConnectInitializeNotificationPermissions(gpointer, guintptr);
// extern void _gotk4_webkit6_WebContext_ConnectAutomationStarted(gpointer, WebKitAutomationSession*, guintptr);
// extern void _gotk4_webkit6_URISchemeRequestCallback(WebKitURISchemeRequest*, gpointer);
// extern gboolean _gotk4_webkit6_WebContext_ConnectUserMessageReceived(gpointer, WebKitUserMessage*, guintptr);
import "C"

// GType values.
var (
	GTypeCacheModel = coreglib.Type(C.webkit_cache_model_get_type())
	GTypeWebContext = coreglib.Type(C.webkit_web_context_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCacheModel, F: marshalCacheModel},
		coreglib.TypeMarshaler{T: GTypeWebContext, F: marshalWebContext},
	})
}

// CacheModel: enum values used for determining the KitWebContext cache model.
type CacheModel C.gint

const (
	// CacheModelDocumentViewer: disable the cache completely, which
	// substantially reduces memory usage. Useful for applications that only
	// access a single local file, with no navigation to other pages. No remote
	// resources will be cached.
	CacheModelDocumentViewer CacheModel = iota
	// CacheModelWebBrowser: improve document load speed substantially by
	// caching a very large number of resources and previously viewed content.
	CacheModelWebBrowser
	// CacheModelDocumentBrowser: cache model optimized for viewing a series of
	// local files -- for example, a documentation viewer or a website designer.
	// WebKit will cache a moderate number of resources.
	CacheModelDocumentBrowser
)

func marshalCacheModel(p uintptr) (interface{}, error) {
	return CacheModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CacheModel.
func (c CacheModel) String() string {
	switch c {
	case CacheModelDocumentViewer:
		return "DocumentViewer"
	case CacheModelWebBrowser:
		return "WebBrowser"
	case CacheModelDocumentBrowser:
		return "DocumentBrowser"
	default:
		return fmt.Sprintf("CacheModel(%d)", c)
	}
}

// URISchemeRequestCallback: type definition for a function that will be called
// back when an URI request is made for a user registered URI scheme.
type URISchemeRequestCallback func(request *URISchemeRequest)

// WebContextOverrides contains methods that are overridable.
type WebContextOverrides struct {
}

func defaultWebContextOverrides(v *WebContext) WebContextOverrides {
	return WebContextOverrides{}
}

// WebContext manages aspects common to all KitWebView<!-- -->s
//
// The KitWebContext manages all aspects common to all KitWebView<!-- -->s.
//
// You can define the KitCacheModel with webkit_web_context_set_cache_model(),
// depending on the needs of your application. You can access the
// KitSecurityManager to specify the behaviour of your application regarding
// security using webkit_web_context_get_security_manager().
//
// It is also possible to change your preferred language or enable
// spell checking, using webkit_web_context_set_preferred_languages(),
// webkit_web_context_set_spell_checking_languages() and
// webkit_web_context_set_spell_checking_enabled().
//
// You can use webkit_web_context_register_uri_scheme() to register custom URI
// schemes, and manage several other settings.
//
// TLS certificate validation failure is now treated as a transport
// error by default. To handle TLS failures differently, you can
// connect to KitWebView::load-failed-with-tls-errors. Alternatively,
// you can use webkit_web_context_set_tls_errors_policy() to set the policy
// WEBKIT_TLS_ERRORS_POLICY_IGNORE; however, this is not appropriate for
// Internet applications.
type WebContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*WebContext)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*WebContext, *WebContextClass, WebContextOverrides](
		GTypeWebContext,
		initWebContextClass,
		wrapWebContext,
		defaultWebContextOverrides,
	)
}

func initWebContextClass(gclass unsafe.Pointer, overrides WebContextOverrides, classInitFunc func(*WebContextClass)) {
	if classInitFunc != nil {
		class := (*WebContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWebContext(obj *coreglib.Object) *WebContext {
	return &WebContext{
		Object: obj,
	}
}

func marshalWebContext(p uintptr) (interface{}, error) {
	return wrapWebContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAutomationStarted: this signal is emitted when a new automation
// request is made. Note that it will never be emitted if automation is not
// enabled in context, see webkit_web_context_set_automation_allowed() for more
// details.
func (context *WebContext) ConnectAutomationStarted(f func(session *AutomationSession)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "automation-started", false, unsafe.Pointer(C._gotk4_webkit6_WebContext_ConnectAutomationStarted), f)
}

// ConnectInitializeNotificationPermissions: this signal is emitted
// when a KitWebContext needs to set initial notification permissions
// for a web process. It is emitted when a new web process is about
// to be launched, and signals the most appropriate moment to
// use webkit_web_context_initialize_notification_permissions().
// If no notification permissions have changed since the last
// time this signal was emitted, then there is no need to call
// webkit_web_context_initialize_notification_permissions() again.
func (context *WebContext) ConnectInitializeNotificationPermissions(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "initialize-notification-permissions", false, unsafe.Pointer(C._gotk4_webkit6_WebContext_ConnectInitializeNotificationPermissions), f)
}

// ConnectInitializeWebProcessExtensions: this signal is emitted when a new web
// process is about to be launched. It signals the most appropriate moment to
// use webkit_web_context_set_web_process_extensions_initialization_user_data()
// and webkit_web_context_set_web_process_extensions_directory().
func (context *WebContext) ConnectInitializeWebProcessExtensions(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "initialize-web-process-extensions", false, unsafe.Pointer(C._gotk4_webkit6_WebContext_ConnectInitializeWebProcessExtensions), f)
}

// ConnectUserMessageReceived: this signal is emitted when a KitUserMessage is
// received from a web process extension. You can reply to the message using
// webkit_user_message_send_reply().
//
// You can handle the user message asynchronously by calling g_object_ref() on
// message and returning TRUE.
func (context *WebContext) ConnectUserMessageReceived(f func(message *UserMessage) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "user-message-received", false, unsafe.Pointer(C._gotk4_webkit6_WebContext_ConnectUserMessageReceived), f)
}

// NewWebContext: create a new KitWebContext.
//
// The function returns the following values:
//
//   - webContext: newly created KitWebContext.
//
func NewWebContext() *WebContext {
	var _cret *C.WebKitWebContext // in

	_cret = C.webkit_web_context_new()

	var _webContext *WebContext // out

	_webContext = wrapWebContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _webContext
}

// AddPathToSandbox adds a path to be mounted in the sandbox.
//
// path must exist before any web process has been created; otherwise, it will
// be silently ignored. It is a fatal error to add paths after a web process has
// been spawned.
//
// Paths under /sys, /proc, and /dev are invalid. Attempting to add all of / is
// not valid. Since 2.40, adding the user's entire home directory or /home is
// also not valid.
//
// See also webkit_web_context_set_sandbox_enabled().
//
// The function takes the following parameters:
//
//   - path: absolute path to mount in the sandbox.
//   - readOnly: if TRUE the path will be read-only.
//
func (context *WebContext) AddPathToSandbox(path string, readOnly bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.char             // out
	var _arg2 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	if readOnly {
		_arg2 = C.TRUE
	}

	C.webkit_web_context_add_path_to_sandbox(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(path)
	runtime.KeepAlive(readOnly)
}

// CacheModel returns the current cache model.
//
// For more information about this value check the documentation of the function
// webkit_web_context_set_cache_model().
//
// The function returns the following values:
//
//   - cacheModel: current KitCacheModel.
//
func (context *WebContext) CacheModel() CacheModel {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.WebKitCacheModel  // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.webkit_web_context_get_cache_model(_arg0)
	runtime.KeepAlive(context)

	var _cacheModel CacheModel // out

	_cacheModel = CacheModel(_cret)

	return _cacheModel
}

// GeolocationManager: get the KitGeolocationManager of context.
//
// The function returns the following values:
//
//   - geolocationManager of context.
//
func (context *WebContext) GeolocationManager() *GeolocationManager {
	var _arg0 *C.WebKitWebContext         // out
	var _cret *C.WebKitGeolocationManager // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.webkit_web_context_get_geolocation_manager(_arg0)
	runtime.KeepAlive(context)

	var _geolocationManager *GeolocationManager // out

	_geolocationManager = wrapGeolocationManager(coreglib.Take(unsafe.Pointer(_cret)))

	return _geolocationManager
}

// NetworkSessionForAutomation: get the KitNetworkSession used for automation
// sessions started in context.
//
// The function returns the following values:
//
//   - networkSession (optional) or NULL if automation is not enabled.
//
func (context *WebContext) NetworkSessionForAutomation() *NetworkSession {
	var _arg0 *C.WebKitWebContext     // out
	var _cret *C.WebKitNetworkSession // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.webkit_web_context_get_network_session_for_automation(_arg0)
	runtime.KeepAlive(context)

	var _networkSession *NetworkSession // out

	if _cret != nil {
		_networkSession = wrapNetworkSession(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _networkSession
}

// SecurityManager: get the KitSecurityManager of context.
//
// The function returns the following values:
//
//   - securityManager of context.
//
func (context *WebContext) SecurityManager() *SecurityManager {
	var _arg0 *C.WebKitWebContext      // out
	var _cret *C.WebKitSecurityManager // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.webkit_web_context_get_security_manager(_arg0)
	runtime.KeepAlive(context)

	var _securityManager *SecurityManager // out

	_securityManager = wrapSecurityManager(coreglib.Take(unsafe.Pointer(_cret)))

	return _securityManager
}

// SpellCheckingEnabled: get whether spell checking feature is currently
// enabled.
//
// The function returns the following values:
//
//   - ok: TRUE If spell checking is enabled, or FALSE otherwise.
//
func (context *WebContext) SpellCheckingEnabled() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.webkit_web_context_get_spell_checking_enabled(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SpellCheckingLanguages: get the the list of spell checking languages.
//
// Get the the list of spell checking languages associated with context, or NULL
// if no languages have been previously set.
//
// See webkit_web_context_set_spell_checking_languages() for more details on the
// format of the languages in the list.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of languages if available, or NULL
//     otherwise.
//
func (context *WebContext) SpellCheckingLanguages() []string {
	var _arg0 *C.WebKitWebContext // out
	var _cret **C.gchar           // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.webkit_web_context_get_spell_checking_languages(_arg0)
	runtime.KeepAlive(context)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// TimeZoneOverride: get the KitWebContext:time-zone-override property.
//
// The function returns the following values:
//
func (context *WebContext) TimeZoneOverride() string {
	var _arg0 *C.WebKitWebContext // out
	var _cret *C.gchar            // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.webkit_web_context_get_time_zone_override(_arg0)
	runtime.KeepAlive(context)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// InitializeNotificationPermissions sets initial desktop notification
// permissions for the context.
//
// allowed_origins and disallowed_origins must each be #GList of
// KitSecurityOrigin objects representing origins that will, respectively,
// either always or never have permission to show desktop notifications.
// No KitNotificationPermissionRequest will ever be generated for any of the
// security origins represented in allowed_origins or disallowed_origins. This
// function is necessary because some webpages proactively check whether they
// have permission to display notifications without ever creating a permission
// request.
//
// This function only affects web processes that have not already
// been created. The best time to call it is when handling
// KitWebContext::initialize-notification-permissions so as to ensure that new
// web processes receive the most recent set of permissions.
//
// The function takes the following parameters:
//
//   - allowedOrigins of security origins.
//   - disallowedOrigins of security origins.
//
func (context *WebContext) InitializeNotificationPermissions(allowedOrigins, disallowedOrigins []*SecurityOrigin) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.GList            // out
	var _arg2 *C.GList            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	for i := len(allowedOrigins) - 1; i >= 0; i-- {
		src := allowedOrigins[i]
		var dst *C.WebKitSecurityOrigin // out
		dst = (*C.WebKitSecurityOrigin)(gextras.StructNative(unsafe.Pointer(src)))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)
	for i := len(disallowedOrigins) - 1; i >= 0; i-- {
		src := disallowedOrigins[i]
		var dst *C.WebKitSecurityOrigin // out
		dst = (*C.WebKitSecurityOrigin)(gextras.StructNative(unsafe.Pointer(src)))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	C.webkit_web_context_initialize_notification_permissions(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(allowedOrigins)
	runtime.KeepAlive(disallowedOrigins)
}

// IsAutomationAllowed: get whether automation is allowed in context.
//
// See also webkit_web_context_set_automation_allowed().
//
// The function returns the following values:
//
//   - ok: TRUE if automation is allowed or FALSE otherwise.
//
func (context *WebContext) IsAutomationAllowed() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.webkit_web_context_is_automation_allowed(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RegisterURIScheme: register scheme in context.
//
// Register scheme in context, so that when an URI request with scheme is
// made in the KitWebContext, the KitURISchemeRequestCallback registered will
// be called with a KitURISchemeRequest. It is possible to handle URI scheme
// requests asynchronously, by calling g_object_ref() on the KitURISchemeRequest
// and calling webkit_uri_scheme_request_finish() later when the data of the
// request is available or webkit_uri_scheme_request_finish_error() in case of
// error.
//
//    static void
//    about_uri_scheme_request_cb (WebKitURISchemeRequest *request,
//                                 gpointer                user_data)
//    {
//        GInputStream *stream;
//        gsize         stream_length;
//        const gchar  *path = webkit_uri_scheme_request_get_path (request);
//
//        if (!g_strcmp0 (path, "memory")) {
//            // Create a GInputStream with the contents of memory about page, and set its length to stream_length
//        } else if (!g_strcmp0 (path, "applications")) {
//            // Create a GInputStream with the contents of applications about page, and set its length to stream_length
//        } else if (!g_strcmp0 (path, "example")) {
//            gchar *contents = g_strdup_printf ("<html><body><p>Example about page</p></body></html>");
//            stream_length = strlen (contents);
//            stream = g_memory_input_stream_new_from_data (contents, stream_length, g_free);
//        } else {
//            GError *error = g_error_new (ABOUT_HANDLER_ERROR, ABOUT_HANDLER_ERROR_INVALID, "Invalid about:s page.", path);
//            webkit_uri_scheme_request_finish_error (request, error);
//            g_error_free (error);
//            return;
//        }
//        webkit_uri_scheme_request_finish (request, stream, stream_length, "text/html");
//        g_object_unref (stream);
//    }.
//
// The function takes the following parameters:
//
//   - scheme: network scheme to register.
//   - callback: KitURISchemeRequestCallback.
//
func (context *WebContext) RegisterURIScheme(scheme string, callback URISchemeRequestCallback) {
	var _arg0 *C.WebKitWebContext              // out
	var _arg1 *C.gchar                         // out
	var _arg2 C.WebKitURISchemeRequestCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*[0]byte)(C._gotk4_webkit6_URISchemeRequestCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.webkit_web_context_register_uri_scheme(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(callback)
}

// SendMessageToAllExtensions: send message to all web process extensions
// associated to context.
//
// If message is floating, it's consumed.
//
// The function takes the following parameters:
//
//   - message: KitUserMessage.
//
func (context *WebContext) SendMessageToAllExtensions(message *UserMessage) {
	var _arg0 *C.WebKitWebContext  // out
	var _arg1 *C.WebKitUserMessage // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.WebKitUserMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	C.webkit_web_context_send_message_to_all_extensions(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(message)
}

// SetAutomationAllowed: set whether automation is allowed in context.
//
// When automation is enabled the browser could be controlled by another
// process by requesting an automation session. When a new automation session is
// requested the signal KitWebContext::automation-started is emitted. Automation
// is disabled by default, so you need to explicitly call this method passing
// TRUE to enable it.
//
// Note that only one KitWebContext can have automation enabled, so this will do
// nothing if there's another KitWebContext with automation already enabled.
//
// The function takes the following parameters:
//
//   - allowed: value to set.
//
func (context *WebContext) SetAutomationAllowed(allowed bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if allowed {
		_arg1 = C.TRUE
	}

	C.webkit_web_context_set_automation_allowed(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(allowed)
}

// SetCacheModel specifies a usage model for WebViews.
//
// Specifies a usage model for WebViews, which WebKit will use to determine
// its caching behavior. All web views follow the cache model. This cache
// model determines the RAM and disk space to use for caching previously viewed
// content .
//
// Research indicates that users tend to browse within clusters of documents
// that hold resources in common, and to revisit previously visited documents.
// WebKit and the frameworks below it include built-in caches that take
// advantage of these patterns, substantially improving document load speed in
// browsing situations. The WebKit cache model controls the behaviors of all of
// these caches, including various WebCore caches.
//
// Browsers can improve document load speed substantially by
// specifying WEBKIT_CACHE_MODEL_WEB_BROWSER. Applications without
// a browsing interface can reduce memory usage substantially by
// specifying WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER. The default value is
// WEBKIT_CACHE_MODEL_WEB_BROWSER.
//
// The function takes the following parameters:
//
//   - cacheModel: KitCacheModel.
//
func (context *WebContext) SetCacheModel(cacheModel CacheModel) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.WebKitCacheModel  // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.WebKitCacheModel(cacheModel)

	C.webkit_web_context_set_cache_model(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cacheModel)
}

// SetPreferredLanguages: set the list of preferred languages.
//
// Set the list of preferred languages, sorted from most desirable to least
// desirable. The list will be used in the following ways:
//
// - Determining how to build the Accept-Language HTTP header that will be
// included in the network requests started by the KitWebContext.
//
// - Setting the values of navigator.language and navigator.languages.
//
// - The first item in the list sets the default locale for JavaScript Intl
// functions.
//
// The function takes the following parameters:
//
//   - languages (optional): NULL-terminated list of language identifiers.
//
func (context *WebContext) SetPreferredLanguages(languages []string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 **C.gchar           // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(languages) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(languages)+1)
			var zero *C.gchar
			out[len(languages)] = zero
			for i := range languages {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(languages[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.webkit_web_context_set_preferred_languages(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(languages)
}

// SetSpellCheckingEnabled: enable or disable the spell checking feature.
//
// The function takes the following parameters:
//
//   - enabled: value to be set.
//
func (context *WebContext) SetSpellCheckingEnabled(enabled bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_web_context_set_spell_checking_enabled(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(enabled)
}

// SetSpellCheckingLanguages: set the list of spell checking languages to be
// used for spell checking.
//
// The locale string typically is in the form lang_COUNTRY, where lang is an
// ISO-639 language code, and COUNTRY is an ISO-3166 country code. For instance,
// sv_FI for Swedish as written in Finland or pt_BR for Portuguese as written in
// Brazil.
//
// You need to call this function with a valid list of languages at least once
// in order to properly enable the spell checking feature in WebKit.
//
// The function takes the following parameters:
//
//   - languages: NULL-terminated list of spell checking languages.
//
func (context *WebContext) SetSpellCheckingLanguages(languages []string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 **C.gchar           // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(languages) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(languages)+1)
			var zero *C.gchar
			out[len(languages)] = zero
			for i := range languages {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(languages[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.webkit_web_context_set_spell_checking_languages(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(languages)
}

// SetWebProcessExtensionsDirectory: set the directory where WebKit will look
// for web process extensions.
//
// This method must be called before loading anything in this context,
// otherwise it will not have any effect. You can connect to
// KitWebContext::initialize-web-process-extensions to call this method before
// anything is loaded.
//
// The function takes the following parameters:
//
//   - directory to add.
//
func (context *WebContext) SetWebProcessExtensionsDirectory(directory string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(directory)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_web_context_set_web_process_extensions_directory(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(directory)
}

// SetWebProcessExtensionsInitializationUserData: set user data to be passed to
// Web Extensions on initialization.
//
// The data will be passed to the
// KitWebProcessExtensionInitializeWithUserDataFunction. This
// method must be called before loading anything in this context,
// otherwise it will not have any effect. You can connect to
// KitWebContext::initialize-web-process-extensions to call this method before
// anything is loaded.
//
// The function takes the following parameters:
//
//   - userData: #GVariant.
//
func (context *WebContext) SetWebProcessExtensionsInitializationUserData(userData *glib.Variant) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.GVariant         // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(userData)))

	C.webkit_web_context_set_web_process_extensions_initialization_user_data(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(userData)
}

// WebContextGetDefault gets the default web context.
//
// The function returns the following values:
//
//   - webContext: KitWebContext.
//
func WebContextGetDefault() *WebContext {
	var _cret *C.WebKitWebContext // in

	_cret = C.webkit_web_context_get_default()

	var _webContext *WebContext // out

	_webContext = wrapWebContext(coreglib.Take(unsafe.Pointer(_cret)))

	return _webContext
}

// WebContextClass: instance of this type is always passed by reference.
type WebContextClass struct {
	*webContextClass
}

// webContextClass is the struct that's finalized.
type webContextClass struct {
	native *C.WebKitWebContextClass
}
