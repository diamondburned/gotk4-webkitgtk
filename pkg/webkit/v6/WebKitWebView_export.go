// Code generated by girgen. DO NOT EDIT.

package webkit

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <webkit/webkit.h>
import "C"

//export _gotk4_webkit6_WebView_ConnectAuthenticate
func _gotk4_webkit6_WebView_ConnectAuthenticate(arg0 C.gpointer, arg1 *C.WebKitAuthenticationRequest, arg2 C.guintptr) (cret C.gboolean) {
	var f func(request *AuthenticationRequest) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(request *AuthenticationRequest) (ok bool))
	}

	var _request *AuthenticationRequest // out

	_request = wrapAuthenticationRequest(coreglib.Take(unsafe.Pointer(arg1)))

	ok := f(_request)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectClose
func _gotk4_webkit6_WebView_ConnectClose(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_webkit6_WebView_ConnectContextMenuDismissed
func _gotk4_webkit6_WebView_ConnectContextMenuDismissed(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_webkit6_WebView_ConnectCreate
func _gotk4_webkit6_WebView_ConnectCreate(arg0 C.gpointer, arg1 *C.WebKitNavigationAction, arg2 C.guintptr) (cret *C.GtkWidget) {
	var f func(navigationAction *NavigationAction) (widget gtk.Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(navigationAction *NavigationAction) (widget gtk.Widgetter))
	}

	var _navigationAction *NavigationAction // out

	_navigationAction = (*NavigationAction)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	widget := f(_navigationAction)

	var _ gtk.Widgetter

	cret = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_webkit6_WebView_ConnectDecidePolicy
func _gotk4_webkit6_WebView_ConnectDecidePolicy(arg0 C.gpointer, arg1 *C.WebKitPolicyDecision, arg2 C.WebKitPolicyDecisionType, arg3 C.guintptr) (cret C.gboolean) {
	var f func(decision PolicyDecisioner, decisionType PolicyDecisionType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(decision PolicyDecisioner, decisionType PolicyDecisionType) (ok bool))
	}

	var _decision PolicyDecisioner       // out
	var _decisionType PolicyDecisionType // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type webkit.PolicyDecisioner is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(PolicyDecisioner)
			return ok
		})
		rv, ok := casted.(PolicyDecisioner)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching webkit.PolicyDecisioner")
		}
		_decision = rv
	}
	_decisionType = PolicyDecisionType(arg2)

	ok := f(_decision, _decisionType)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectEnterFullscreen
func _gotk4_webkit6_WebView_ConnectEnterFullscreen(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectInsecureContentDetected
func _gotk4_webkit6_WebView_ConnectInsecureContentDetected(arg0 C.gpointer, arg1 C.WebKitInsecureContentEvent, arg2 C.guintptr) {
	var f func(event InsecureContentEvent)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event InsecureContentEvent))
	}

	var _event InsecureContentEvent // out

	_event = InsecureContentEvent(arg1)

	f(_event)
}

//export _gotk4_webkit6_WebView_ConnectLeaveFullscreen
func _gotk4_webkit6_WebView_ConnectLeaveFullscreen(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectLoadChanged
func _gotk4_webkit6_WebView_ConnectLoadChanged(arg0 C.gpointer, arg1 C.WebKitLoadEvent, arg2 C.guintptr) {
	var f func(loadEvent LoadEvent)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(loadEvent LoadEvent))
	}

	var _loadEvent LoadEvent // out

	_loadEvent = LoadEvent(arg1)

	f(_loadEvent)
}

//export _gotk4_webkit6_WebView_ConnectLoadFailed
func _gotk4_webkit6_WebView_ConnectLoadFailed(arg0 C.gpointer, arg1 C.WebKitLoadEvent, arg2 *C.gchar, arg3 *C.GError, arg4 C.guintptr) (cret C.gboolean) {
	var f func(loadEvent LoadEvent, failingUri string, err error) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(loadEvent LoadEvent, failingUri string, err error) (ok bool))
	}

	var _loadEvent LoadEvent // out
	var _failingUri string   // out
	var _err error           // out

	_loadEvent = LoadEvent(arg1)
	_failingUri = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_err = gerror.Take(unsafe.Pointer(arg3))

	ok := f(_loadEvent, _failingUri, _err)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectLoadFailedWithTLSErrors
func _gotk4_webkit6_WebView_ConnectLoadFailedWithTLSErrors(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.GTlsCertificate, arg3 C.GTlsCertificateFlags, arg4 C.guintptr) (cret C.gboolean) {
	var f func(failingUri string, certificate gio.TLSCertificater, errors gio.TLSCertificateFlags) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(failingUri string, certificate gio.TLSCertificater, errors gio.TLSCertificateFlags) (ok bool))
	}

	var _failingUri string               // out
	var _certificate gio.TLSCertificater // out
	var _errors gio.TLSCertificateFlags  // out

	_failingUri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.TLSCertificater)
			return ok
		})
		rv, ok := casted.(gio.TLSCertificater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
		}
		_certificate = rv
	}
	_errors = gio.TLSCertificateFlags(arg3)

	ok := f(_failingUri, _certificate, _errors)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectMouseTargetChanged
func _gotk4_webkit6_WebView_ConnectMouseTargetChanged(arg0 C.gpointer, arg1 *C.WebKitHitTestResult, arg2 C.guint, arg3 C.guintptr) {
	var f func(hitTestResult *HitTestResult, modifiers uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(hitTestResult *HitTestResult, modifiers uint))
	}

	var _hitTestResult *HitTestResult // out
	var _modifiers uint               // out

	_hitTestResult = wrapHitTestResult(coreglib.Take(unsafe.Pointer(arg1)))
	_modifiers = uint(arg2)

	f(_hitTestResult, _modifiers)
}

//export _gotk4_webkit6_WebView_ConnectPermissionRequest
func _gotk4_webkit6_WebView_ConnectPermissionRequest(arg0 C.gpointer, arg1 *C.WebKitPermissionRequest, arg2 C.guintptr) (cret C.gboolean) {
	var f func(request PermissionRequester) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(request PermissionRequester) (ok bool))
	}

	var _request PermissionRequester // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type webkit.PermissionRequester is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(PermissionRequester)
			return ok
		})
		rv, ok := casted.(PermissionRequester)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching webkit.PermissionRequester")
		}
		_request = rv
	}

	ok := f(_request)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectPrint
func _gotk4_webkit6_WebView_ConnectPrint(arg0 C.gpointer, arg1 *C.WebKitPrintOperation, arg2 C.guintptr) (cret C.gboolean) {
	var f func(printOperation *PrintOperation) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(printOperation *PrintOperation) (ok bool))
	}

	var _printOperation *PrintOperation // out

	_printOperation = wrapPrintOperation(coreglib.Take(unsafe.Pointer(arg1)))

	ok := f(_printOperation)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectQueryPermissionState
func _gotk4_webkit6_WebView_ConnectQueryPermissionState(arg0 C.gpointer, arg1 *C.WebKitPermissionStateQuery, arg2 C.guintptr) (cret C.gboolean) {
	var f func(query *PermissionStateQuery) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(query *PermissionStateQuery) (ok bool))
	}

	var _query *PermissionStateQuery // out

	_query = (*PermissionStateQuery)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.webkit_permission_state_query_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_permission_state_query_unref((*C.WebKitPermissionStateQuery)(intern.C))
		},
	)

	ok := f(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectReadyToShow
func _gotk4_webkit6_WebView_ConnectReadyToShow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_webkit6_WebView_ConnectResourceLoadStarted
func _gotk4_webkit6_WebView_ConnectResourceLoadStarted(arg0 C.gpointer, arg1 *C.WebKitWebResource, arg2 *C.WebKitURIRequest, arg3 C.guintptr) {
	var f func(resource *WebResource, request *URIRequest)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(resource *WebResource, request *URIRequest))
	}

	var _resource *WebResource // out
	var _request *URIRequest   // out

	_resource = wrapWebResource(coreglib.Take(unsafe.Pointer(arg1)))
	_request = wrapURIRequest(coreglib.Take(unsafe.Pointer(arg2)))

	f(_resource, _request)
}

//export _gotk4_webkit6_WebView_ConnectRunAsModal
func _gotk4_webkit6_WebView_ConnectRunAsModal(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_webkit6_WebView_ConnectRunColorChooser
func _gotk4_webkit6_WebView_ConnectRunColorChooser(arg0 C.gpointer, arg1 *C.WebKitColorChooserRequest, arg2 C.guintptr) (cret C.gboolean) {
	var f func(request *ColorChooserRequest) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(request *ColorChooserRequest) (ok bool))
	}

	var _request *ColorChooserRequest // out

	_request = wrapColorChooserRequest(coreglib.Take(unsafe.Pointer(arg1)))

	ok := f(_request)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectRunFileChooser
func _gotk4_webkit6_WebView_ConnectRunFileChooser(arg0 C.gpointer, arg1 *C.WebKitFileChooserRequest, arg2 C.guintptr) (cret C.gboolean) {
	var f func(request *FileChooserRequest) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(request *FileChooserRequest) (ok bool))
	}

	var _request *FileChooserRequest // out

	_request = wrapFileChooserRequest(coreglib.Take(unsafe.Pointer(arg1)))

	ok := f(_request)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectScriptDialog
func _gotk4_webkit6_WebView_ConnectScriptDialog(arg0 C.gpointer, arg1 *C.WebKitScriptDialog, arg2 C.guintptr) (cret C.gboolean) {
	var f func(dialog *ScriptDialog) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(dialog *ScriptDialog) (ok bool))
	}

	var _dialog *ScriptDialog // out

	_dialog = (*ScriptDialog)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.webkit_script_dialog_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dialog)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_script_dialog_unref((*C.WebKitScriptDialog)(intern.C))
		},
	)

	ok := f(_dialog)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectShowNotification
func _gotk4_webkit6_WebView_ConnectShowNotification(arg0 C.gpointer, arg1 *C.WebKitNotification, arg2 C.guintptr) (cret C.gboolean) {
	var f func(notification *Notification) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(notification *Notification) (ok bool))
	}

	var _notification *Notification // out

	_notification = wrapNotification(coreglib.Take(unsafe.Pointer(arg1)))

	ok := f(_notification)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectSubmitForm
func _gotk4_webkit6_WebView_ConnectSubmitForm(arg0 C.gpointer, arg1 *C.WebKitFormSubmissionRequest, arg2 C.guintptr) {
	var f func(request *FormSubmissionRequest)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(request *FormSubmissionRequest))
	}

	var _request *FormSubmissionRequest // out

	_request = wrapFormSubmissionRequest(coreglib.Take(unsafe.Pointer(arg1)))

	f(_request)
}

//export _gotk4_webkit6_WebView_ConnectUserMessageReceived
func _gotk4_webkit6_WebView_ConnectUserMessageReceived(arg0 C.gpointer, arg1 *C.WebKitUserMessage, arg2 C.guintptr) (cret C.gboolean) {
	var f func(message *UserMessage) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(message *UserMessage) (ok bool))
	}

	var _message *UserMessage // out

	_message = wrapUserMessage(coreglib.Take(unsafe.Pointer(arg1)))

	ok := f(_message)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_webkit6_WebView_ConnectWebProcessTerminated
func _gotk4_webkit6_WebView_ConnectWebProcessTerminated(arg0 C.gpointer, arg1 C.WebKitWebProcessTerminationReason, arg2 C.guintptr) {
	var f func(reason WebProcessTerminationReason)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(reason WebProcessTerminationReason))
	}

	var _reason WebProcessTerminationReason // out

	_reason = WebProcessTerminationReason(arg1)

	f(_reason)
}
