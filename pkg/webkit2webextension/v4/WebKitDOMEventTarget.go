// Code generated by girgen. DO NOT EDIT.

package webkit2webextension

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit2/webkit-web-extension.h>
// gboolean _gotk4_webkit2webextension4_DOMEventTarget_virtual_add_event_listener(void* fnptr, WebKitDOMEventTarget* arg0, char* arg1, GClosure* arg2, gboolean arg3) {
//   return ((gboolean (*)(WebKitDOMEventTarget*, char*, GClosure*, gboolean))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_webkit2webextension4_DOMEventTarget_virtual_dispatch_event(void* fnptr, WebKitDOMEventTarget* arg0, WebKitDOMEvent* arg1, GError** arg2) {
//   return ((gboolean (*)(WebKitDOMEventTarget*, WebKitDOMEvent*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_webkit2webextension4_DOMEventTarget_virtual_remove_event_listener(void* fnptr, WebKitDOMEventTarget* arg0, char* arg1, GClosure* arg2, gboolean arg3) {
//   return ((gboolean (*)(WebKitDOMEventTarget*, char*, GClosure*, gboolean))(fnptr))(arg0, arg1, arg2, arg3);
// };
import "C"

// GType values.
var (
	GTypeDOMEventTarget = coreglib.Type(C.webkit_dom_event_target_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDOMEventTarget, F: marshalDOMEventTarget},
	})
}

//
// DOMEventTarget wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DOMEventTarget struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DOMEventTarget)(nil)
)

// DOMEventTargetter describes DOMEventTarget's interface methods.
type DOMEventTargetter interface {
	coreglib.Objector

	// AddEventListener: version of webkit_dom_event_target_add_event_listener()
	// using a closure instead of a callbacks for easier binding in other
	// languages.
	AddEventListener(eventName string, handler coreglib.AnyClosure, useCapture bool) bool
	// DispatchEvent: deprecated: Use JavaScriptCore API instead.
	DispatchEvent(event *DOMEvent) error
	// RemoveEventListener: version of
	// webkit_dom_event_target_remove_event_listener() using a closure instead
	// of a callbacks for easier binding in other languages.
	RemoveEventListener(eventName string, handler coreglib.AnyClosure, useCapture bool) bool
}

var _ DOMEventTargetter = (*DOMEventTarget)(nil)

func wrapDOMEventTarget(obj *coreglib.Object) *DOMEventTarget {
	return &DOMEventTarget{
		Object: obj,
	}
}

func marshalDOMEventTarget(p uintptr) (interface{}, error) {
	return wrapDOMEventTarget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddEventListener: version of webkit_dom_event_target_add_event_listener()
// using a closure instead of a callbacks for easier binding in other languages.
//
// Deprecated: Use JavaScriptCore API instead.
//
// The function takes the following parameters:
//
//   - eventName: #gchar.
//   - handler: #GClosure.
//   - useCapture: #gboolean.
//
// The function returns the following values:
//
//   - ok: #gboolean.
//
func (target *DOMEventTarget) AddEventListener(eventName string, handler coreglib.AnyClosure, useCapture bool) bool {
	var _arg0 *C.WebKitDOMEventTarget // out
	var _arg1 *C.char                 // out
	var _arg2 *C.GClosure             // out
	var _arg3 C.gboolean              // out
	var _cret C.gboolean              // in

	_arg0 = (*C.WebKitDOMEventTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(eventName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GClosure)(coreglib.NewClosure(coreglib.InternObject(target), handler))
	if useCapture {
		_arg3 = C.TRUE
	}

	_cret = C.webkit_dom_event_target_add_event_listener_with_closure(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(target)
	runtime.KeepAlive(eventName)
	runtime.KeepAlive(handler)
	runtime.KeepAlive(useCapture)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DispatchEvent: deprecated: Use JavaScriptCore API instead.
//
// The function takes the following parameters:
//
//   - event: KitDOMEvent.
//
func (target *DOMEventTarget) DispatchEvent(event *DOMEvent) error {
	var _arg0 *C.WebKitDOMEventTarget // out
	var _arg1 *C.WebKitDOMEvent       // out
	var _cerr *C.GError               // in

	_arg0 = (*C.WebKitDOMEventTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg1 = (*C.WebKitDOMEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	C.webkit_dom_event_target_dispatch_event(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(target)
	runtime.KeepAlive(event)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveEventListener: version of
// webkit_dom_event_target_remove_event_listener() using a closure instead of a
// callbacks for easier binding in other languages.
//
// Deprecated: Use JavaScriptCore API instead.
//
// The function takes the following parameters:
//
//   - eventName: #gchar.
//   - handler: #GClosure.
//   - useCapture: #gboolean.
//
// The function returns the following values:
//
//   - ok: #gboolean.
//
func (target *DOMEventTarget) RemoveEventListener(eventName string, handler coreglib.AnyClosure, useCapture bool) bool {
	var _arg0 *C.WebKitDOMEventTarget // out
	var _arg1 *C.char                 // out
	var _arg2 *C.GClosure             // out
	var _arg3 C.gboolean              // out
	var _cret C.gboolean              // in

	_arg0 = (*C.WebKitDOMEventTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(eventName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GClosure)(coreglib.NewClosure(coreglib.InternObject(target), handler))
	if useCapture {
		_arg3 = C.TRUE
	}

	_cret = C.webkit_dom_event_target_remove_event_listener_with_closure(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(target)
	runtime.KeepAlive(eventName)
	runtime.KeepAlive(handler)
	runtime.KeepAlive(useCapture)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - eventName
//   - handler
//   - useCapture
//
// The function returns the following values:
//
func (target *DOMEventTarget) addEventListener(eventName string, handler coreglib.AnyClosure, useCapture bool) bool {
	gclass := (*C.WebKitDOMEventTargetIface)(coreglib.PeekParentClass(target))
	fnarg := gclass.add_event_listener

	var _arg0 *C.WebKitDOMEventTarget // out
	var _arg1 *C.char                 // out
	var _arg2 *C.GClosure             // out
	var _arg3 C.gboolean              // out
	var _cret C.gboolean              // in

	_arg0 = (*C.WebKitDOMEventTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(eventName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GClosure)(coreglib.NewClosure(coreglib.InternObject(target), handler))
	if useCapture {
		_arg3 = C.TRUE
	}

	_cret = C._gotk4_webkit2webextension4_DOMEventTarget_virtual_add_event_listener(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(target)
	runtime.KeepAlive(eventName)
	runtime.KeepAlive(handler)
	runtime.KeepAlive(useCapture)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// dispatchEvent: deprecated: Use JavaScriptCore API instead.
//
// The function takes the following parameters:
//
//   - event: KitDOMEvent.
//
func (target *DOMEventTarget) dispatchEvent(event *DOMEvent) error {
	gclass := (*C.WebKitDOMEventTargetIface)(coreglib.PeekParentClass(target))
	fnarg := gclass.dispatch_event

	var _arg0 *C.WebKitDOMEventTarget // out
	var _arg1 *C.WebKitDOMEvent       // out
	var _cerr *C.GError               // in

	_arg0 = (*C.WebKitDOMEventTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg1 = (*C.WebKitDOMEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	C._gotk4_webkit2webextension4_DOMEventTarget_virtual_dispatch_event(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(target)
	runtime.KeepAlive(event)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// removeEventListener: deprecated: Use JavaScriptCore API instead.
//
// The function takes the following parameters:
//
//   - eventName: #gchar.
//   - handler: #GCallback.
//   - useCapture: #gboolean.
//
// The function returns the following values:
//
//   - ok: #gboolean.
//
func (target *DOMEventTarget) removeEventListener(eventName string, handler coreglib.AnyClosure, useCapture bool) bool {
	gclass := (*C.WebKitDOMEventTargetIface)(coreglib.PeekParentClass(target))
	fnarg := gclass.remove_event_listener

	var _arg0 *C.WebKitDOMEventTarget // out
	var _arg1 *C.char                 // out
	var _arg2 *C.GClosure             // out
	var _arg3 C.gboolean              // out
	var _cret C.gboolean              // in

	_arg0 = (*C.WebKitDOMEventTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(eventName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GClosure)(coreglib.NewClosure(coreglib.InternObject(target), handler))
	if useCapture {
		_arg3 = C.TRUE
	}

	_cret = C._gotk4_webkit2webextension4_DOMEventTarget_virtual_remove_event_listener(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(target)
	runtime.KeepAlive(eventName)
	runtime.KeepAlive(handler)
	runtime.KeepAlive(useCapture)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DOMEventTargetIface: instance of this type is always passed by reference.
type DOMEventTargetIface struct {
	*domEventTargetIface
}

// domEventTargetIface is the struct that's finalized.
type domEventTargetIface struct {
	native *C.WebKitDOMEventTargetIface
}
