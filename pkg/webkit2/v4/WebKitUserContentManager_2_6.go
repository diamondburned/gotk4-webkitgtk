// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4-webkitgtk/pkg/javascriptcore/v4"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
// extern void _gotk4_webkit24_UserContentManager_ConnectScriptMessageReceived(gpointer, WebKitJavascriptResult*, guintptr);
// extern gboolean _gotk4_webkit24_UserContentManager_ConnectScriptMessageWithReplyReceived(gpointer, JSCValue*, WebKitScriptMessageReply*, guintptr);
import "C"

// GType values.
var (
	GTypeUserContentManager = coreglib.Type(C.webkit_user_content_manager_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeUserContentManager, F: marshalUserContentManager},
	})
}

// UserContentManagerOverrides contains methods that are overridable.
type UserContentManagerOverrides struct {
}

func defaultUserContentManagerOverrides(v *UserContentManager) UserContentManagerOverrides {
	return UserContentManagerOverrides{}
}

// UserContentManager manages user-defined content which affects web pages.
//
// Using a KitUserContentManager user CSS style sheets can be
// set to be injected in the web pages loaded by a KitWebView, by
// webkit_user_content_manager_add_style_sheet().
//
// To use a KitUserContentManager, it must be created using
// webkit_user_content_manager_new(), and then used to construct a KitWebView.
// User style sheets can be created with webkit_user_style_sheet_new().
//
// User style sheets can be added and removed at any time, but they will affect
// the web pages loaded afterwards.
type UserContentManager struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*UserContentManager)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*UserContentManager, *UserContentManagerClass, UserContentManagerOverrides](
		GTypeUserContentManager,
		initUserContentManagerClass,
		wrapUserContentManager,
		defaultUserContentManagerOverrides,
	)
}

func initUserContentManagerClass(gclass unsafe.Pointer, overrides UserContentManagerOverrides, classInitFunc func(*UserContentManagerClass)) {
	if classInitFunc != nil {
		class := (*UserContentManagerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapUserContentManager(obj *coreglib.Object) *UserContentManager {
	return &UserContentManager{
		Object: obj,
	}
}

func marshalUserContentManager(p uintptr) (interface{}, error) {
	return wrapUserContentManager(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectScriptMessageReceived: this signal is emitted when JavaScript in a web
// view calls <code>window.webkit.messageHandlers.<name>.postMessage()</code>,
// after registering <code><name></code> using
// webkit_user_content_manager_register_script_message_handler().
func (manager *UserContentManager) ConnectScriptMessageReceived(f func(value *JavascriptResult)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(manager, "script-message-received", false, unsafe.Pointer(C._gotk4_webkit24_UserContentManager_ConnectScriptMessageReceived), f)
}

// ConnectScriptMessageWithReplyReceived: this signal
// is emitted when JavaScript in a web view calls
// <code>window.webkit.messageHandlers.<name>.postMessage()</code>,
// after registering <code><name></code> using
// webkit_user_content_manager_register_script_message_handler_with_reply()
//
// The given reply can be used to send a return value with
// webkit_script_message_reply_return_value() or an error message with
// webkit_script_message_reply_return_error_message(). If none of them are
// called, an automatic reply with an undefined value will be sent.
//
// It is possible to handle the reply asynchronously, by simply calling
// g_object_ref() on the reply and returning TRUE.
func (manager *UserContentManager) ConnectScriptMessageWithReplyReceived(f func(value *javascriptcore.Value, reply *ScriptMessageReply) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(manager, "script-message-with-reply-received", false, unsafe.Pointer(C._gotk4_webkit24_UserContentManager_ConnectScriptMessageWithReplyReceived), f)
}

// NewUserContentManager creates a new user content manager.
//
// The function returns the following values:
//
//   - userContentManager: KitUserContentManager.
//
func NewUserContentManager() *UserContentManager {
	var _cret *C.WebKitUserContentManager // in

	_cret = C.webkit_user_content_manager_new()

	var _userContentManager *UserContentManager // out

	_userContentManager = wrapUserContentManager(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _userContentManager
}

// AddFilter adds a KitUserContentFilter to the given KitUserContentManager.
//
// The same KitUserContentFilter can be reused with multiple
// KitUserContentManager instances.
//
// Filters need to be saved and loaded from KitUserContentFilterStore.
//
// The function takes the following parameters:
//
//   - filter: KitUserContentFilter.
//
func (manager *UserContentManager) AddFilter(filter *UserContentFilter) {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.WebKitUserContentFilter  // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.WebKitUserContentFilter)(gextras.StructNative(unsafe.Pointer(filter)))

	C.webkit_user_content_manager_add_filter(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(filter)
}

// AddScript adds a KitUserScript to the given KitUserContentManager.
//
// The same KitUserScript can be reused with multiple KitUserContentManager
// instances.
//
// The function takes the following parameters:
//
//   - script: KitUserScript.
//
func (manager *UserContentManager) AddScript(script *UserScript) {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.WebKitUserScript         // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.WebKitUserScript)(gextras.StructNative(unsafe.Pointer(script)))

	C.webkit_user_content_manager_add_script(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(script)
}

// AddStyleSheet adds a KitUserStyleSheet to the given KitUserContentManager.
//
// The same KitUserStyleSheet can be reused with multiple KitUserContentManager
// instances.
//
// The function takes the following parameters:
//
//   - stylesheet: KitUserStyleSheet.
//
func (manager *UserContentManager) AddStyleSheet(stylesheet *UserStyleSheet) {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.WebKitUserStyleSheet     // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.WebKitUserStyleSheet)(gextras.StructNative(unsafe.Pointer(stylesheet)))

	C.webkit_user_content_manager_add_style_sheet(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(stylesheet)
}

// RegisterScriptMessageHandler registers a new user script message handler.
//
// After it is registered, scripts can use
// window.webkit.messageHandlers.<name>.postMessage(value) to send
// messages. Those messages are received by connecting handlers to the
// KitUserContentManager::script-message-received signal. The handler name
// is used as the detail of the signal. To avoid race conditions between
// registering the handler name, and starting to receive the signals, it is
// recommended to connect to the signal *before* registering the handler name:
//
//    WebKitWebView *view = webkit_web_view_new ();
//    WebKitUserContentManager *manager = webkit_web_view_get_user_content_manager ();
//    g_signal_connect (manager, "script-message-received::foobar",
//                      G_CALLBACK (handle_script_message), NULL);
//    webkit_user_content_manager_register_script_message_handler (manager, "foobar");
//
// Registering a script message handler will fail if the requested name has been
// already registered before.
//
// The function takes the following parameters:
//
//   - name: name of the script message channel.
//
// The function returns the following values:
//
//   - ok: TRUE if message handler was registered successfully, or FALSE
//     otherwise.
//
func (manager *UserContentManager) RegisterScriptMessageHandler(name string) bool {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.gchar                    // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.webkit_user_content_manager_register_script_message_handler(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RegisterScriptMessageHandlerInWorld registers a new user script message
// handler in script world.
//
// Registers a new user script message handler in script world with name
// world_name. See webkit_user_content_manager_register_script_message_handler()
// for full description.
//
// Registering a script message handler will fail if the requested name has been
// already registered before.
//
// The function takes the following parameters:
//
//   - name: name of the script message channel.
//   - worldName: name of a KitScriptWorld.
//
// The function returns the following values:
//
//   - ok: TRUE if message handler was registered successfully, or FALSE
//     otherwise.
//
func (manager *UserContentManager) RegisterScriptMessageHandlerInWorld(name, worldName string) bool {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.gchar                    // out
	var _arg2 *C.gchar                    // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(worldName)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.webkit_user_content_manager_register_script_message_handler_in_world(_arg0, _arg1, _arg2)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(name)
	runtime.KeepAlive(worldName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RegisterScriptMessageHandlerWithReply registers a new user script message
// handler in script world with name world_name.
//
// Different from webkit_user_content_manager_register_script_message_handler(),
// when using this function to register the handler, the connected signal is
// script-message-with-reply-received, and a reply provided by the user is
// expected. Otherwise, the user will receive a default undefined value.
//
// If NULL is passed as the world_name, the default world will be used.
// See webkit_user_content_manager_register_script_message_handler() for full
// description.
//
// Registering a script message handler will fail if the requested name has been
// already registered before.
//
// The registered handler can be unregistered by using
// webkit_user_content_manager_unregister_script_message_handler().
//
// The function takes the following parameters:
//
//   - name: name of the script message channel world_name (nullable): the name
//     of a KitScriptWorld.
//   - worldName
//
// The function returns the following values:
//
//   - ok: TRUE if message handler was registered successfully, or FALSE
//     otherwise.
//
func (manager *UserContentManager) RegisterScriptMessageHandlerWithReply(name, worldName string) bool {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.char                     // out
	var _arg2 *C.char                     // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(worldName)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.webkit_user_content_manager_register_script_message_handler_with_reply(_arg0, _arg1, _arg2)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(name)
	runtime.KeepAlive(worldName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAllFilters removes all content filters from the given
// KitUserContentManager.
func (manager *UserContentManager) RemoveAllFilters() {
	var _arg0 *C.WebKitUserContentManager // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	C.webkit_user_content_manager_remove_all_filters(_arg0)
	runtime.KeepAlive(manager)
}

// RemoveAllScripts removes all user scripts from the given
// KitUserContentManager
//
// See also webkit_user_content_manager_remove_script().
func (manager *UserContentManager) RemoveAllScripts() {
	var _arg0 *C.WebKitUserContentManager // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	C.webkit_user_content_manager_remove_all_scripts(_arg0)
	runtime.KeepAlive(manager)
}

// RemoveAllStyleSheets removes all user style sheets from the given
// KitUserContentManager.
func (manager *UserContentManager) RemoveAllStyleSheets() {
	var _arg0 *C.WebKitUserContentManager // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	C.webkit_user_content_manager_remove_all_style_sheets(_arg0)
	runtime.KeepAlive(manager)
}

// RemoveFilter removes a filter from the given KitUserContentManager.
//
// Since 2.24.
//
// The function takes the following parameters:
//
//   - filter: KitUserContentFilter.
//
func (manager *UserContentManager) RemoveFilter(filter *UserContentFilter) {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.WebKitUserContentFilter  // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.WebKitUserContentFilter)(gextras.StructNative(unsafe.Pointer(filter)))

	C.webkit_user_content_manager_remove_filter(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(filter)
}

// RemoveFilterByID removes a filter by the given identifier.
//
// Removes a filter from the given KitUserContentManager given
// the identifier of a KitUserContentFilter as returned by
// webkit_user_content_filter_get_identifier().
//
// The function takes the following parameters:
//
//   - filterId: filter identifier.
//
func (manager *UserContentManager) RemoveFilterByID(filterId string) {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.char                     // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filterId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_user_content_manager_remove_filter_by_id(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(filterId)
}

// RemoveScript removes a KitUserScript from the given KitUserContentManager.
//
// See also webkit_user_content_manager_remove_all_scripts().
//
// The function takes the following parameters:
//
//   - script: KitUserScript.
//
func (manager *UserContentManager) RemoveScript(script *UserScript) {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.WebKitUserScript         // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.WebKitUserScript)(gextras.StructNative(unsafe.Pointer(script)))

	C.webkit_user_content_manager_remove_script(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(script)
}

// RemoveStyleSheet removes a KitUserStyleSheet from the given
// KitUserContentManager.
//
// See also webkit_user_content_manager_remove_all_style_sheets().
//
// The function takes the following parameters:
//
//   - stylesheet: KitUserStyleSheet.
//
func (manager *UserContentManager) RemoveStyleSheet(stylesheet *UserStyleSheet) {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.WebKitUserStyleSheet     // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.WebKitUserStyleSheet)(gextras.StructNative(unsafe.Pointer(stylesheet)))

	C.webkit_user_content_manager_remove_style_sheet(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(stylesheet)
}

// UnregisterScriptMessageHandler unregisters a previously registered message
// handler.
//
// Note that this does *not* disconnect handlers for the
// KitUserContentManager::script-message-received signal; they will be kept
// connected, but the signal will not be emitted unless the handler name is
// registered again.
//
// See also webkit_user_content_manager_register_script_message_handler().
//
// The function takes the following parameters:
//
//   - name: name of the script message channel.
//
func (manager *UserContentManager) UnregisterScriptMessageHandler(name string) {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.gchar                    // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_user_content_manager_unregister_script_message_handler(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(name)
}

// UnregisterScriptMessageHandlerInWorld unregisters a previously registered
// message handler in script world with name world_name.
//
// Note that this does *not* disconnect handlers for the
// KitUserContentManager::script-message-received signal; they will be kept
// connected, but the signal will not be emitted unless the handler name is
// registered again.
//
// See also
// webkit_user_content_manager_register_script_message_handler_in_world().
//
// The function takes the following parameters:
//
//   - name: name of the script message channel.
//   - worldName: name of a KitScriptWorld.
//
func (manager *UserContentManager) UnregisterScriptMessageHandlerInWorld(name, worldName string) {
	var _arg0 *C.WebKitUserContentManager // out
	var _arg1 *C.gchar                    // out
	var _arg2 *C.gchar                    // out

	_arg0 = (*C.WebKitUserContentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(worldName)))
	defer C.free(unsafe.Pointer(_arg2))

	C.webkit_user_content_manager_unregister_script_message_handler_in_world(_arg0, _arg1, _arg2)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(name)
	runtime.KeepAlive(worldName)
}
