// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <webkit2/webkit2.h>
import "C"

//export _gotk4_webkit24_WebResource_ConnectFailed
func _gotk4_webkit24_WebResource_ConnectFailed(arg0 C.gpointer, arg1 *C.GError, arg2 C.guintptr) {
	var f func(err error)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(err error))
	}

	var _err error // out

	_err = gerror.Take(unsafe.Pointer(arg1))

	f(_err)
}

//export _gotk4_webkit24_WebResource_ConnectFailedWithTLSErrors
func _gotk4_webkit24_WebResource_ConnectFailedWithTLSErrors(arg0 C.gpointer, arg1 *C.GTlsCertificate, arg2 C.GTlsCertificateFlags, arg3 C.guintptr) {
	var f func(certificate gio.TLSCertificater, errors gio.TLSCertificateFlags)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(certificate gio.TLSCertificater, errors gio.TLSCertificateFlags))
	}

	var _certificate gio.TLSCertificater // out
	var _errors gio.TLSCertificateFlags  // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.TLSCertificater)
			return ok
		})
		rv, ok := casted.(gio.TLSCertificater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
		}
		_certificate = rv
	}
	_errors = gio.TLSCertificateFlags(arg2)

	f(_certificate, _errors)
}

//export _gotk4_webkit24_WebResource_ConnectFinished
func _gotk4_webkit24_WebResource_ConnectFinished(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_webkit24_WebResource_ConnectReceivedData
func _gotk4_webkit24_WebResource_ConnectReceivedData(arg0 C.gpointer, arg1 C.guint64, arg2 C.guintptr) {
	var f func(dataLength uint64)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(dataLength uint64))
	}

	var _dataLength uint64 // out

	_dataLength = uint64(arg1)

	f(_dataLength)
}

//export _gotk4_webkit24_WebResource_ConnectSentRequest
func _gotk4_webkit24_WebResource_ConnectSentRequest(arg0 C.gpointer, arg1 *C.WebKitURIRequest, arg2 *C.WebKitURIResponse, arg3 C.guintptr) {
	var f func(request *URIRequest, redirectedResponse *URIResponse)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(request *URIRequest, redirectedResponse *URIResponse))
	}

	var _request *URIRequest             // out
	var _redirectedResponse *URIResponse // out

	_request = wrapURIRequest(coreglib.Take(unsafe.Pointer(arg1)))
	_redirectedResponse = wrapURIResponse(coreglib.Take(unsafe.Pointer(arg2)))

	f(_request, _redirectedResponse)
}
