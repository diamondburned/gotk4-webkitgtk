// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
// extern void _gotk4_webkit24_Download_ConnectReceivedData(gpointer, guint64, guintptr);
// extern void _gotk4_webkit24_Download_ConnectFinished(gpointer, guintptr);
// extern void _gotk4_webkit24_Download_ConnectFailed(gpointer, GError*, guintptr);
// extern void _gotk4_webkit24_Download_ConnectCreatedDestination(gpointer, gchar*, guintptr);
// extern gboolean _gotk4_webkit24_Download_ConnectDecideDestination(gpointer, gchar*, guintptr);
// extern gboolean _gotk4_webkit24_DownloadClass_decide_destination(WebKitDownload*, gchar*);
// gboolean _gotk4_webkit24_Download_virtual_decide_destination(void* fnptr, WebKitDownload* arg0, gchar* arg1) {
//   return ((gboolean (*)(WebKitDownload*, gchar*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeDownload = coreglib.Type(C.webkit_download_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDownload, F: marshalDownload},
	})
}

// DownloadOverrides contains methods that are overridable.
type DownloadOverrides struct {
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DecideDestination func(suggestedFilename string) bool
}

func defaultDownloadOverrides(v *Download) DownloadOverrides {
	return DownloadOverrides{
		DecideDestination: v.decideDestination,
	}
}

// Download: object used to communicate with the application when downloading.
//
// KitDownload carries information about a download request and response,
// including a KitURIRequest and a KitURIResponse objects. The application may
// use this object to control the download process, or to simply figure out what
// is to be downloaded, and handle the download process itself.
type Download struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Download)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Download, *DownloadClass, DownloadOverrides](
		GTypeDownload,
		initDownloadClass,
		wrapDownload,
		defaultDownloadOverrides,
	)
}

func initDownloadClass(gclass unsafe.Pointer, overrides DownloadOverrides, classInitFunc func(*DownloadClass)) {
	pclass := (*C.WebKitDownloadClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDownload))))

	if overrides.DecideDestination != nil {
		pclass.decide_destination = (*[0]byte)(C._gotk4_webkit24_DownloadClass_decide_destination)
	}

	if classInitFunc != nil {
		class := (*DownloadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDownload(obj *coreglib.Object) *Download {
	return &Download{
		Object: obj,
	}
}

func marshalDownload(p uintptr) (interface{}, error) {
	return wrapDownload(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCreatedDestination: this signal is emitted after
// KitDownload::decide-destination and before KitDownload::received-data to
// notify that destination file has been created successfully at destination.
func (download *Download) ConnectCreatedDestination(f func(destination string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(download, "created-destination", false, unsafe.Pointer(C._gotk4_webkit24_Download_ConnectCreatedDestination), f)
}

// ConnectDecideDestination: this signal is emitted after response
// is received to decide a destination for the download using
// webkit_download_set_destination(). If this signal is not handled,
// the file will be downloaded to G_USER_DIRECTORY_DOWNLOAD directory using
// suggested_filename.
//
// Since 2.40, you may handle this signal asynchronously by returning TRUE
// without calling webkit_download_set_destination(). This indicates intent
// to eventually call webkit_download_set_destination(). In this case,
// the download will not proceed until the destination is set or cancelled with
// webkit_download_cancel().
func (download *Download) ConnectDecideDestination(f func(suggestedFilename string) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(download, "decide-destination", false, unsafe.Pointer(C._gotk4_webkit24_Download_ConnectDecideDestination), f)
}

// ConnectFailed: this signal is emitted when an error occurs during the
// download operation. The given error, of the domain WEBKIT_DOWNLOAD_ERROR,
// contains further details of the failure. If the download is cancelled
// with webkit_download_cancel(), this signal is emitted with error
// WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER. The download operation finishes
// after an error and KitDownload::finished signal is emitted after this one.
func (download *Download) ConnectFailed(f func(err error)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(download, "failed", false, unsafe.Pointer(C._gotk4_webkit24_Download_ConnectFailed), f)
}

// ConnectFinished: this signal is emitted when download finishes successfully
// or due to an error. In case of errors KitDownload::failed signal is emitted
// before this one.
func (download *Download) ConnectFinished(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(download, "finished", false, unsafe.Pointer(C._gotk4_webkit24_Download_ConnectFinished), f)
}

// ConnectReceivedData: this signal is emitted after response is received,
// every time new data has been written to the destination. It's useful to know
// the progress of the download operation.
func (download *Download) ConnectReceivedData(f func(dataLength uint64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(download, "received-data", false, unsafe.Pointer(C._gotk4_webkit24_Download_ConnectReceivedData), f)
}

// Cancel cancels the download.
//
// When the ongoing download operation is effectively cancelled the signal
// KitDownload::failed is emitted with WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER
// error.
func (download *Download) Cancel() {
	var _arg0 *C.WebKitDownload // out

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))

	C.webkit_download_cancel(_arg0)
	runtime.KeepAlive(download)
}

// AllowOverwrite returns the current value of the KitDownload:allow-overwrite
// property.
//
// Returns the current value of the KitDownload:allow-overwrite property, which
// determines whether the download will overwrite an existing file on disk,
// or if it will fail if the destination already exists.
//
// The function returns the following values:
//
//   - ok: current value of the KitDownload:allow-overwrite property.
//
func (download *Download) AllowOverwrite() bool {
	var _arg0 *C.WebKitDownload // out
	var _cret C.gboolean        // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))

	_cret = C.webkit_download_get_allow_overwrite(_arg0)
	runtime.KeepAlive(download)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Destination obtains the destination to which the downloaded file will be
// written.
//
// You can connect to KitDownload::created-destination to make sure this method
// returns a valid destination.
//
// The function returns the following values:
//
//   - utf8 (optional): destination or NULL.
//
func (download *Download) Destination() string {
	var _arg0 *C.WebKitDownload // out
	var _cret *C.gchar          // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))

	_cret = C.webkit_download_get_destination(_arg0)
	runtime.KeepAlive(download)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ElapsedTime gets the elapsed time in seconds, including any fractional part.
//
// If the download finished, had an error or was cancelled this is the time
// between its start and the event.
//
// The function returns the following values:
//
//   - gdouble seconds since the download was started.
//
func (download *Download) ElapsedTime() float64 {
	var _arg0 *C.WebKitDownload // out
	var _cret C.gdouble         // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))

	_cret = C.webkit_download_get_elapsed_time(_arg0)
	runtime.KeepAlive(download)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// EstimatedProgress gets the value of the KitDownload:estimated-progress
// property. Gets the value of the KitDownload:estimated-progress property. You
// can monitor the estimated progress of the download operation by connecting to
// the notify::estimated-progress signal of download.
//
// The function returns the following values:
//
//   - gdouble: estimate of the of the percent complete for a download as a
//     range from 0.0 to 1.0.
//
func (download *Download) EstimatedProgress() float64 {
	var _arg0 *C.WebKitDownload // out
	var _cret C.gdouble         // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))

	_cret = C.webkit_download_get_estimated_progress(_arg0)
	runtime.KeepAlive(download)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ReceivedDataLength gets the length of the data already downloaded for
// download.
//
// Gets the length of the data already downloaded for download in bytes.
//
// The function returns the following values:
//
//   - guint64: amount of bytes already downloaded.
//
func (download *Download) ReceivedDataLength() uint64 {
	var _arg0 *C.WebKitDownload // out
	var _cret C.guint64         // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))

	_cret = C.webkit_download_get_received_data_length(_arg0)
	runtime.KeepAlive(download)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Request retrieves the KitURIRequest object that backs the download process.
//
// The function returns the following values:
//
//   - uriRequest of download.
//
func (download *Download) Request() *URIRequest {
	var _arg0 *C.WebKitDownload   // out
	var _cret *C.WebKitURIRequest // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))

	_cret = C.webkit_download_get_request(_arg0)
	runtime.KeepAlive(download)

	var _uriRequest *URIRequest // out

	_uriRequest = wrapURIRequest(coreglib.Take(unsafe.Pointer(_cret)))

	return _uriRequest
}

// Response retrieves the KitURIResponse object that backs the download process.
//
// Retrieves the KitURIResponse object that backs the download process.
// This method returns NULL if called before the response is received from the
// server. You can connect to notify::response signal to be notified when the
// response is received.
//
// The function returns the following values:
//
//   - uriResponse or NULL if the response hasn't been received yet.
//
func (download *Download) Response() *URIResponse {
	var _arg0 *C.WebKitDownload    // out
	var _cret *C.WebKitURIResponse // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))

	_cret = C.webkit_download_get_response(_arg0)
	runtime.KeepAlive(download)

	var _uriResponse *URIResponse // out

	_uriResponse = wrapURIResponse(coreglib.Take(unsafe.Pointer(_cret)))

	return _uriResponse
}

// WebView: get the KitWebView that initiated the download.
//
// The function returns the following values:
//
//   - webView that initiated download, or NULL if download was not initiated by
//     a KitWebView.
//
func (download *Download) WebView() *WebView {
	var _arg0 *C.WebKitDownload // out
	var _cret *C.WebKitWebView  // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))

	_cret = C.webkit_download_get_web_view(_arg0)
	runtime.KeepAlive(download)

	var _webView *WebView // out

	_webView = wrapWebView(coreglib.Take(unsafe.Pointer(_cret)))

	return _webView
}

// SetAllowOverwrite sets the KitDownload:allow-overwrite property.
//
// Sets the KitDownload:allow-overwrite property, which determines whether the
// download may overwrite an existing file on disk, or if it will fail if the
// destination already exists.
//
// The function takes the following parameters:
//
//   - allowed: new value for the KitDownload:allow-overwrite property.
//
func (download *Download) SetAllowOverwrite(allowed bool) {
	var _arg0 *C.WebKitDownload // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))
	if allowed {
		_arg1 = C.TRUE
	}

	C.webkit_download_set_allow_overwrite(_arg0, _arg1)
	runtime.KeepAlive(download)
	runtime.KeepAlive(allowed)
}

// SetDestination sets the destination to which the downloaded file will be
// written.
//
// This method should be called before the download transfer starts
// or it will not have any effect on the ongoing download operation.
// To set the destination using the filename suggested by the
// server connect to KitDownload::decide-destination signal and call
// webkit_download_set_destination(). If you want to set a fixed destination
// that doesn't depend on the suggested filename you can connect to
// notify::response signal and call webkit_download_set_destination().
//
// If KitDownload::decide-destination signal is not handled and destination is
// not set when the download transfer starts, the file will be saved with the
// filename suggested by the server in G_USER_DIRECTORY_DOWNLOAD directory.
//
// The function takes the following parameters:
//
//   - destination: destination.
//
func (download *Download) SetDestination(destination string) {
	var _arg0 *C.WebKitDownload // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(destination)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_download_set_destination(_arg0, _arg1)
	runtime.KeepAlive(download)
	runtime.KeepAlive(destination)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (download *Download) decideDestination(suggestedFilename string) bool {
	gclass := (*C.WebKitDownloadClass)(coreglib.PeekParentClass(download))
	fnarg := gclass.decide_destination

	var _arg0 *C.WebKitDownload // out
	var _arg1 *C.gchar          // out
	var _cret C.gboolean        // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(coreglib.InternObject(download).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(suggestedFilename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_webkit24_Download_virtual_decide_destination(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(download)
	runtime.KeepAlive(suggestedFilename)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DownloadClass: instance of this type is always passed by reference.
type DownloadClass struct {
	*downloadClass
}

// downloadClass is the struct that's finalized.
type downloadClass struct {
	native *C.WebKitDownloadClass
}
