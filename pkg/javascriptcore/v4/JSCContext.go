// Code generated by girgen. DO NOT EDIT.

package javascriptcore

import (
	"fmt"
	"runtime"
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: javascriptcoregtk-4.0 webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <jsc/jsc.h>
// extern void callbackDelete(gpointer);
// void _gotk4_javascriptcore4_ExceptionHandler(JSCContext*, JSCException*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.jsc_context_get_type()), F: marshalContexter},
	})
}

// CheckSyntaxMode: enum values to specify a mode to check for syntax errors in
// jsc_context_check_syntax().
type CheckSyntaxMode C.gint

const (
	// CheckSyntaxModeScript: mode to check syntax of a script.
	CheckSyntaxModeScript CheckSyntaxMode = iota
	// CheckSyntaxModeModule: mode to check syntax of a module.
	CheckSyntaxModeModule
)

// String returns the name in string for CheckSyntaxMode.
func (c CheckSyntaxMode) String() string {
	switch c {
	case CheckSyntaxModeScript:
		return "Script"
	case CheckSyntaxModeModule:
		return "Module"
	default:
		return fmt.Sprintf("CheckSyntaxMode(%d)", c)
	}
}

// CheckSyntaxResult: enum values to specify the result of
// jsc_context_check_syntax().
type CheckSyntaxResult C.gint

const (
	// CheckSyntaxResultSuccess: no errors.
	CheckSyntaxResultSuccess CheckSyntaxResult = iota
	// CheckSyntaxResultRecoverableError: recoverable syntax error.
	CheckSyntaxResultRecoverableError
	// CheckSyntaxResultIrrecoverableError: irrecoverable syntax error.
	CheckSyntaxResultIrrecoverableError
	// CheckSyntaxResultUnterminatedLiteralError: unterminated literal error.
	CheckSyntaxResultUnterminatedLiteralError
	// CheckSyntaxResultOutOfMemoryError: out of memory error.
	CheckSyntaxResultOutOfMemoryError
	// CheckSyntaxResultStackOverflowError: stack overflow error.
	CheckSyntaxResultStackOverflowError
)

// String returns the name in string for CheckSyntaxResult.
func (c CheckSyntaxResult) String() string {
	switch c {
	case CheckSyntaxResultSuccess:
		return "Success"
	case CheckSyntaxResultRecoverableError:
		return "RecoverableError"
	case CheckSyntaxResultIrrecoverableError:
		return "IrrecoverableError"
	case CheckSyntaxResultUnterminatedLiteralError:
		return "UnterminatedLiteralError"
	case CheckSyntaxResultOutOfMemoryError:
		return "OutOfMemoryError"
	case CheckSyntaxResultStackOverflowError:
		return "StackOverflowError"
	default:
		return fmt.Sprintf("CheckSyntaxResult(%d)", c)
	}
}

// ExceptionHandler: function used to handle JavaScript exceptions in a
// CContext.
type ExceptionHandler func(context *Context, exception *Exception)

//export _gotk4_javascriptcore4_ExceptionHandler
func _gotk4_javascriptcore4_ExceptionHandler(arg0 *C.JSCContext, arg1 *C.JSCException, arg2 C.gpointer) {
	v := gbox.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var context *Context     // out
	var exception *Exception // out

	context = wrapContext(externglib.Take(unsafe.Pointer(arg0)))
	exception = wrapException(externglib.Take(unsafe.Pointer(arg1)))

	fn := v.(ExceptionHandler)
	fn(context, exception)
}

type Context struct {
	*externglib.Object
}

var (
	_ externglib.Objector = (*Context)(nil)
)

func wrapContext(obj *externglib.Object) *Context {
	return &Context{
		Object: obj,
	}
}

func marshalContexter(p uintptr) (interface{}, error) {
	return wrapContext(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewContext: create a new CContext. The context is created in a new
// CVirtualMachine. Use jsc_context_new_with_virtual_machine() to create a new
// CContext in an existing CVirtualMachine.
func NewContext() *Context {
	var _cret *C.JSCContext // in

	_cret = C.jsc_context_new()

	var _context *Context // out

	_context = wrapContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _context
}

// NewContextWithVirtualMachine: create a new CContext in virtual_machine.
//
// The function takes the following parameters:
//
//    - vm: CVirtualMachine.
//
func NewContextWithVirtualMachine(vm *VirtualMachine) *Context {
	var _arg1 *C.JSCVirtualMachine // out
	var _cret *C.JSCContext        // in

	_arg1 = (*C.JSCVirtualMachine)(unsafe.Pointer(vm.Native()))

	_cret = C.jsc_context_new_with_virtual_machine(_arg1)
	runtime.KeepAlive(vm)

	var _context *Context // out

	_context = wrapContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _context
}

// CheckSyntax: check the given code in context for syntax errors. The
// line_number is the starting line number in uri; the value is one-based so the
// first line is 1. uri and line_number are only used to fill the exception. In
// case of errors exception will be set to a new CException with the details.
// You can pass NULL to exception to ignore the error details.
//
// The function takes the following parameters:
//
//    - code: javaScript script to check.
//    - length of code, or -1 if code is a nul-terminated string.
//    - mode: CCheckSyntaxMode.
//    - uri: source URI.
//    - lineNumber: starting line number.
//
func (context *Context) CheckSyntax(code string, length int, mode CheckSyntaxMode, uri string, lineNumber uint) (*Exception, CheckSyntaxResult) {
	var _arg0 *C.JSCContext          // out
	var _arg1 *C.char                // out
	var _arg2 C.gssize               // out
	var _arg3 C.JSCCheckSyntaxMode   // out
	var _arg4 *C.char                // out
	var _arg5 C.unsigned             // out
	var _arg6 *C.JSCException        // in
	var _cret C.JSCCheckSyntaxResult // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)
	_arg3 = C.JSCCheckSyntaxMode(mode)
	_arg4 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = C.unsigned(lineNumber)

	_cret = C.jsc_context_check_syntax(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(code)
	runtime.KeepAlive(length)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(lineNumber)

	var _exception *Exception                // out
	var _checkSyntaxResult CheckSyntaxResult // out

	if _arg6 != nil {
		_exception = wrapException(externglib.AssumeOwnership(unsafe.Pointer(_arg6)))
	}
	_checkSyntaxResult = CheckSyntaxResult(_cret)

	return _exception, _checkSyntaxResult
}

// ClearException: clear the uncaught exception in context if any.
func (context *Context) ClearException() {
	var _arg0 *C.JSCContext // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))

	C.jsc_context_clear_exception(_arg0)
	runtime.KeepAlive(context)
}

// Evaluate code in context.
//
// The function takes the following parameters:
//
//    - code: javaScript script to evaluate.
//    - length of code, or -1 if code is a nul-terminated string.
//
func (context *Context) Evaluate(code string, length int) *Value {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _cret *C.JSCValue   // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)

	_cret = C.jsc_context_evaluate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(code)
	runtime.KeepAlive(length)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// EvaluateInObject: evaluate code and create an new object where symbols
// defined in code will be added as properties, instead of being added to
// context global object. The new object is returned as object parameter.
// Similar to how jsc_value_new_object() works, if object_instance is not NULL
// object_class must be provided too. The line_number is the starting line
// number in uri; the value is one-based so the first line is 1. uri and
// line_number will be shown in exceptions and they don't affect the behavior of
// the script.
//
// The function takes the following parameters:
//
//    - code: javaScript script to evaluate.
//    - length of code, or -1 if code is a nul-terminated string.
//    - objectInstance: object instance.
//    - objectClass or NULL to use the default.
//    - uri: source URI.
//    - lineNumber: starting line number.
//
func (context *Context) EvaluateInObject(code string, length int, objectInstance cgo.Handle, objectClass *Class, uri string, lineNumber uint) (object *Value, value *Value) {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _arg3 C.gpointer    // out
	var _arg4 *C.JSCClass   // out
	var _arg5 *C.char       // out
	var _arg6 C.guint       // out
	var _arg7 *C.JSCValue   // in
	var _cret *C.JSCValue   // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)
	_arg3 = (C.gpointer)(unsafe.Pointer(objectInstance))
	if objectClass != nil {
		_arg4 = (*C.JSCClass)(unsafe.Pointer(objectClass.Native()))
	}
	_arg5 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = C.guint(lineNumber)

	_cret = C.jsc_context_evaluate_in_object(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, &_arg7)
	runtime.KeepAlive(context)
	runtime.KeepAlive(code)
	runtime.KeepAlive(length)
	runtime.KeepAlive(objectInstance)
	runtime.KeepAlive(objectClass)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(lineNumber)

	var _object *Value // out
	var _value *Value  // out

	_object = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_arg7)))
	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _object, _value
}

// EvaluateWithSourceURI: evaluate code in context using uri as the source URI.
// The line_number is the starting line number in uri; the value is one-based so
// the first line is 1. uri and line_number will be shown in exceptions and they
// don't affect the behavior of the script.
//
// The function takes the following parameters:
//
//    - code: javaScript script to evaluate.
//    - length of code, or -1 if code is a nul-terminated string.
//    - uri: source URI.
//    - lineNumber: starting line number.
//
func (context *Context) EvaluateWithSourceURI(code string, length int, uri string, lineNumber uint) *Value {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _arg3 *C.char       // out
	var _arg4 C.guint       // out
	var _cret *C.JSCValue   // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.guint(lineNumber)

	_cret = C.jsc_context_evaluate_with_source_uri(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(code)
	runtime.KeepAlive(length)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(lineNumber)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// Exception: get the last unhandled exception thrown in context by API
// functions calls.
func (context *Context) Exception() *Exception {
	var _arg0 *C.JSCContext   // out
	var _cret *C.JSCException // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))

	_cret = C.jsc_context_get_exception(_arg0)
	runtime.KeepAlive(context)

	var _exception *Exception // out

	if _cret != nil {
		_exception = wrapException(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _exception
}

// GlobalObject: get a CValue referencing the context global object.
func (context *Context) GlobalObject() *Value {
	var _arg0 *C.JSCContext // out
	var _cret *C.JSCValue   // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))

	_cret = C.jsc_context_get_global_object(_arg0)
	runtime.KeepAlive(context)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// Value: get a property of context global object with name.
//
// The function takes the following parameters:
//
//    - name: value name.
//
func (context *Context) Value(name string) *Value {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _cret *C.JSCValue   // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.jsc_context_get_value(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(name)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// VirtualMachine: get the CVirtualMachine where context was created.
func (context *Context) VirtualMachine() *VirtualMachine {
	var _arg0 *C.JSCContext        // out
	var _cret *C.JSCVirtualMachine // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))

	_cret = C.jsc_context_get_virtual_machine(_arg0)
	runtime.KeepAlive(context)

	var _virtualMachine *VirtualMachine // out

	_virtualMachine = wrapVirtualMachine(externglib.Take(unsafe.Pointer(_cret)))

	return _virtualMachine
}

// PopExceptionHandler: remove the last CExceptionHandler previously pushed to
// context with jsc_context_push_exception_handler().
func (context *Context) PopExceptionHandler() {
	var _arg0 *C.JSCContext // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))

	C.jsc_context_pop_exception_handler(_arg0)
	runtime.KeepAlive(context)
}

// PushExceptionHandler: push an exception handler in context. Whenever a
// JavaScript exception happens in the CContext, the given handler will be
// called. The default CExceptionHandler simply calls
// jsc_context_throw_exception() to throw the exception to the CContext. If you
// don't want to catch the exception, but only get notified about it, call
// jsc_context_throw_exception() in handler like the default one does. The last
// exception handler pushed is the only one used by the CContext, use
// jsc_context_pop_exception_handler() to remove it and set the previous one.
// When handler is removed from the context, destroy_notify i called with
// user_data as parameter.
//
// The function takes the following parameters:
//
//    - handler: CExceptionHandler.
//
func (context *Context) PushExceptionHandler(handler ExceptionHandler) {
	var _arg0 *C.JSCContext         // out
	var _arg1 C.JSCExceptionHandler // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*[0]byte)(C._gotk4_javascriptcore4_ExceptionHandler)
	_arg2 = C.gpointer(gbox.Assign(handler))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.jsc_context_push_exception_handler(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(handler)
}

// SetValue: set a property of context global object with name and value.
//
// The function takes the following parameters:
//
//    - name: value name.
//    - value: CValue.
//
func (context *Context) SetValue(name string, value *Value) {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _arg2 *C.JSCValue   // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.JSCValue)(unsafe.Pointer(value.Native()))

	C.jsc_context_set_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// Throw an exception to context using the given error message. The created
// CException can be retrieved with jsc_context_get_exception().
//
// The function takes the following parameters:
//
//    - errorMessage: error message.
//
func (context *Context) Throw(errorMessage string) {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(errorMessage)))
	defer C.free(unsafe.Pointer(_arg1))

	C.jsc_context_throw(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(errorMessage)
}

// ThrowException: throw exception to context.
//
// The function takes the following parameters:
//
//    - exception: CException.
//
func (context *Context) ThrowException(exception *Exception) {
	var _arg0 *C.JSCContext   // out
	var _arg1 *C.JSCException // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.JSCException)(unsafe.Pointer(exception.Native()))

	C.jsc_context_throw_exception(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(exception)
}

// ThrowWithName: throw an exception to context using the given error name and
// message. The created CException can be retrieved with
// jsc_context_get_exception().
//
// The function takes the following parameters:
//
//    - errorName: error name.
//    - errorMessage: error message.
//
func (context *Context) ThrowWithName(errorName, errorMessage string) {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _arg2 *C.char       // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(errorName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(errorMessage)))
	defer C.free(unsafe.Pointer(_arg2))

	C.jsc_context_throw_with_name(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(errorName)
	runtime.KeepAlive(errorMessage)
}

// ContextGetCurrent: get the CContext that is currently executing a function.
// This should only be called within a function or method callback, otherwise
// NULL will be returned.
func ContextGetCurrent() *Context {
	var _cret *C.JSCContext // in

	_cret = C.jsc_context_get_current()

	var _context *Context // out

	if _cret != nil {
		_context = wrapContext(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _context
}
