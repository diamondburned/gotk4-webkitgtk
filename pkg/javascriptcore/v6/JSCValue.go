// Code generated by girgen. DO NOT EDIT.

package javascriptcore

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <jsc/jsc.h>
import "C"

// GType values.
var (
	GTypeValue = coreglib.Type(C.jsc_value_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeValue, F: marshalValue},
	})
}

// ValuePropertyFlags flags used when defining properties
// with jsc_value_object_define_property_data() and
// jsc_value_object_define_property_accessor().
type ValuePropertyFlags C.guint

const (
	// ValuePropertyConfigurable: type of the property descriptor may be changed
	// and the property may be deleted from the corresponding object.
	ValuePropertyConfigurable ValuePropertyFlags = 0b1
	// ValuePropertyEnumerable: property shows up during enumeration of the
	// properties on the corresponding object.
	ValuePropertyEnumerable ValuePropertyFlags = 0b10
	// ValuePropertyWritable: value associated with the property may be changed
	// with an assignment operator. This doesn't have any effect when passed to
	// jsc_value_object_define_property_accessor().
	ValuePropertyWritable ValuePropertyFlags = 0b100
)

// String returns the names in string for ValuePropertyFlags.
func (v ValuePropertyFlags) String() string {
	if v == 0 {
		return "ValuePropertyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(71)

	for v != 0 {
		next := v & (v - 1)
		bit := v - next

		switch bit {
		case ValuePropertyConfigurable:
			builder.WriteString("Configurable|")
		case ValuePropertyEnumerable:
			builder.WriteString("Enumerable|")
		case ValuePropertyWritable:
			builder.WriteString("Writable|")
		default:
			builder.WriteString(fmt.Sprintf("ValuePropertyFlags(0b%b)|", bit))
		}

		v = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if v contains other.
func (v ValuePropertyFlags) Has(other ValuePropertyFlags) bool {
	return (v & other) == other
}

// ValueOverrides contains methods that are overridable.
type ValueOverrides struct {
}

func defaultValueOverrides(v *Value) ValueOverrides {
	return ValueOverrides{}
}

// Value represents a reference to a value in a CContext. The JSCValue protects
// the referenced value from being garbage collected.
type Value struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Value)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Value, *ValueClass, ValueOverrides](
		GTypeValue,
		initValueClass,
		wrapValue,
		defaultValueOverrides,
	)
}

func initValueClass(gclass unsafe.Pointer, overrides ValueOverrides, classInitFunc func(*ValueClass)) {
	if classInitFunc != nil {
		class := (*ValueClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapValue(obj *coreglib.Object) *Value {
	return &Value{
		Object: obj,
	}
}

func marshalValue(p uintptr) (interface{}, error) {
	return wrapValue(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewValueArrayFromStrv: create a new CValue referencing an array of strings
// with the items from strv. If array is NULL or empty a new empty array will be
// created.
//
// The function takes the following parameters:
//
//   - context: CContext.
//   - strv: NULL-terminated array of strings.
//
// The function returns the following values:
//
//   - value: CValue.
//
func NewValueArrayFromStrv(context *Context, strv []string) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 **C.char      // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	{
		_arg2 = (**C.char)(C.calloc(C.size_t((len(strv) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(strv)+1)
			var zero *C.char
			out[len(strv)] = zero
			for i := range strv {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(strv[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.jsc_value_new_array_from_strv(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(strv)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueBoolean: create a new CValue from value.
//
// The function takes the following parameters:
//
//   - context: CContext.
//   - value: #gboolean.
//
// The function returns the following values:
//
//   - ret: CValue.
//
func NewValueBoolean(context *Context, value bool) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 C.gboolean    // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if value {
		_arg2 = C.TRUE
	}

	_cret = C.jsc_value_new_boolean(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(value)

	var _ret *Value // out

	_ret = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// NewValueFromJson: create a new CValue referencing a new value created by
// parsing json.
//
// The function takes the following parameters:
//
//   - context: CContext.
//   - json: JSON string to be parsed.
//
// The function returns the following values:
//
//   - value: CValue.
//
func NewValueFromJson(context *Context, json string) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 *C.char       // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(json)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.jsc_value_new_from_json(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(json)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueNull: create a new CValue referencing <function>null</function> in
// context.
//
// The function takes the following parameters:
//
//   - context: CContext.
//
// The function returns the following values:
//
//   - value: CValue.
//
func NewValueNull(context *Context) *Value {
	var _arg1 *C.JSCContext // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.jsc_value_new_null(_arg1)
	runtime.KeepAlive(context)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueNumber: create a new CValue from number.
//
// The function takes the following parameters:
//
//   - context: CContext.
//   - number: number.
//
// The function returns the following values:
//
//   - value: CValue.
//
func NewValueNumber(context *Context, number float64) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 C.double      // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.double(number)

	_cret = C.jsc_value_new_number(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(number)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueObject: create a new CValue from instance. If instance is NULL a
// new empty object is created. When instance is provided, jsc_class must be
// provided too. jsc_class takes ownership of instance that will be freed by the
// Notify passed to jsc_context_register_class().
//
// The function takes the following parameters:
//
//   - context: CContext.
//   - instance (optional): object instance or NULL.
//   - jscClass (optional) of instance.
//
// The function returns the following values:
//
//   - value: CValue.
//
func NewValueObject(context *Context, instance unsafe.Pointer, jscClass *Class) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 C.gpointer    // out
	var _arg3 *C.JSCClass   // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (C.gpointer)(unsafe.Pointer(instance))
	if jscClass != nil {
		_arg3 = (*C.JSCClass)(unsafe.Pointer(coreglib.InternObject(jscClass).Native()))
	}

	_cret = C.jsc_value_new_object(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(instance)
	runtime.KeepAlive(jscClass)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueString: create a new CValue from string. If you need to
// create a CValue from a string containing null characters, use
// jsc_value_new_string_from_bytes() instead.
//
// The function takes the following parameters:
//
//   - context: CContext.
//   - str (optional): null-terminated string.
//
// The function returns the following values:
//
//   - value: CValue.
//
func NewValueString(context *Context, str string) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 *C.char       // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if str != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.jsc_value_new_string(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(str)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueStringFromBytes: create a new CValue from bytes.
//
// The function takes the following parameters:
//
//   - context: CContext.
//   - bytes (optional): #GBytes.
//
// The function returns the following values:
//
//   - value: CValue.
//
func NewValueStringFromBytes(context *Context, bytes *glib.Bytes) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 *C.GBytes     // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if bytes != nil {
		_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	}

	_cret = C.jsc_value_new_string_from_bytes(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(bytes)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueTypedArray: create a new typed array containing a given amount of
// elements.
//
// Create a CValue referencing a new typed array with space for length elements
// of a given type. As all typed arrays must have an associated ArrayBuffer,
// a new one of suitable size will be allocated to store the elements, which
// will be initialized to zero.
//
// The type must *not* be JSC_TYPED_ARRAY_NONE.
//
// The function takes the following parameters:
//
//   - context: CContext.
//   - typ: type of array elements.
//   - length: number of elements in the array.
//
// The function returns the following values:
//
//   - value: CValue.
//
func NewValueTypedArray(context *Context, typ TypedArrayType, length uint) *Value {
	var _arg1 *C.JSCContext       // out
	var _arg2 C.JSCTypedArrayType // out
	var _arg3 C.gsize             // out
	var _cret *C.JSCValue         // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.JSCTypedArrayType(typ)
	_arg3 = C.gsize(length)

	_cret = C.jsc_value_new_typed_array(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(length)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueUndefined: create a new CValue referencing
// <function>undefined</function> in context.
//
// The function takes the following parameters:
//
//   - context: CContext.
//
// The function returns the following values:
//
//   - value: CValue.
//
func NewValueUndefined(context *Context) *Value {
	var _arg1 *C.JSCContext // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.jsc_value_new_undefined(_arg1)
	runtime.KeepAlive(context)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// ArrayBufferGetData gets a pointer to memory that contains the array buffer
// data.
//
// Obtains a pointer to the memory region that holds the contents of the
// ArrayBuffer; modifications done to the data will be visible to JavaScript
// code. If size is not NULL, the size in bytes of the memory region will also
// be stored in the pointed location.
//
// Note that the pointer returned by this function is not guaranteed to remain
// the same after calls to other JSC API functions. If you plan to access the
// data of the ArrayBuffer later, you can keep a reference to the value and
// obtain the data pointer at a later point. Keep in mind that if JavaScript
// code has a chance to run, for example due to main loop events that result in
// JSC being called, the contents of the memory region might be modified in the
// meantime. Consider taking a copy of the data and using the copy instead in
// asynchronous code.
//
// The function takes the following parameters:
//
//   - size (optional): location where to store the size of the memory region.
//
// The function returns the following values:
//
//   - gpointer (optional): pointer to memory.
//
func (value *Value) ArrayBufferGetData(size *uint) unsafe.Pointer {
	var _arg0 *C.JSCValue // out
	var _arg1 *C.gsize    // out
	var _cret C.gpointer  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	if size != nil {
		_arg1 = (*C.gsize)(unsafe.Pointer(size))
	}

	_cret = C.jsc_value_array_buffer_get_data(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(size)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// ArrayBufferGetSize gets the size in bytes of the array buffer.
//
// Obtains the size in bytes of the memory region that holds the contents of an
// ArrayBuffer.
//
// The function returns the following values:
//
//   - gsize: size, in bytes.
//
func (value *Value) ArrayBufferGetSize() uint {
	var _arg0 *C.JSCValue // out
	var _cret C.gsize     // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_array_buffer_get_size(_arg0)
	runtime.KeepAlive(value)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// ConstructorCall: invoke <function>new</function> with constructor referenced
// by value. If n_parameters is 0 no parameters will be passed to the
// constructor.
//
// The function takes the following parameters:
//
//   - parameters (optional) -->s to pass as parameters to the constructor,
//     or NULL.
//
// The function returns the following values:
//
//   - ret referencing the newly created object instance.
//
func (value *Value) ConstructorCall(parameters []*Value) *Value {
	var _arg0 *C.JSCValue  // out
	var _arg2 **C.JSCValue // out
	var _arg1 C.guint
	var _cret *C.JSCValue // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	if parameters != nil {
		_arg1 = (C.guint)(len(parameters))
		_arg2 = (**C.JSCValue)(C.calloc(C.size_t(len(parameters)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice((**C.JSCValue)(_arg2), len(parameters))
			for i := range parameters {
				out[i] = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(parameters[i]).Native()))
			}
		}
	}

	_cret = C.jsc_value_constructor_callv(_arg0, _arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(parameters)

	var _ret *Value // out

	_ret = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// FunctionCall: call function referenced by value, passing the given
// parameters. If n_parameters is 0 no parameters will be passed to the
// function.
//
// This function always returns a CValue, in case of void functions a CValue
// referencing <function>undefined</function> is returned.
//
// The function takes the following parameters:
//
//   - parameters (optional) -->s to pass as parameters to the function,
//     or NULL.
//
// The function returns the following values:
//
//   - ret with the return value of the function.
//
func (value *Value) FunctionCall(parameters []*Value) *Value {
	var _arg0 *C.JSCValue  // out
	var _arg2 **C.JSCValue // out
	var _arg1 C.guint
	var _cret *C.JSCValue // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	if parameters != nil {
		_arg1 = (C.guint)(len(parameters))
		_arg2 = (**C.JSCValue)(C.calloc(C.size_t(len(parameters)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice((**C.JSCValue)(_arg2), len(parameters))
			for i := range parameters {
				out[i] = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(parameters[i]).Native()))
			}
		}
	}

	_cret = C.jsc_value_function_callv(_arg0, _arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(parameters)

	var _ret *Value // out

	_ret = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// Context: get the CContext in which value was created.
//
// The function returns the following values:
//
//   - context: CValue context.
//
func (value *Value) Context() *Context {
	var _arg0 *C.JSCValue   // out
	var _cret *C.JSCContext // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_get_context(_arg0)
	runtime.KeepAlive(value)

	var _context *Context // out

	_context = wrapContext(coreglib.Take(unsafe.Pointer(_cret)))

	return _context
}

// IsArray: get whether the value referenced by value is an array.
//
// The function returns the following values:
//
//   - ok: whether the value is an array.
//
func (value *Value) IsArray() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_array(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsArrayBuffer: check whether the value is an ArrayBuffer.
//
// The function returns the following values:
//
//   - ok: whether the value is an ArrayBuffer.
//
func (value *Value) IsArrayBuffer() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_array_buffer(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsBoolean: get whether the value referenced by value is a boolean.
//
// The function returns the following values:
//
//   - ok: whether the value is a boolean.
//
func (value *Value) IsBoolean() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_boolean(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsConstructor: get whether the value referenced by value is a constructor.
//
// The function returns the following values:
//
//   - ok: whether the value is a constructor.
//
func (value *Value) IsConstructor() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_constructor(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFunction: get whether the value referenced by value is a function.
//
// The function returns the following values:
//
//   - ok: whether the value is a function.
//
func (value *Value) IsFunction() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_function(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsNull: get whether the value referenced by value is
// <function>null</function>.
//
// The function returns the following values:
//
//   - ok: whether the value is null.
//
func (value *Value) IsNull() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_null(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsNumber: get whether the value referenced by value is a number.
//
// The function returns the following values:
//
//   - ok: whether the value is a number.
//
func (value *Value) IsNumber() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_number(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsObject: get whether the value referenced by value is an object.
//
// The function returns the following values:
//
//   - ok: whether the value is an object.
//
func (value *Value) IsObject() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_object(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsString: get whether the value referenced by value is a string.
//
// The function returns the following values:
//
//   - ok: whether the value is a string.
//
func (value *Value) IsString() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_string(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsTypedArray determines whether a value is a typed array.
//
// The function returns the following values:
//
//   - ok: whether value is a typed array.
//
func (value *Value) IsTypedArray() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_typed_array(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsUndefined: get whether the value referenced by value is
// <function>undefined</function>.
//
// The function returns the following values:
//
//   - ok: whether the value is undefined.
//
func (value *Value) IsUndefined() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_undefined(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewTypedArrayWithBuffer: create a new typed array value with elements from an
// array buffer.
//
// Create a CValue referencing a new typed array value containing elements
// of the given type, where the elements are stored at the memory region
// represented by the array_buffer.
//
// The type must *not* be JSC_TYPED_ARRAY_NONE.
//
// The offset and length parameters can be used to indicate which part of the
// array buffer can be accessed through the typed array. If both are omitted
// (passing zero as offset, and -1 as length), the whole array_buffer is exposed
// through the typed array. Omitting the length with a non-zero offset will
// expose the remainder of the array_buffer starting at the indicated offset.
//
// The function takes the following parameters:
//
//   - typ: type of array elements.
//   - offset: offset, in bytes.
//   - length: number of array elements, or -1.
//
// The function returns the following values:
//
//   - value: CValue.
//
func (arrayBuffer *Value) NewTypedArrayWithBuffer(typ TypedArrayType, offset uint, length int) *Value {
	var _arg0 *C.JSCValue         // out
	var _arg1 C.JSCTypedArrayType // out
	var _arg2 C.gsize             // out
	var _arg3 C.gssize            // out
	var _cret *C.JSCValue         // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(arrayBuffer).Native()))
	_arg1 = C.JSCTypedArrayType(typ)
	_arg2 = C.gsize(offset)
	_arg3 = C.gssize(length)

	_cret = C.jsc_value_new_typed_array_with_buffer(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(arrayBuffer)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(length)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// ObjectDefinePropertyData: define or modify a property with property_name
// in object referenced by value. This is equivalent to JavaScript
// <function>Object.defineProperty()</function> when used with a data
// descriptor.
//
// The function takes the following parameters:
//
//   - propertyName: name of the property to define.
//   - flags: CValuePropertyFlags.
//   - propertyValue (optional): default property value.
//
func (value *Value) ObjectDefinePropertyData(propertyName string, flags ValuePropertyFlags, propertyValue *Value) {
	var _arg0 *C.JSCValue             // out
	var _arg1 *C.char                 // out
	var _arg2 C.JSCValuePropertyFlags // out
	var _arg3 *C.JSCValue             // out

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.JSCValuePropertyFlags(flags)
	if propertyValue != nil {
		_arg3 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(propertyValue).Native()))
	}

	C.jsc_value_object_define_property_data(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(propertyValue)
}

// ObjectDeleteProperty: try to delete property with name from value.
// This function will return FALSE if the property was defined without
// JSC_VALUE_PROPERTY_CONFIGURABLE flag.
//
// The function takes the following parameters:
//
//   - name: property name.
//
// The function returns the following values:
//
//   - ok: TRUE if the property was deleted, or FALSE otherwise.
//
func (value *Value) ObjectDeleteProperty(name string) bool {
	var _arg0 *C.JSCValue // out
	var _arg1 *C.char     // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.jsc_value_object_delete_property(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ObjectEnumerateProperties: get the list of property names of value. Only
// properties defined with JSC_VALUE_PROPERTY_ENUMERABLE flag will be collected.
//
// The function returns the following values:
//
//   - utf8s (optional): NULL-terminated array of strings containing the
//     property names, or NULL if value doesn't have enumerable properties.
//     Use g_strfreev() to free.
//
func (value *Value) ObjectEnumerateProperties() []string {
	var _arg0 *C.JSCValue // out
	var _cret **C.gchar   // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_object_enumerate_properties(_arg0)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// ObjectGetProperty: get property with name from value.
//
// The function takes the following parameters:
//
//   - name: property name.
//
// The function returns the following values:
//
//   - ret: property CValue.
//
func (value *Value) ObjectGetProperty(name string) *Value {
	var _arg0 *C.JSCValue // out
	var _arg1 *C.char     // out
	var _cret *C.JSCValue // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.jsc_value_object_get_property(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)

	var _ret *Value // out

	_ret = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// ObjectGetPropertyAtIndex: get property at index from value.
//
// The function takes the following parameters:
//
//   - index: property index.
//
// The function returns the following values:
//
//   - ret: property CValue.
//
func (value *Value) ObjectGetPropertyAtIndex(index uint) *Value {
	var _arg0 *C.JSCValue // out
	var _arg1 C.guint     // out
	var _cret *C.JSCValue // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	_arg1 = C.guint(index)

	_cret = C.jsc_value_object_get_property_at_index(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(index)

	var _ret *Value // out

	_ret = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// ObjectHasProperty: get whether value has property with name.
//
// The function takes the following parameters:
//
//   - name: property name.
//
// The function returns the following values:
//
//   - ok: TRUE if value has a property with name, or FALSE otherwise.
//
func (value *Value) ObjectHasProperty(name string) bool {
	var _arg0 *C.JSCValue // out
	var _arg1 *C.char     // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.jsc_value_object_has_property(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ObjectInvokeMethod: invoke method with name on object referenced by value,
// passing the given parameters. If n_parameters is 0 no parameters will be
// passed to the method. The object instance will be handled automatically even
// when the method is a custom one registered with jsc_class_add_method(),
// so it should never be passed explicitly as parameter of this function.
//
// This function always returns a CValue, in case of void methods a CValue
// referencing <function>undefined</function> is returned.
//
// The function takes the following parameters:
//
//   - name: method name.
//   - parameters (optional) -->s to pass as parameters to the method, or NULL.
//
// The function returns the following values:
//
//   - ret with the return value of the method.
//
func (value *Value) ObjectInvokeMethod(name string, parameters []*Value) *Value {
	var _arg0 *C.JSCValue  // out
	var _arg1 *C.char      // out
	var _arg3 **C.JSCValue // out
	var _arg2 C.guint
	var _cret *C.JSCValue // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameters != nil {
		_arg2 = (C.guint)(len(parameters))
		_arg3 = (**C.JSCValue)(C.calloc(C.size_t(len(parameters)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice((**C.JSCValue)(_arg3), len(parameters))
			for i := range parameters {
				out[i] = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(parameters[i]).Native()))
			}
		}
	}

	_cret = C.jsc_value_object_invoke_methodv(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)
	runtime.KeepAlive(parameters)

	var _ret *Value // out

	_ret = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// ObjectIsInstanceOf: get whether the value referenced by value is an instance
// of class name.
//
// The function takes the following parameters:
//
//   - name class name.
//
// The function returns the following values:
//
//   - ok: whether the value is an object instance of class name.
//
func (value *Value) ObjectIsInstanceOf(name string) bool {
	var _arg0 *C.JSCValue // out
	var _arg1 *C.char     // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.jsc_value_object_is_instance_of(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ObjectSetProperty: set property with name on value.
//
// The function takes the following parameters:
//
//   - name: property name.
//   - property to set.
//
func (value *Value) ObjectSetProperty(name string, property *Value) {
	var _arg0 *C.JSCValue // out
	var _arg1 *C.char     // out
	var _arg2 *C.JSCValue // out

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(property).Native()))

	C.jsc_value_object_set_property(_arg0, _arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)
	runtime.KeepAlive(property)
}

// ObjectSetPropertyAtIndex: set property at index on value.
//
// The function takes the following parameters:
//
//   - index: property index.
//   - property to set.
//
func (value *Value) ObjectSetPropertyAtIndex(index uint, property *Value) {
	var _arg0 *C.JSCValue // out
	var _arg1 C.guint     // out
	var _arg2 *C.JSCValue // out

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	_arg1 = C.guint(index)
	_arg2 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(property).Native()))

	C.jsc_value_object_set_property_at_index(_arg0, _arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(index)
	runtime.KeepAlive(property)
}

// ToBoolean: convert value to a boolean.
//
// The function returns the following values:
//
//   - ok result of the conversion.
//
func (value *Value) ToBoolean() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_to_boolean(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ToDouble: convert value to a double.
//
// The function returns the following values:
//
//   - gdouble result of the conversion.
//
func (value *Value) ToDouble() float64 {
	var _arg0 *C.JSCValue // out
	var _cret C.double    // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_to_double(_arg0)
	runtime.KeepAlive(value)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ToInt32: convert value to a #gint32.
//
// The function returns the following values:
//
//   - gint32 result of the conversion.
//
func (value *Value) ToInt32() int32 {
	var _arg0 *C.JSCValue // out
	var _cret C.gint32    // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_to_int32(_arg0)
	runtime.KeepAlive(value)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// ToJson: create a JSON string of value serialization. If indent is 0, the
// resulting JSON will not contain newlines. The size of the indent is clamped
// to 10 spaces.
//
// The function takes the following parameters:
//
//   - indent: number of spaces to indent when nesting.
//
// The function returns the following values:
//
//   - utf8: null-terminated JSON string with serialization of value.
//
func (value *Value) ToJson(indent uint) string {
	var _arg0 *C.JSCValue // out
	var _arg1 C.guint     // out
	var _cret *C.char     // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))
	_arg1 = C.guint(indent)

	_cret = C.jsc_value_to_json(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(indent)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// String: convert value to a string. Use jsc_value_to_string_as_bytes()
// instead, if you need to handle strings containing null characters.
//
// The function returns the following values:
//
//   - utf8: null-terminated string result of the conversion.
//
func (value *Value) String() string {
	var _arg0 *C.JSCValue // out
	var _cret *C.char     // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_to_string(_arg0)
	runtime.KeepAlive(value)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToStringAsBytes: convert value to a string and return the results as #GBytes.
// This is needed to handle strings with null characters.
//
// The function returns the following values:
//
//   - bytes with the result of the conversion.
//
func (value *Value) ToStringAsBytes() *glib.Bytes {
	var _arg0 *C.JSCValue // out
	var _cret *C.GBytes   // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_to_string_as_bytes(_arg0)
	runtime.KeepAlive(value)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// TypedArrayGetBuffer: obtain the ArrayBuffer for the memory region of the
// typed array elements.
//
// The function returns the following values:
//
//   - ret: CValue.
//
func (value *Value) TypedArrayGetBuffer() *Value {
	var _arg0 *C.JSCValue // out
	var _cret *C.JSCValue // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_typed_array_get_buffer(_arg0)
	runtime.KeepAlive(value)

	var _ret *Value // out

	_ret = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// TypedArrayGetData obtains a pointer to the memory region that holds the
// elements of the typed array; modifications done to them will be visible to
// JavaScript code. If length is not NULL, the number of elements contained in
// the typed array are also stored in the pointed location.
//
// The returned pointer needs to be casted to the appropriate type (see
// CTypedArrayType), and has the offset over the underlying array buffer data
// applied—that is, points to the first element of the typed array:
//
//    if (jsc_value_typed_array_get_type(value) != JSC_TYPED_ARRAY_UINT32)
//        g_error ("Only arrays of uint32_t are supported");
//
//    gsize count = 0;
//    uint32_t *elements = jsc_value_typed_array_get_contents (value, &count);
//    for (gsize i = 0; i < count; i++)
//         g_print ("index zu, value %" PRIu32 "\n", i, elements[i]);
//
// Note that the pointer returned by this function is not guaranteed
// to remain the same after calls to other JSC API functions. See
// jsc_value_array_buffer_get_data() for details.
//
// The function returns the following values:
//
//   - length (optional): location to return the number of elements contained.
//   - gpointer (optional): pointer to memory.
//
func (value *Value) TypedArrayGetData() (uint, unsafe.Pointer) {
	var _arg0 *C.JSCValue // out
	var _arg1 C.gsize     // in
	var _cret C.gpointer  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_typed_array_get_data(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _length uint             // out
	var _gpointer unsafe.Pointer // out

	_length = uint(_arg1)
	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _length, _gpointer
}

// TypedArrayGetLength gets the number of elements in a typed array.
//
// The function returns the following values:
//
//   - gsize: number of elements.
//
func (value *Value) TypedArrayGetLength() uint {
	var _arg0 *C.JSCValue // out
	var _cret C.gsize     // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_typed_array_get_length(_arg0)
	runtime.KeepAlive(value)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// TypedArrayGetOffset gets the offset over the underlying array buffer data.
//
// The function returns the following values:
//
//   - gsize: offset, in bytes.
//
func (value *Value) TypedArrayGetOffset() uint {
	var _arg0 *C.JSCValue // out
	var _cret C.gsize     // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_typed_array_get_offset(_arg0)
	runtime.KeepAlive(value)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// TypedArrayGetSize gets the size of a typed array.
//
// The function returns the following values:
//
//   - gsize: size, in bytes.
//
func (value *Value) TypedArrayGetSize() uint {
	var _arg0 *C.JSCValue // out
	var _cret C.gsize     // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_typed_array_get_size(_arg0)
	runtime.KeepAlive(value)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// TypedArrayGetType gets the type of elements contained in a typed array.
//
// The function returns the following values:
//
//   - typedArrayType: type of the elements, or JSC_TYPED_ARRAY_NONE if value is
//     not a typed array.
//
func (value *Value) TypedArrayGetType() TypedArrayType {
	var _arg0 *C.JSCValue         // out
	var _cret C.JSCTypedArrayType // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	_cret = C.jsc_value_typed_array_get_type(_arg0)
	runtime.KeepAlive(value)

	var _typedArrayType TypedArrayType // out

	_typedArrayType = TypedArrayType(_cret)

	return _typedArrayType
}

// ValueClass: instance of this type is always passed by reference.
type ValueClass struct {
	*valueClass
}

// valueClass is the struct that's finalized.
type valueClass struct {
	native *C.JSCValueClass
}
