// Code generated by girgen. DO NOT EDIT.

package javascriptcore

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <jsc/jsc.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_javascriptcore6_ExceptionHandler(JSCContext*, JSCException*, gpointer);
import "C"

// GType values.
var (
	GTypeContext = coreglib.Type(C.jsc_context_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeContext, F: marshalContext},
	})
}

// CheckSyntaxMode: enum values to specify a mode to check for syntax errors in
// jsc_context_check_syntax().
type CheckSyntaxMode C.gint

const (
	// CheckSyntaxModeScript: mode to check syntax of a script.
	CheckSyntaxModeScript CheckSyntaxMode = iota
	// CheckSyntaxModeModule: mode to check syntax of a module.
	CheckSyntaxModeModule
)

// String returns the name in string for CheckSyntaxMode.
func (c CheckSyntaxMode) String() string {
	switch c {
	case CheckSyntaxModeScript:
		return "Script"
	case CheckSyntaxModeModule:
		return "Module"
	default:
		return fmt.Sprintf("CheckSyntaxMode(%d)", c)
	}
}

// CheckSyntaxResult: enum values to specify the result of
// jsc_context_check_syntax().
type CheckSyntaxResult C.gint

const (
	// CheckSyntaxResultSuccess: no errors.
	CheckSyntaxResultSuccess CheckSyntaxResult = iota
	// CheckSyntaxResultRecoverableError: recoverable syntax error.
	CheckSyntaxResultRecoverableError
	// CheckSyntaxResultIrrecoverableError: irrecoverable syntax error.
	CheckSyntaxResultIrrecoverableError
	// CheckSyntaxResultUnterminatedLiteralError: unterminated literal error.
	CheckSyntaxResultUnterminatedLiteralError
	// CheckSyntaxResultOutOfMemoryError: out of memory error.
	CheckSyntaxResultOutOfMemoryError
	// CheckSyntaxResultStackOverflowError: stack overflow error.
	CheckSyntaxResultStackOverflowError
)

// String returns the name in string for CheckSyntaxResult.
func (c CheckSyntaxResult) String() string {
	switch c {
	case CheckSyntaxResultSuccess:
		return "Success"
	case CheckSyntaxResultRecoverableError:
		return "RecoverableError"
	case CheckSyntaxResultIrrecoverableError:
		return "IrrecoverableError"
	case CheckSyntaxResultUnterminatedLiteralError:
		return "UnterminatedLiteralError"
	case CheckSyntaxResultOutOfMemoryError:
		return "OutOfMemoryError"
	case CheckSyntaxResultStackOverflowError:
		return "StackOverflowError"
	default:
		return fmt.Sprintf("CheckSyntaxResult(%d)", c)
	}
}

// ExceptionHandler: function used to handle JavaScript exceptions in a
// CContext.
type ExceptionHandler func(context *Context, exception *Exception)

// ContextOverrides contains methods that are overridable.
type ContextOverrides struct {
}

func defaultContextOverrides(v *Context) ContextOverrides {
	return ContextOverrides{}
}

// Context represents a JavaScript execution context, where all operations take
// place and where the values will be associated.
//
// When a new context is created, a global object is allocated and the built-in
// JavaScript objects (Object, Function, String, Array) are populated.
// You can execute JavaScript in the context by using jsc_context_evaluate() or
// jsc_context_evaluate_with_source_uri(). It's also possible to register custom
// objects in the context with jsc_context_register_class().
type Context struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Context)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Context, *ContextClass, ContextOverrides](
		GTypeContext,
		initContextClass,
		wrapContext,
		defaultContextOverrides,
	)
}

func initContextClass(gclass unsafe.Pointer, overrides ContextOverrides, classInitFunc func(*ContextClass)) {
	if classInitFunc != nil {
		class := (*ContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapContext(obj *coreglib.Object) *Context {
	return &Context{
		Object: obj,
	}
}

func marshalContext(p uintptr) (interface{}, error) {
	return wrapContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewContext: create a new CContext. The context is created in a new
// CVirtualMachine. Use jsc_context_new_with_virtual_machine() to create a new
// CContext in an existing CVirtualMachine.
//
// The function returns the following values:
//
//   - context: newly created CContext.
//
func NewContext() *Context {
	var _cret *C.JSCContext // in

	_cret = C.jsc_context_new()

	var _context *Context // out

	_context = wrapContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _context
}

// NewContextWithVirtualMachine: create a new CContext in virtual_machine.
//
// The function takes the following parameters:
//
//   - vm: CVirtualMachine.
//
// The function returns the following values:
//
//   - context: newly created CContext.
//
func NewContextWithVirtualMachine(vm *VirtualMachine) *Context {
	var _arg1 *C.JSCVirtualMachine // out
	var _cret *C.JSCContext        // in

	_arg1 = (*C.JSCVirtualMachine)(unsafe.Pointer(coreglib.InternObject(vm).Native()))

	_cret = C.jsc_context_new_with_virtual_machine(_arg1)
	runtime.KeepAlive(vm)

	var _context *Context // out

	_context = wrapContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _context
}

// CheckSyntax: check the given code in context for syntax errors. The
// line_number is the starting line number in uri; the value is one-based so the
// first line is 1. uri and line_number are only used to fill the exception.
// In case of errors exception will be set to a new CException with the details.
// You can pass NULL to exception to ignore the error details.
//
// The function takes the following parameters:
//
//   - code: javaScript script to check.
//   - length of code, or -1 if code is a nul-terminated string.
//   - mode: CCheckSyntaxMode.
//   - uri: source URI.
//   - lineNumber: starting line number.
//
// The function returns the following values:
//
//   - exception (optional): return location for a CException, or NULL to
//     ignore.
//   - checkSyntaxResult: CCheckSyntaxResult.
//
func (context *Context) CheckSyntax(code string, length int, mode CheckSyntaxMode, uri string, lineNumber uint) (*Exception, CheckSyntaxResult) {
	var _arg0 *C.JSCContext          // out
	var _arg1 *C.char                // out
	var _arg2 C.gssize               // out
	var _arg3 C.JSCCheckSyntaxMode   // out
	var _arg4 *C.char                // out
	var _arg5 C.unsigned             // out
	var _arg6 *C.JSCException        // in
	var _cret C.JSCCheckSyntaxResult // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)
	_arg3 = C.JSCCheckSyntaxMode(mode)
	_arg4 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = C.unsigned(lineNumber)

	_cret = C.jsc_context_check_syntax(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(code)
	runtime.KeepAlive(length)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(lineNumber)

	var _exception *Exception                // out
	var _checkSyntaxResult CheckSyntaxResult // out

	if _arg6 != nil {
		_exception = wrapException(coreglib.AssumeOwnership(unsafe.Pointer(_arg6)))
	}
	_checkSyntaxResult = CheckSyntaxResult(_cret)

	return _exception, _checkSyntaxResult
}

// ClearException: clear the uncaught exception in context if any.
func (context *Context) ClearException() {
	var _arg0 *C.JSCContext // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.jsc_context_clear_exception(_arg0)
	runtime.KeepAlive(context)
}

// Evaluate code in context.
//
// The function takes the following parameters:
//
//   - code: javaScript script to evaluate.
//   - length of code, or -1 if code is a nul-terminated string.
//
// The function returns the following values:
//
//   - value representing the last value generated by the script.
//
func (context *Context) Evaluate(code string, length int) *Value {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _cret *C.JSCValue   // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)

	_cret = C.jsc_context_evaluate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(code)
	runtime.KeepAlive(length)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// EvaluateInObject: evaluate code and create an new object where symbols
// defined in code will be added as properties, instead of being added to
// context global object. The new object is returned as object parameter.
// Similar to how jsc_value_new_object() works, if object_instance is not
// NULL object_class must be provided too. The line_number is the starting
// line number in uri; the value is one-based so the first line is 1. uri and
// line_number will be shown in exceptions and they don't affect the behavior of
// the script.
//
// The function takes the following parameters:
//
//   - code: javaScript script to evaluate.
//   - length of code, or -1 if code is a nul-terminated string.
//   - objectInstance (optional): object instance.
//   - objectClass (optional) or NULL to use the default.
//   - uri: source URI.
//   - lineNumber: starting line number.
//
// The function returns the following values:
//
//   - object: return location for a CValue.
//   - value representing the last value generated by the script.
//
func (context *Context) EvaluateInObject(code string, length int, objectInstance unsafe.Pointer, objectClass *Class, uri string, lineNumber uint) (object, value *Value) {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _arg3 C.gpointer    // out
	var _arg4 *C.JSCClass   // out
	var _arg5 *C.char       // out
	var _arg6 C.guint       // out
	var _arg7 *C.JSCValue   // in
	var _cret *C.JSCValue   // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)
	_arg3 = (C.gpointer)(unsafe.Pointer(objectInstance))
	if objectClass != nil {
		_arg4 = (*C.JSCClass)(unsafe.Pointer(coreglib.InternObject(objectClass).Native()))
	}
	_arg5 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = C.guint(lineNumber)

	_cret = C.jsc_context_evaluate_in_object(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, &_arg7)
	runtime.KeepAlive(context)
	runtime.KeepAlive(code)
	runtime.KeepAlive(length)
	runtime.KeepAlive(objectInstance)
	runtime.KeepAlive(objectClass)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(lineNumber)

	var _object *Value // out
	var _value *Value  // out

	_object = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_arg7)))
	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _object, _value
}

// EvaluateWithSourceURI: evaluate code in context using uri as the source URI.
// The line_number is the starting line number in uri; the value is one-based so
// the first line is 1. uri and line_number will be shown in exceptions and they
// don't affect the behavior of the script.
//
// The function takes the following parameters:
//
//   - code: javaScript script to evaluate.
//   - length of code, or -1 if code is a nul-terminated string.
//   - uri: source URI.
//   - lineNumber: starting line number.
//
// The function returns the following values:
//
//   - value representing the last value generated by the script.
//
func (context *Context) EvaluateWithSourceURI(code string, length int, uri string, lineNumber uint) *Value {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _arg3 *C.char       // out
	var _arg4 C.guint       // out
	var _cret *C.JSCValue   // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.guint(lineNumber)

	_cret = C.jsc_context_evaluate_with_source_uri(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(code)
	runtime.KeepAlive(length)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(lineNumber)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// Exception: get the last unhandled exception thrown in context by API
// functions calls.
//
// The function returns the following values:
//
//   - exception (optional) or NULL if there isn't any unhandled exception in
//     the CContext.
//
func (context *Context) Exception() *Exception {
	var _arg0 *C.JSCContext   // out
	var _cret *C.JSCException // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.jsc_context_get_exception(_arg0)
	runtime.KeepAlive(context)

	var _exception *Exception // out

	if _cret != nil {
		_exception = wrapException(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _exception
}

// GlobalObject: get a CValue referencing the context global object.
//
// The function returns the following values:
//
//   - value: CValue.
//
func (context *Context) GlobalObject() *Value {
	var _arg0 *C.JSCContext // out
	var _cret *C.JSCValue   // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.jsc_context_get_global_object(_arg0)
	runtime.KeepAlive(context)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// Value: get a property of context global object with name.
//
// The function takes the following parameters:
//
//   - name: value name.
//
// The function returns the following values:
//
//   - value: CValue.
//
func (context *Context) Value(name string) *Value {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _cret *C.JSCValue   // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.jsc_context_get_value(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(name)

	var _value *Value // out

	_value = wrapValue(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// VirtualMachine: get the CVirtualMachine where context was created.
//
// The function returns the following values:
//
//   - virtualMachine where the CContext was created.
//
func (context *Context) VirtualMachine() *VirtualMachine {
	var _arg0 *C.JSCContext        // out
	var _cret *C.JSCVirtualMachine // in

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.jsc_context_get_virtual_machine(_arg0)
	runtime.KeepAlive(context)

	var _virtualMachine *VirtualMachine // out

	_virtualMachine = wrapVirtualMachine(coreglib.Take(unsafe.Pointer(_cret)))

	return _virtualMachine
}

// PopExceptionHandler: remove the last CExceptionHandler previously pushed to
// context with jsc_context_push_exception_handler().
func (context *Context) PopExceptionHandler() {
	var _arg0 *C.JSCContext // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.jsc_context_pop_exception_handler(_arg0)
	runtime.KeepAlive(context)
}

// PushExceptionHandler: push an exception handler in context.
// Whenever a JavaScript exception happens in the CContext, the given
// handler will be called. The default CExceptionHandler simply calls
// jsc_context_throw_exception() to throw the exception to the CContext.
// If you don't want to catch the exception, but only get notified about it,
// call jsc_context_throw_exception() in handler like the default one does.
// The last exception handler pushed is the only one used by the CContext,
// use jsc_context_pop_exception_handler() to remove it and set the previous
// one. When handler is removed from the context, destroy_notify i called with
// user_data as parameter.
//
// The function takes the following parameters:
//
//   - handler: CExceptionHandler.
//
func (context *Context) PushExceptionHandler(handler ExceptionHandler) {
	var _arg0 *C.JSCContext         // out
	var _arg1 C.JSCExceptionHandler // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*[0]byte)(C._gotk4_javascriptcore6_ExceptionHandler)
	_arg2 = C.gpointer(gbox.Assign(handler))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.jsc_context_push_exception_handler(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(handler)
}

// SetValue: set a property of context global object with name and value.
//
// The function takes the following parameters:
//
//   - name: value name.
//   - value: CValue.
//
func (context *Context) SetValue(name string, value *Value) {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _arg2 *C.JSCValue   // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(value).Native()))

	C.jsc_context_set_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// Throw an exception to context using the given error message. The created
// CException can be retrieved with jsc_context_get_exception().
//
// The function takes the following parameters:
//
//   - errorMessage: error message.
//
func (context *Context) Throw(errorMessage string) {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(errorMessage)))
	defer C.free(unsafe.Pointer(_arg1))

	C.jsc_context_throw(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(errorMessage)
}

// ThrowException: throw exception to context.
//
// The function takes the following parameters:
//
//   - exception: CException.
//
func (context *Context) ThrowException(exception *Exception) {
	var _arg0 *C.JSCContext   // out
	var _arg1 *C.JSCException // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.JSCException)(unsafe.Pointer(coreglib.InternObject(exception).Native()))

	C.jsc_context_throw_exception(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(exception)
}

// ThrowWithName: throw an exception to context using the given error
// name and message. The created CException can be retrieved with
// jsc_context_get_exception().
//
// The function takes the following parameters:
//
//   - errorName: error name.
//   - errorMessage: error message.
//
func (context *Context) ThrowWithName(errorName, errorMessage string) {
	var _arg0 *C.JSCContext // out
	var _arg1 *C.char       // out
	var _arg2 *C.char       // out

	_arg0 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(errorName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(errorMessage)))
	defer C.free(unsafe.Pointer(_arg2))

	C.jsc_context_throw_with_name(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(errorName)
	runtime.KeepAlive(errorMessage)
}

// ContextGetCurrent: get the CContext that is currently executing a function.
// This should only be called within a function or method callback, otherwise
// NULL will be returned.
//
// The function returns the following values:
//
//   - context (optional) that is currently executing.
//
func ContextGetCurrent() *Context {
	var _cret *C.JSCContext // in

	_cret = C.jsc_context_get_current()

	var _context *Context // out

	if _cret != nil {
		_context = wrapContext(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _context
}

// ContextClass: instance of this type is always passed by reference.
type ContextClass struct {
	*contextClass
}

// contextClass is the struct that's finalized.
type contextClass struct {
	native *C.JSCContextClass
}
