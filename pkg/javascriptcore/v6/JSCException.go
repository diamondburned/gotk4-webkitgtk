// Code generated by girgen. DO NOT EDIT.

package javascriptcore

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <jsc/jsc.h>
import "C"

// GType values.
var (
	GTypeException = coreglib.Type(C.jsc_exception_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeException, F: marshalException},
	})
}

// ExceptionOverrides contains methods that are overridable.
type ExceptionOverrides struct {
}

func defaultExceptionOverrides(v *Exception) ExceptionOverrides {
	return ExceptionOverrides{}
}

// Exception represents a JavaScript exception.
type Exception struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Exception)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Exception, *ExceptionClass, ExceptionOverrides](
		GTypeException,
		initExceptionClass,
		wrapException,
		defaultExceptionOverrides,
	)
}

func initExceptionClass(gclass unsafe.Pointer, overrides ExceptionOverrides, classInitFunc func(*ExceptionClass)) {
	if classInitFunc != nil {
		class := (*ExceptionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapException(obj *coreglib.Object) *Exception {
	return &Exception{
		Object: obj,
	}
}

func marshalException(p uintptr) (interface{}, error) {
	return wrapException(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewException: create a new CException in context with message.
//
// The function takes the following parameters:
//
//   - context: CContext.
//   - message: error message.
//
// The function returns the following values:
//
//   - exception: new CException.
//
func NewException(context *Context, message string) *Exception {
	var _arg1 *C.JSCContext   // out
	var _arg2 *C.char         // out
	var _cret *C.JSCException // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.jsc_exception_new(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(message)

	var _exception *Exception // out

	_exception = wrapException(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _exception
}

// NewExceptionWithName: create a new CException in context with name and
// message.
//
// The function takes the following parameters:
//
//   - context: CContext.
//   - name: error name.
//   - message: error message.
//
// The function returns the following values:
//
//   - exception: new CException.
//
func NewExceptionWithName(context *Context, name, message string) *Exception {
	var _arg1 *C.JSCContext   // out
	var _arg2 *C.char         // out
	var _arg3 *C.char         // out
	var _cret *C.JSCException // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.jsc_exception_new_with_name(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(name)
	runtime.KeepAlive(message)

	var _exception *Exception // out

	_exception = wrapException(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _exception
}

// BacktraceString: get a string with the exception backtrace.
//
// The function returns the following values:
//
//   - utf8 (optional): exception backtrace string or NULL.
//
func (exception *Exception) BacktraceString() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(coreglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_backtrace_string(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ColumnNumber: get the column number at which exception happened.
//
// The function returns the following values:
//
//   - guint: column number of exception.
//
func (exception *Exception) ColumnNumber() uint {
	var _arg0 *C.JSCException // out
	var _cret C.guint         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(coreglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_column_number(_arg0)
	runtime.KeepAlive(exception)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// LineNumber: get the line number at which exception happened.
//
// The function returns the following values:
//
//   - guint: line number of exception.
//
func (exception *Exception) LineNumber() uint {
	var _arg0 *C.JSCException // out
	var _cret C.guint         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(coreglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_line_number(_arg0)
	runtime.KeepAlive(exception)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Message: get the error message of exception.
//
// The function returns the following values:
//
//   - utf8: exception error message.
//
func (exception *Exception) Message() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(coreglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_message(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Name: get the error name of exception.
//
// The function returns the following values:
//
//   - utf8: exception error name.
//
func (exception *Exception) Name() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(coreglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_name(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SourceURI: get the source URI of exception.
//
// The function returns the following values:
//
//   - utf8 (optional): the source URI of exception, or NULL.
//
func (exception *Exception) SourceURI() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(coreglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_source_uri(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Report: return a report message of exception, containing all the possible
// details such us source URI, line, column and backtrace, and formatted to be
// printed.
//
// The function returns the following values:
//
//   - utf8: new string with the exception report.
//
func (exception *Exception) Report() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(coreglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_report(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// String: get the string representation of exception error.
//
// The function returns the following values:
//
//   - utf8: string representation of exception.
//
func (exception *Exception) String() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(coreglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_to_string(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ExceptionClass: instance of this type is always passed by reference.
type ExceptionClass struct {
	*exceptionClass
}

// exceptionClass is the struct that's finalized.
type exceptionClass struct {
	native *C.JSCExceptionClass
}
