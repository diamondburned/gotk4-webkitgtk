// Code generated by girgen. DO NOT EDIT.

package webkitwebprocessextension

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4-webkitgtk/pkg/javascriptcore/v6"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit/webkit-web-process-extension.h>
// extern void _gotk4_webkitwebprocessextension6_WebFormManager_ConnectWillSubmitForm(gpointer, JSCValue*, WebKitFrame*, WebKitFrame*, guintptr);
// extern void _gotk4_webkitwebprocessextension6_WebFormManager_ConnectWillSendSubmitEvent(gpointer, JSCValue*, WebKitFrame*, WebKitFrame*, guintptr);
import "C"

// GType values.
var (
	GTypeWebFormManager = coreglib.Type(C.webkit_web_form_manager_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeWebFormManager, F: marshalWebFormManager},
	})
}

// WebFormManagerOverrides contains methods that are overridable.
type WebFormManagerOverrides struct {
}

func defaultWebFormManagerOverrides(v *WebFormManager) WebFormManagerOverrides {
	return WebFormManagerOverrides{}
}

// WebFormManager: form manager of a KitWebPage in a KitScriptWorld.
type WebFormManager struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*WebFormManager)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*WebFormManager, *WebFormManagerClass, WebFormManagerOverrides](
		GTypeWebFormManager,
		initWebFormManagerClass,
		wrapWebFormManager,
		defaultWebFormManagerOverrides,
	)
}

func initWebFormManagerClass(gclass unsafe.Pointer, overrides WebFormManagerOverrides, classInitFunc func(*WebFormManagerClass)) {
	if classInitFunc != nil {
		class := (*WebFormManagerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWebFormManager(obj *coreglib.Object) *WebFormManager {
	return &WebFormManager{
		Object: obj,
	}
}

func marshalWebFormManager(p uintptr) (interface{}, error) {
	return wrapWebFormManager(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectWillSendSubmitEvent: this signal is emitted when the DOM submit event
// is about to be fired for form. JavaScript code may rely on the submit event
// to detect that the user has clicked on a submit button, and to possibly
// cancel the form submission before KitWebFormManager::will-submit-form signal
// is emitted. However, beware that, for historical reasons, the submit event
// is not emitted at all if the form submission is triggered by JavaScript.
// For these reasons, this signal may not be used to reliably detect whether a
// form will be submitted. Instead, use it to detect if a user has clicked on a
// form's submit button even if JavaScript later cancels the form submission,
// or to read the values of the form's fields even if JavaScript later
// clears certain fields before submitting. This may be needed, for example,
// to implement a robust browser password manager, as some misguided websites
// may use such techniques to attempt to thwart password managers.
func (v *WebFormManager) ConnectWillSendSubmitEvent(f func(form *javascriptcore.Value, sourceFrame, targetFrame *Frame)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "will-send-submit-event", false, unsafe.Pointer(C._gotk4_webkitwebprocessextension6_WebFormManager_ConnectWillSendSubmitEvent), f)
}

// ConnectWillSubmitForm: this signal is emitted when form will imminently
// be submitted. It can no longer be cancelled. This event always occurs
// immediately before a form is submitted to its target, so use this event
// to reliably detect when a form is submitted. This signal is emitted after
// KitWebFormManager::will-send-submit-event if that signal is emitted.
func (v *WebFormManager) ConnectWillSubmitForm(f func(form *javascriptcore.Value, sourceFrame, targetFrame *Frame)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "will-submit-form", false, unsafe.Pointer(C._gotk4_webkitwebprocessextension6_WebFormManager_ConnectWillSubmitForm), f)
}

// WebFormManagerInputElementAutoFill: set the value of an HTML input element as
// if it had been edited by the user, triggering a change event, and set it as
// filled automatically. If element is not an HTML input element this function
// does nothing.
//
// The function takes the following parameters:
//
//   - element: CValue.
//   - value: text to set.
//
func WebFormManagerInputElementAutoFill(element *javascriptcore.Value, value string) {
	var _arg1 *C.JSCValue // out
	var _arg2 *C.char     // out

	_arg1 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))

	C.webkit_web_form_manager_input_element_auto_fill(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(value)
}

// WebFormManagerInputElementIsAutoFilled: get whether element is an HTML input
// element that has been filled automatically.
//
// The function takes the following parameters:
//
//   - element: CValue.
//
// The function returns the following values:
//
//   - ok: TRUE if element is an HTML input element that has been filled
//     automatically, or FALSE otherwise.
//
func WebFormManagerInputElementIsAutoFilled(element *javascriptcore.Value) bool {
	var _arg1 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg1 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.webkit_web_form_manager_input_element_is_auto_filled(_arg1)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WebFormManagerInputElementIsUserEdited: get whether element is an HTML text
// input element that has been edited by a user action.
//
// The function takes the following parameters:
//
//   - element: CValue.
//
// The function returns the following values:
//
//   - ok: TRUE if element is an HTML text input element that has been edited by
//     a user action, or FALSE otherwise.
//
func WebFormManagerInputElementIsUserEdited(element *javascriptcore.Value) bool {
	var _arg1 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg1 = (*C.JSCValue)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.webkit_web_form_manager_input_element_is_user_edited(_arg1)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
