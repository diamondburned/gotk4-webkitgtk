// Code generated by girgen. DO NOT EDIT.

package webkitwebprocessextension

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit/webkit-web-process-extension.h>
// extern void _gotk4_webkitwebprocessextension6_WebProcessExtension_ConnectUserMessageReceived(gpointer, WebKitUserMessage*, guintptr);
// extern void _gotk4_webkitwebprocessextension6_WebProcessExtension_ConnectPageCreated(gpointer, WebKitWebPage*, guintptr);
import "C"

// GType values.
var (
	GTypeWebProcessExtension = coreglib.Type(C.webkit_web_process_extension_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeWebProcessExtension, F: marshalWebProcessExtension},
	})
}

// WebProcessExtensionOverrides contains methods that are overridable.
type WebProcessExtensionOverrides struct {
}

func defaultWebProcessExtensionOverrides(v *WebProcessExtension) WebProcessExtensionOverrides {
	return WebProcessExtensionOverrides{}
}

// WebProcessExtension represents an extension of the web process.
//
// WebKitWebProcessExtension is a loadable module for the web process. It allows
// you to execute code in the web process and being able to use the DOM API,
// to change any request or to inject custom JavaScript code, for example.
//
// To create a WebKitWebProcessExtension you should write
// a module with an initialization function that could be
// either webkit_web_process_extension_initialize() with
// prototype KitWebProcessExtensionInitializeFunction or
// webkit_web_process_extension_initialize_with_user_data() with prototype
// KitWebProcessExtensionInitializeWithUserDataFunction. This function has to be
// public and it has to use the MODULE_EXPORT macro. It is called when the web
// process is initialized.
//
//    static void
//    web_page_created_callback (WebKitWebProcessExtension *extension,
//                               WebKitWebPage             *web_page,
//                               gpointer                   user_data)
//    {
//        g_print ("Page d created for s\n",
//                 webkit_web_page_get_id (web_page),
//                 webkit_web_page_get_uri (web_page));
//    }
//
//    G_MODULE_EXPORT void
//    webkit_web_process_extension_initialize (WebKitWebProcessExtension *extension)
//    {
//        g_signal_connect (extension, "page-created",
//                          G_CALLBACK (web_page_created_callback),
//                          NULL);
//    }
//
// The previous piece of code shows a trivial example of an extension that
// notifies when a KitWebPage is created.
//
// WebKit has to know where it can find the created WebKitWebProcessExtension.
// To do so you should use the webkit_web_context_set_web_extensions_directory()
// function. The signal KitWebContext::initialize-web-extensions is the
// recommended place to call it.
//
// To provide the initialization data used by the
// webkit_web_process_extension_initialize_with_user_data() function, you have
// to call webkit_web_context_set_web_extensions_initialization_user_data()
// with the desired data as parameter. You can see an example of this in the
// following piece of code:
//
//    #define WEB_EXTENSIONS_DIRECTORY // ...
//
//    static void
//    initialize_web_extensions (WebKitWebContext *context,
//                               gpointer          user_data)
//    {
//      // Web Extensions get a different ID for each Web Process
//      static guint32 unique_id = 0;
//
//      webkit_web_context_set_web_extensions_directory (
//         context, WEB_EXTENSIONS_DIRECTORY);
//      webkit_web_context_set_web_extensions_initialization_user_data (
//         context, g_variant_new_uint32 (unique_id++));
//    }
//
//    int main (int argc, char **argv)
//    {
//      g_signal_connect (webkit_web_context_get_default (),
//                       "initialize-web-extensions",
//                        G_CALLBACK (initialize_web_extensions),
//                        NULL);
//
//      GtkWidget *view = webkit_web_view_new ();
//
//      // ...
//    }.
type WebProcessExtension struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*WebProcessExtension)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*WebProcessExtension, *WebProcessExtensionClass, WebProcessExtensionOverrides](
		GTypeWebProcessExtension,
		initWebProcessExtensionClass,
		wrapWebProcessExtension,
		defaultWebProcessExtensionOverrides,
	)
}

func initWebProcessExtensionClass(gclass unsafe.Pointer, overrides WebProcessExtensionOverrides, classInitFunc func(*WebProcessExtensionClass)) {
	if classInitFunc != nil {
		class := (*WebProcessExtensionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWebProcessExtension(obj *coreglib.Object) *WebProcessExtension {
	return &WebProcessExtension{
		Object: obj,
	}
}

func marshalWebProcessExtension(p uintptr) (interface{}, error) {
	return wrapWebProcessExtension(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectPageCreated: this signal is emitted when a new KitWebPage is created
// in the Web Process.
func (extension *WebProcessExtension) ConnectPageCreated(f func(webPage *WebPage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(extension, "page-created", false, unsafe.Pointer(C._gotk4_webkitwebprocessextension6_WebProcessExtension_ConnectPageCreated), f)
}

// ConnectUserMessageReceived: this signal is emitted when a KitUserMessage is
// received from the KitWebContext corresponding to extension. Messages sent by
// KitWebContext are always broadcasted to all web extensions and they can't be
// replied to. Calling webkit_user_message_send_reply() will do nothing.
func (extension *WebProcessExtension) ConnectUserMessageReceived(f func(message *UserMessage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(extension, "user-message-received", false, unsafe.Pointer(C._gotk4_webkitwebprocessextension6_WebProcessExtension_ConnectUserMessageReceived), f)
}

// Page: get the web page of the given page_id.
//
// The function takes the following parameters:
//
//   - pageId: identifier of the KitWebPage to get.
//
// The function returns the following values:
//
//   - webPage for the given page_id, or NULL if the identifier doesn't
//     correspond to an existing web page.
//
func (extension *WebProcessExtension) Page(pageId uint64) *WebPage {
	var _arg0 *C.WebKitWebProcessExtension // out
	var _arg1 C.guint64                    // out
	var _cret *C.WebKitWebPage             // in

	_arg0 = (*C.WebKitWebProcessExtension)(unsafe.Pointer(coreglib.InternObject(extension).Native()))
	_arg1 = C.guint64(pageId)

	_cret = C.webkit_web_process_extension_get_page(_arg0, _arg1)
	runtime.KeepAlive(extension)
	runtime.KeepAlive(pageId)

	var _webPage *WebPage // out

	_webPage = wrapWebPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _webPage
}

// SendMessageToContextFinish: finish an asynchronous operation started with
// webkit_web_process_extension_send_message_to_context().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - userMessage with the reply or NULL in case of error.
//
func (extension *WebProcessExtension) SendMessageToContextFinish(result gio.AsyncResulter) (*UserMessage, error) {
	var _arg0 *C.WebKitWebProcessExtension // out
	var _arg1 *C.GAsyncResult              // out
	var _cret *C.WebKitUserMessage         // in
	var _cerr *C.GError                    // in

	_arg0 = (*C.WebKitWebProcessExtension)(unsafe.Pointer(coreglib.InternObject(extension).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.webkit_web_process_extension_send_message_to_context_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(extension)
	runtime.KeepAlive(result)

	var _userMessage *UserMessage // out
	var _goerr error              // out

	_userMessage = wrapUserMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _userMessage, _goerr
}
